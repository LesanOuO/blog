<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Git中提高效率的5条命令 | Lesan's Blog</title><meta name=keywords content="Git"><meta name=description content="前言
使用 Git 作为代码版本管理，早已是现在开发工程师必备的技能。可大多数工程师还是只会最基本的保存、拉取、推送，遇到一些commit管理的问题就束手无策，或者用一些不优雅的方式解决。"><meta name=author content="Lesan"><link rel=canonical href=https://lesanouo.github.io/blog/posts/code/170196480001/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://lesanouo.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://lesanouo.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://lesanouo.github.io/blog/favicon.ico><link rel=apple-touch-icon href=https://lesanouo.github.io/blog/favicon.ico><link rel=mask-icon href=https://lesanouo.github.io/blog/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-cn href=https://lesanouo.github.io/blog/posts/code/170196480001/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:url" content="https://lesanouo.github.io/blog/posts/code/170196480001/"><meta property="og:site_name" content="Lesan's Blog"><meta property="og:title" content="Git中提高效率的5条命令"><meta property="og:description" content="前言 使用 Git 作为代码版本管理，早已是现在开发工程师必备的技能。可大多数工程师还是只会最基本的保存、拉取、推送，遇到一些commit管理的问题就束手无策，或者用一些不优雅的方式解决。"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-12-08T00:00:00+00:00"><meta property="article:modified_time" content="2023-12-08T00:00:00+00:00"><meta property="article:tag" content="Git"><meta name=twitter:card content="summary"><meta name=twitter:title content="Git中提高效率的5条命令"><meta name=twitter:description content="前言
使用 Git 作为代码版本管理，早已是现在开发工程师必备的技能。可大多数工程师还是只会最基本的保存、拉取、推送，遇到一些commit管理的问题就束手无策，或者用一些不优雅的方式解决。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"📚 博客","item":"https://lesanouo.github.io/blog/posts/"},{"@type":"ListItem","position":2,"name":"Git中提高效率的5条命令","item":"https://lesanouo.github.io/blog/posts/code/170196480001/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Git中提高效率的5条命令","name":"Git中提高效率的5条命令","description":"前言 使用 Git 作为代码版本管理，早已是现在开发工程师必备的技能。可大多数工程师还是只会最基本的保存、拉取、推送，遇到一些commit管理的问题就束手无策，或者用一些不优雅的方式解决。\n","keywords":["Git"],"articleBody":"前言 使用 Git 作为代码版本管理，早已是现在开发工程师必备的技能。可大多数工程师还是只会最基本的保存、拉取、推送，遇到一些commit管理的问题就束手无策，或者用一些不优雅的方式解决。\n本文分享我在开发工作中实践过的实用命令。这些都能够大大提高工作效率，还能解决不少疑难场景。下面会介绍命令，列出应用场景，手把手教学使用，让大家看完即学会。\nstash 描述 官方解释：当您想记录工作目录和索引的当前状态，但又想返回一个干净的工作目录时，请使用git stash。该命令将保存本地修改，并恢复工作目录以匹配头部提交。\nstash 命令能够将还未 commit 的代码存起来，让你的工作目录变得干净。\n应用场景 我猜你心里一定在想：为什么要变干净？\n应用场景：某一天你正在 feature 分支开发新需求，突然产品经理跑过来说线上有bug，必须马上修复。而此时你的功能开发到一半，于是你急忙想切到 master 分支，然后你就会看到报错：Please commit your change or stash them before you switch branches.\n因为当前有文件更改了，需要提交commit保持工作区干净才能切分支。由于情况紧急，你只有急忙 commit 上去，commit 信息也随便写了个“暂存代码”，于是该分支提交记录就留了一条黑历史\n命令使用 如果你学会 stash，就不用那么狼狈了。你只需要：git stash\n就这么简单，代码就被存起来了。\n当你修复完线上问题，切回 feature 分支，想恢复代码也只需要：git stash apply\n相关命令\n# 保存当前未commit的代码\rgit stash\r# 保存当前未commit的代码并添加备注\rgit stash save \"备注的内容\"\r# 列出stash的所有记录\rgit stash list\r# 删除stash的所有记录\rgit stash clear\r# 应用最近一次的stash\rgit stash apply\r# 应用最近一次的stash，随后删除该记录\rgit stash pop\r# 删除最近的一次stash\rgit stash drop 当有多条 stash，可以指定操作stash，首先使用stash list 列出所有记录：\n$ git stash list\rstash@{0}: WIP on ...\rstash@{1}: WIP on ...\rstash@{2}: On ... 应用第二条记录：\n$ git stash apply stash@{1} pop，drop 同理。\nreset –soft 描述 完全不接触索引文件或工作树（但会像所有模式一样，将头部重置为）。这使您的所有更改的文件更改为“要提交的更改”。\n回退你已提交的 commit，并将 commit 的修改内容放回到暂存区。\n一般我们在使用 reset 命令时，git reset –hard会被提及的比较多，它能让 commit 记录强制回溯到某一个节点。而git reset –soft的作用正如其名，–soft(柔软的) 除了回溯节点外，还会保留节点的修改内容。\n应用场景 回溯节点，为什么要保留修改内容？\n应用场景1：有时候手滑不小心把不该提交的内容 commit 了，这时想改回来，只能再 commit 一次，又多一条“黑历史”。\n应用场景2：规范些的团队，一般对于 commit 的内容要求职责明确，颗粒度要细，便于后续出现问题排查。本来属于两块不同功能的修改，一起 commit 上去，这种就属于不规范。这次恰好又手滑了，一次性 commit 上去。\n命令使用 学会reset –soft之后，你只需要：\n# 恢复最近一次 commit\rgit reset --soft HEAD^ reset –soft相当于后悔药，给你重新改过的机会。对于上面的场景，就可以再次修改重新提交，保持干净的 commit 记录。\n以上说的是还未 push 的commit。对于已经 push 的 commit，也可以使用该命令，不过再次 push 时，由于远程分支和本地分支有差异，需要强制推送git push -f来覆盖被 reset 的 commit。\n还有一点需要注意，在reset –soft指定 commit 号时，会将该 commit 到最近一次 commit 的所有修改内容全部恢复，而不是只针对该 commit。\n举个例子：\ncommit 记录有 c、b、a。\nreset 到 a。\ngit reset --soft 1a900ac29eba73ce817bf959f82ffcb0bfa38f75\n此时的 HEAD 到了 a，而 b、c 的修改内容都回到了暂存区。\ncherry-pick 描述 给定一个或多个现有提交，应用每个提交引入的更改，为每个提交记录一个新的提交。这需要您的工作树清洁（没有从头提交的修改）。\n将已经提交的 commit，复制出新的 commit 应用到分支里\n应用场景 commit 都提交了，为什么还要复制新的出来？\n应用场景1：有时候版本的一些优化需求开发到一半，可能其中某一个开发完的需求要临时上，或者某些原因导致待开发的需求卡住了已开发完成的需求上线。这时候就需要把 commit 抽出来，单独处理。\n应用场景2：有时候开发分支中的代码记录被污染了，导致开发分支合到线上分支有问题，这时就需要拉一条干净的开发分支，再从旧的开发分支中，把 commit 复制到新分支。\n命令使用 复制单个 需要把 b 复制到另一个分支，首先把 commitHash 复制下来，然后切到 master 分支。\n当前 master 最新的记录是 a，使用cherry-pick把 b 应用到当前分支。\ngit cherry-pick 1a900ac29eba73ce817bf959f82ffcb0bfa38f75\n完成后看下最新的 log，b 已经应用到 master，作为最新的 commit 了。可以看到 commitHash 和之前的不一样，但是提交时间还是保留之前的。\n复制多个 以上是单个 commit 的复制，下面再来看看 cherry-pick 多个 commit 要如何操作。\n一次转移多个提交：\ngit cherry-pick commit1 commit2\n上面的命令将 commit1 和 commit2 两个提交应用到当前分支。\n多个连续的commit，也可区间复制：\ngit cherry-pick commit1^..commit2\n上面的命令将 commit1 到 commit2 这个区间的 commit 都应用到当前分支（包含commit1、commit2），commit1 是最早的提交。\ncherry-pick 代码冲突 在cherry-pick多个commit时，可能会遇到代码冲突，这时cherry-pick会停下来，让用户决定如何继续操作。下面看看怎么解决这种场景。\n还是 feature 分支，现在需要把 c、d、e 都复制到 master 分支上。先把起点c和终点e的 commitHash 记下来。\n切到 master 分支，使用区间的cherry-pick。可以看到 c 被成功复制，当进行到 d 时，发现代码冲突，cherry-pick中断了。这时需要解决代码冲突，重新提交到暂存区。\n然后使用cherry-pick –continue让cherry-pick继续进行下去。最后 e 也被复制进来，整个流程就完成了。\n以上是完整的流程，但有时候可能需要在代码冲突后，放弃或者退出流程：\n放弃 cherry-pick：\ngit cherry-pick --abort\n回到操作前的样子，就像什么都没发生过。\n退出 cherry-pick：\ngit cherry-pick --quit\n不回到操作前的样子。即保留已经cherry-pick成功的 commit，并退出cherry-pick流程。\nrevert 描述 给定一个或多个现有提交，恢复相关提交引入的更改，并记录一些这些更改的新提交。这就要求你的工作树是干净的（没有来自头部的修改）。\n将现有的提交还原，恢复提交的内容，并生成一条还原记录。\n应用场景 应用场景：有一天测试突然跟你说，你开发上线的功能有问题，需要马上撤回，否则会影响到系统使用。这时可能会想到用 reset 回退，可是你看了看分支上最新的提交还有其他同事的代码，用 reset 会把这部分代码也撤回了。由于情况紧急，又想不到好方法，还是任性的使用 reset，然后再让同事把他的代码合一遍（同事听到想打人），于是你的技术形象在同事眼里一落千丈。\n命令使用 revert 普通提交 学会 revert 之后，立马就可以拯救这种尴尬的情况。\ngit revert 21dcd937fe555f58841b17466a99118deb489212\nrevert 掉自己提交的 commit。\n因为 revert 会生成一条新的提交记录，这时会让你编辑提交信息，编辑完后 :wq 保存退出就好了。\n再来看下最新的 log，生成了一条 revert 记录，虽然自己之前的提交记录还是会保留着，但你修改的代码内容已经被撤回了。\nrevert 合并提交 在 git 的 commit 记录里，还有一种类型是合并提交，想要 revert 合并提交，使用上会有些不一样。\n现在的 master 分支里多了条合并提交。\n使用刚刚同样的 revert 方法，会发现命令行报错了。为什么会这样？在官方文档中有解释。\n通常无法 revert 合并，因为您不知道合并的哪一侧应被视为主线。此选项指定主线的父编号（从1开始），并允许 revert 反转相对于指定父编号的更改\n我的理解是因为合并提交是两条分支的交集节点，而 git 不知道需要撤销的哪一条分支，需要添加参数 -m 指定主线分支，保留主线分支的代码，另一条则被撤销。\n-m 后面要跟一个 parent number 标识出\"主线\"，一般使用 1 保留主分支代码。\ngit revert -m 1 revert 合并提交后，再次合并分支会失效 还是上面的场景，在 master 分支 revert 合并提交后，然后切到 feature 分支修复好 bug，再合并到 master 分支时，会发现之前被 revert 的修改内容没有重新合并进来。\n因为使用 revert 后， feature 分支的 commit 还是会保留在 master 分支的记录中，当你再次合并进去时，git 判断有相同的 commitHash，就忽略了相关 commit 修改的内容。\n这时就需要 revert 掉之前 revert 的合并提交，有点拗口，接下来看操作吧。\n现在 master 的记录是这样的。\n再次使用 revert，之前被 revert 的修改内容就又回来了。\nreflog 描述 此命令管理重录中记录的信息。\n如果说reset –soft是后悔药，那 reflog 就是强力后悔药。它记录了所有的 commit 操作记录，便于错误操作后找回记录。\n应用场景 应用场景：某天你眼花，发现自己在其他人分支提交了代码还推到远程分支，这时因为分支只有你的最新提交，就想着使用reset –hard，结果紧张不小心记错了 commitHash，reset 过头，把同事的 commit 搞没了。没办法，reset –hard是强制回退的，找不到 commitHash 了，只能让同事从本地分支再推一次（同事瞬间拳头就硬了，怎么又是你）。于是，你的技术形象又一落千丈。\n命令使用 分支记录如上，想要 reset 到 b。\n误操作 reset 过头，b 没了，最新的只剩下 a。\n这时用git reflog查看历史记录，把错误提交的那次 commitHash 记下。\n再次 reset 回去，就会发现 b 回来了。\n总结 本文主要分享了5个在开发中实用的 Git 命令和设置短命令的方式。\nstash：存储临时代码。 reset –soft：软回溯，回退 commit 的同时保留修改内容。 cherry-pick：复制 commit。 revert：撤销 commit 的修改内容。 reflog：记录了 commit 的历史操作。 ","wordCount":"3774","inLanguage":"zh-cn","datePublished":"2023-12-08T00:00:00Z","dateModified":"2023-12-08T00:00:00Z","author":{"@type":"Person","name":"Lesan"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://lesanouo.github.io/blog/posts/code/170196480001/"},"publisher":{"@type":"Organization","name":"Lesan's Blog","logo":{"@type":"ImageObject","url":"https://lesanouo.github.io/blog/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://lesanouo.github.io/blog/ accesskey=h title="Lesan's Blog (Alt + H)">Lesan's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://lesanouo.github.io/blog/archives title="📚 归档"><span>📚 归档</span></a></li><li><a href=https://lesanouo.github.io/blog/categories/ title="🗃️ 分类"><span>🗃️ 分类</span></a></li><li><a href=https://lesanouo.github.io/blog/tags/ title="🏷️ 标签"><span>🏷️ 标签</span></a></li><li><a href=https://lesanouo.github.io/blog/search/ title="🔎 搜索"><span>🔎 搜索</span></a></li><li><a href=https://lesanouo.github.io/blog/about/ title="👨‍💻 关于我"><span>👨‍💻 关于我</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://lesanouo.github.io/blog/>Home</a>&nbsp;»&nbsp;<a href=https://lesanouo.github.io/blog/posts/>📚 博客</a></div><h1 class="post-title entry-hint-parent">Git中提高效率的5条命令</h1><div class=post-meta><span title='2023-12-08 00:00:00 +0000 UTC'>2023-12-08</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Lesan</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%89%8d%e8%a8%80 aria-label=前言>前言</a></li><li><a href=#stash aria-label=stash>stash</a><ul><li><a href=#%e6%8f%8f%e8%bf%b0 aria-label=描述>描述</a></li><li><a href=#%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af aria-label=应用场景>应用场景</a></li><li><a href=#%e5%91%bd%e4%bb%a4%e4%bd%bf%e7%94%a8 aria-label=命令使用>命令使用</a></li></ul></li><li><a href=#reset-soft aria-label="reset &ndash;soft">reset &ndash;soft</a><ul><li><a href=#%e6%8f%8f%e8%bf%b0-1 aria-label=描述>描述</a></li><li><a href=#%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af-1 aria-label=应用场景>应用场景</a></li><li><a href=#%e5%91%bd%e4%bb%a4%e4%bd%bf%e7%94%a8-1 aria-label=命令使用>命令使用</a></li></ul></li><li><a href=#cherry-pick aria-label=cherry-pick>cherry-pick</a><ul><li><a href=#%e6%8f%8f%e8%bf%b0-2 aria-label=描述>描述</a></li><li><a href=#%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af-2 aria-label=应用场景>应用场景</a></li><li><a href=#%e5%91%bd%e4%bb%a4%e4%bd%bf%e7%94%a8-2 aria-label=命令使用>命令使用</a></li></ul></li><li><a href=#revert aria-label=revert>revert</a><ul><li><a href=#%e6%8f%8f%e8%bf%b0-3 aria-label=描述>描述</a></li><li><a href=#%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af-3 aria-label=应用场景>应用场景</a></li><li><a href=#%e5%91%bd%e4%bb%a4%e4%bd%bf%e7%94%a8-3 aria-label=命令使用>命令使用</a></li></ul></li><li><a href=#reflog aria-label=reflog>reflog</a><ul><li><a href=#%e6%8f%8f%e8%bf%b0-4 aria-label=描述>描述</a></li><li><a href=#%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af-4 aria-label=应用场景>应用场景</a></li><li><a href=#%e5%91%bd%e4%bb%a4%e4%bd%bf%e7%94%a8-4 aria-label=命令使用>命令使用</a></li></ul></li><li><a href=#%e6%80%bb%e7%bb%93 aria-label=总结>总结</a></li></ul></div></details></div><div class=post-content><h2 id=前言>前言<a hidden class=anchor aria-hidden=true href=#前言>#</a></h2><p>使用 Git 作为代码版本管理，早已是现在开发工程师必备的技能。可大多数工程师还是只会最基本的保存、拉取、推送，遇到一些commit管理的问题就束手无策，或者用一些不优雅的方式解决。</p><p>本文分享我在开发工作中实践过的实用命令。这些都能够大大提高工作效率，还能解决不少疑难场景。下面会介绍命令，列出应用场景，手把手教学使用，让大家看完即学会。</p><h2 id=stash>stash<a hidden class=anchor aria-hidden=true href=#stash>#</a></h2><h3 id=描述>描述<a hidden class=anchor aria-hidden=true href=#描述>#</a></h3><p>官方解释：当您想记录工作目录和索引的当前状态，但又想返回一个干净的工作目录时，请使用git stash。该命令将保存本地修改，并恢复工作目录以匹配头部提交。</p><p>stash 命令能够将还未 commit 的代码存起来，让你的工作目录变得干净。</p><h3 id=应用场景>应用场景<a hidden class=anchor aria-hidden=true href=#应用场景>#</a></h3><p>我猜你心里一定在想：为什么要变干净？</p><p>应用场景：某一天你正在 feature 分支开发新需求，突然产品经理跑过来说线上有bug，必须马上修复。而此时你的功能开发到一半，于是你急忙想切到 master 分支，然后你就会看到报错：<code>Please commit your change or stash them before you switch branches.</code></p><p>因为当前有文件更改了，需要提交commit保持工作区干净才能切分支。由于情况紧急，你只有急忙 commit 上去，commit 信息也随便写了个“暂存代码”，于是该分支提交记录就留了一条黑历史</p><h3 id=命令使用>命令使用<a hidden class=anchor aria-hidden=true href=#命令使用>#</a></h3><p>如果你学会 stash，就不用那么狼狈了。你只需要：<code>git stash</code></p><p>就这么简单，代码就被存起来了。</p><p>当你修复完线上问题，切回 feature 分支，想恢复代码也只需要：<code>git stash apply</code></p><p>相关命令</p><pre tabindex=0><code># 保存当前未commit的代码
git stash

# 保存当前未commit的代码并添加备注
git stash save &#34;备注的内容&#34;

# 列出stash的所有记录
git stash list

# 删除stash的所有记录
git stash clear

# 应用最近一次的stash
git stash apply

# 应用最近一次的stash，随后删除该记录
git stash pop

# 删除最近的一次stash
git stash drop
</code></pre><p>当有多条 stash，可以指定操作stash，首先使用stash list 列出所有记录：</p><pre tabindex=0><code>$ git stash list
stash@{0}: WIP on ...
stash@{1}: WIP on ...
stash@{2}: On ...
</code></pre><p>应用第二条记录：</p><pre tabindex=0><code>$ git stash apply stash@{1}
</code></pre><p>pop，drop 同理。</p><h2 id=reset-soft>reset &ndash;soft<a hidden class=anchor aria-hidden=true href=#reset-soft>#</a></h2><h3 id=描述-1>描述<a hidden class=anchor aria-hidden=true href=#描述-1>#</a></h3><p>完全不接触索引文件或工作树（但会像所有模式一样，将头部重置为）。这使您的所有更改的文件更改为“要提交的更改”。</p><p>回退你已提交的 commit，并将 commit 的修改内容放回到暂存区。</p><p>一般我们在使用 reset 命令时，git reset &ndash;hard会被提及的比较多，它能让 commit 记录强制回溯到某一个节点。而git reset &ndash;soft的作用正如其名，&ndash;soft(柔软的) 除了回溯节点外，还会保留节点的修改内容。</p><h3 id=应用场景-1>应用场景<a hidden class=anchor aria-hidden=true href=#应用场景-1>#</a></h3><p>回溯节点，为什么要保留修改内容？</p><p>应用场景1：有时候手滑不小心把不该提交的内容 commit 了，这时想改回来，只能再 commit 一次，又多一条“黑历史”。</p><p>应用场景2：规范些的团队，一般对于 commit 的内容要求职责明确，颗粒度要细，便于后续出现问题排查。本来属于两块不同功能的修改，一起 commit 上去，这种就属于不规范。这次恰好又手滑了，一次性 commit 上去。</p><h3 id=命令使用-1>命令使用<a hidden class=anchor aria-hidden=true href=#命令使用-1>#</a></h3><p>学会reset &ndash;soft之后，你只需要：</p><pre tabindex=0><code># 恢复最近一次 commit
git reset --soft HEAD^
</code></pre><p>reset &ndash;soft相当于后悔药，给你重新改过的机会。对于上面的场景，就可以再次修改重新提交，保持干净的 commit 记录。</p><p>以上说的是还未 push 的commit。对于已经 push 的 commit，也可以使用该命令，不过再次 push 时，由于远程分支和本地分支有差异，需要强制推送git push -f来覆盖被 reset 的 commit。</p><p>还有一点需要注意，在reset &ndash;soft指定 commit 号时，会将该 commit 到最近一次 commit 的所有修改内容全部恢复，而不是只针对该 commit。</p><p>举个例子：</p><p>commit 记录有 c、b、a。</p><p>reset 到 a。</p><p><code>git reset --soft 1a900ac29eba73ce817bf959f82ffcb0bfa38f75</code></p><p>此时的 HEAD 到了 a，而 b、c 的修改内容都回到了暂存区。</p><h2 id=cherry-pick>cherry-pick<a hidden class=anchor aria-hidden=true href=#cherry-pick>#</a></h2><h3 id=描述-2>描述<a hidden class=anchor aria-hidden=true href=#描述-2>#</a></h3><p>给定一个或多个现有提交，应用每个提交引入的更改，为每个提交记录一个新的提交。这需要您的工作树清洁（没有从头提交的修改）。</p><p>将已经提交的 commit，复制出新的 commit 应用到分支里</p><h3 id=应用场景-2>应用场景<a hidden class=anchor aria-hidden=true href=#应用场景-2>#</a></h3><p>commit 都提交了，为什么还要复制新的出来？</p><p>应用场景1：有时候版本的一些优化需求开发到一半，可能其中某一个开发完的需求要临时上，或者某些原因导致待开发的需求卡住了已开发完成的需求上线。这时候就需要把 commit 抽出来，单独处理。</p><p>应用场景2：有时候开发分支中的代码记录被污染了，导致开发分支合到线上分支有问题，这时就需要拉一条干净的开发分支，再从旧的开发分支中，把 commit 复制到新分支。</p><h3 id=命令使用-2>命令使用<a hidden class=anchor aria-hidden=true href=#命令使用-2>#</a></h3><ul><li>复制单个</li></ul><p>需要把 b 复制到另一个分支，首先把 commitHash 复制下来，然后切到 master 分支。</p><p>当前 master 最新的记录是 a，使用cherry-pick把 b 应用到当前分支。</p><p><code>git cherry-pick 1a900ac29eba73ce817bf959f82ffcb0bfa38f75</code></p><p>完成后看下最新的 log，b 已经应用到 master，作为最新的 commit 了。可以看到 commitHash 和之前的不一样，但是提交时间还是保留之前的。</p><ul><li>复制多个</li></ul><p>以上是单个 commit 的复制，下面再来看看 cherry-pick 多个 commit 要如何操作。</p><p>一次转移多个提交：</p><p><code>git cherry-pick commit1 commit2</code></p><p>上面的命令将 commit1 和 commit2 两个提交应用到当前分支。</p><p>多个连续的commit，也可区间复制：</p><p><code>git cherry-pick commit1^..commit2</code></p><p>上面的命令将 commit1 到 commit2 这个区间的 commit 都应用到当前分支（包含commit1、commit2），commit1 是最早的提交。</p><ul><li>cherry-pick 代码冲突</li></ul><p>在cherry-pick多个commit时，可能会遇到代码冲突，这时cherry-pick会停下来，让用户决定如何继续操作。下面看看怎么解决这种场景。</p><p>还是 feature 分支，现在需要把 c、d、e 都复制到 master 分支上。先把起点c和终点e的 commitHash 记下来。</p><p>切到 master 分支，使用区间的cherry-pick。可以看到 c 被成功复制，当进行到 d 时，发现代码冲突，cherry-pick中断了。这时需要解决代码冲突，重新提交到暂存区。</p><p>然后使用cherry-pick &ndash;continue让cherry-pick继续进行下去。最后 e 也被复制进来，整个流程就完成了。</p><p>以上是完整的流程，但有时候可能需要在代码冲突后，放弃或者退出流程：</p><p>放弃 cherry-pick：</p><p><code>git cherry-pick --abort</code></p><p>回到操作前的样子，就像什么都没发生过。</p><p>退出 cherry-pick：</p><p><code>git cherry-pick --quit</code></p><p>不回到操作前的样子。即保留已经cherry-pick成功的 commit，并退出cherry-pick流程。</p><h2 id=revert>revert<a hidden class=anchor aria-hidden=true href=#revert>#</a></h2><h3 id=描述-3>描述<a hidden class=anchor aria-hidden=true href=#描述-3>#</a></h3><p>给定一个或多个现有提交，恢复相关提交引入的更改，并记录一些这些更改的新提交。这就要求你的工作树是干净的（没有来自头部的修改）。</p><p>将现有的提交还原，恢复提交的内容，并生成一条还原记录。</p><h3 id=应用场景-3>应用场景<a hidden class=anchor aria-hidden=true href=#应用场景-3>#</a></h3><p>应用场景：有一天测试突然跟你说，你开发上线的功能有问题，需要马上撤回，否则会影响到系统使用。这时可能会想到用 reset 回退，可是你看了看分支上最新的提交还有其他同事的代码，用 reset 会把这部分代码也撤回了。由于情况紧急，又想不到好方法，还是任性的使用 reset，然后再让同事把他的代码合一遍（同事听到想打人），于是你的技术形象在同事眼里一落千丈。</p><h3 id=命令使用-3>命令使用<a hidden class=anchor aria-hidden=true href=#命令使用-3>#</a></h3><ul><li>revert 普通提交</li></ul><p>学会 revert 之后，立马就可以拯救这种尴尬的情况。</p><p><code>git revert 21dcd937fe555f58841b17466a99118deb489212</code></p><p>revert 掉自己提交的 commit。</p><p>因为 revert 会生成一条新的提交记录，这时会让你编辑提交信息，编辑完后 :wq 保存退出就好了。</p><p>再来看下最新的 log，生成了一条 revert 记录，虽然自己之前的提交记录还是会保留着，但你修改的代码内容已经被撤回了。</p><ul><li>revert 合并提交</li></ul><p>在 git 的 commit 记录里，还有一种类型是合并提交，想要 revert 合并提交，使用上会有些不一样。</p><p>现在的 master 分支里多了条合并提交。</p><p>使用刚刚同样的 revert 方法，会发现命令行报错了。为什么会这样？在官方文档中有解释。</p><p>通常无法 revert 合并，因为您不知道合并的哪一侧应被视为主线。此选项指定主线的父编号（从1开始），并允许 revert 反转相对于指定父编号的更改</p><p>我的理解是因为合并提交是两条分支的交集节点，而 git 不知道需要撤销的哪一条分支，需要添加参数 -m 指定主线分支，保留主线分支的代码，另一条则被撤销。</p><p>-m 后面要跟一个 parent number 标识出"主线"，一般使用 1 保留主分支代码。</p><p><code>git revert -m 1 &lt;commitHash></code></p><ul><li>revert 合并提交后，再次合并分支会失效</li></ul><p>还是上面的场景，在 master 分支 revert 合并提交后，然后切到 feature 分支修复好 bug，再合并到 master 分支时，会发现之前被 revert 的修改内容没有重新合并进来。</p><p>因为使用 revert 后， feature 分支的 commit 还是会保留在 master 分支的记录中，当你再次合并进去时，git 判断有相同的 commitHash，就忽略了相关 commit 修改的内容。</p><p>这时就需要 revert 掉之前 revert 的合并提交，有点拗口，接下来看操作吧。</p><p>现在 master 的记录是这样的。</p><p>再次使用 revert，之前被 revert 的修改内容就又回来了。</p><h2 id=reflog>reflog<a hidden class=anchor aria-hidden=true href=#reflog>#</a></h2><h3 id=描述-4>描述<a hidden class=anchor aria-hidden=true href=#描述-4>#</a></h3><p>此命令管理重录中记录的信息。</p><p>如果说reset &ndash;soft是后悔药，那 reflog 就是强力后悔药。它记录了所有的 commit 操作记录，便于错误操作后找回记录。</p><h3 id=应用场景-4>应用场景<a hidden class=anchor aria-hidden=true href=#应用场景-4>#</a></h3><p>应用场景：某天你眼花，发现自己在其他人分支提交了代码还推到远程分支，这时因为分支只有你的最新提交，就想着使用reset &ndash;hard，结果紧张不小心记错了 commitHash，reset 过头，把同事的 commit 搞没了。没办法，reset &ndash;hard是强制回退的，找不到 commitHash 了，只能让同事从本地分支再推一次（同事瞬间拳头就硬了，怎么又是你）。于是，你的技术形象又一落千丈。</p><h3 id=命令使用-4>命令使用<a hidden class=anchor aria-hidden=true href=#命令使用-4>#</a></h3><p>分支记录如上，想要 reset 到 b。</p><p>误操作 reset 过头，b 没了，最新的只剩下 a。</p><p>这时用git reflog查看历史记录，把错误提交的那次 commitHash 记下。</p><p>再次 reset 回去，就会发现 b 回来了。</p><h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><p>本文主要分享了5个在开发中实用的 Git 命令和设置短命令的方式。</p><ul><li>stash：存储临时代码。</li><li>reset &ndash;soft：软回溯，回退 commit 的同时保留修改内容。</li><li>cherry-pick：复制 commit。</li><li>revert：撤销 commit 的修改内容。</li><li>reflog：记录了 commit 的历史操作。</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://lesanouo.github.io/blog/tags/git/>Git</a></li></ul><nav class=paginav><a class=prev href=https://lesanouo.github.io/blog/posts/code/171423360001/><span class=title>«</span><br><span>Linux系统使用systemd配置.NET项目开机自启动</span>
</a><a class=next href=https://lesanouo.github.io/blog/posts/code/170187840001/><span class=title>»</span><br><span>如何更优雅地实现策略模式</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://lesanouo.github.io/blog/>Lesan's Blog</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>