<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>一些简单好用的SQL语法 | Lesan's Blog</title><meta name=keywords content="SQL"><meta name=description content="本篇文章分享网上看到的一些非常有用的 SQL 语句，并不复杂，希望大家要用到的时候能想起来有这么一些东西。
下面以最经典的数据库之一 MySQL 的语法为例，其实很多语法和函数其他的数据库也是支持的。"><meta name=author content="Lesan"><link rel=canonical href=https://lesanouo.github.io/blog/posts/168805440001/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://lesanouo.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://lesanouo.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://lesanouo.github.io/blog/favicon.ico><link rel=apple-touch-icon href=https://lesanouo.github.io/blog/favicon.ico><link rel=mask-icon href=https://lesanouo.github.io/blog/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-cn href=https://lesanouo.github.io/blog/posts/168805440001/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:url" content="https://lesanouo.github.io/blog/posts/168805440001/"><meta property="og:site_name" content="Lesan's Blog"><meta property="og:title" content="一些简单好用的SQL语法"><meta property="og:description" content="本篇文章分享网上看到的一些非常有用的 SQL 语句，并不复杂，希望大家要用到的时候能想起来有这么一些东西。
下面以最经典的数据库之一 MySQL 的语法为例，其实很多语法和函数其他的数据库也是支持的。"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-06-30T00:00:00+00:00"><meta property="article:modified_time" content="2023-06-30T00:00:00+00:00"><meta property="article:tag" content="SQL"><meta name=twitter:card content="summary"><meta name=twitter:title content="一些简单好用的SQL语法"><meta name=twitter:description content="本篇文章分享网上看到的一些非常有用的 SQL 语句，并不复杂，希望大家要用到的时候能想起来有这么一些东西。
下面以最经典的数据库之一 MySQL 的语法为例，其实很多语法和函数其他的数据库也是支持的。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"📚 博客","item":"https://lesanouo.github.io/blog/posts/"},{"@type":"ListItem","position":2,"name":"一些简单好用的SQL语法","item":"https://lesanouo.github.io/blog/posts/168805440001/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"一些简单好用的SQL语法","name":"一些简单好用的SQL语法","description":"本篇文章分享网上看到的一些非常有用的 SQL 语句，并不复杂，希望大家要用到的时候能想起来有这么一些东西。\n下面以最经典的数据库之一 MySQL 的语法为例，其实很多语法和函数其他的数据库也是支持的。\n","keywords":["SQL"],"articleBody":"本篇文章分享网上看到的一些非常有用的 SQL 语句，并不复杂，希望大家要用到的时候能想起来有这么一些东西。\n下面以最经典的数据库之一 MySQL 的语法为例，其实很多语法和函数其他的数据库也是支持的。\ngroup_concat 在我们平常的工作中，使用group by进行分组的场景，是非常多的。\n比如想统计出用户表中，名称不同的用户的具体名称有哪些？\n具体sql如下：\nselect name from `user` group by name; 但如果想把name相同的code拼接在一起，放到另外一列中该怎么办呢？\n答：使用group_concat函数。\n例如：\nselect name,group_concat(code) from `user` group by name; 使用group_concat函数，可以轻松的把分组后，name相同的数据拼接到一起，组成一个字符串，用逗号分隔。\nchar_length 有时候我们需要获取字符的长度，然后根据字符的长度进行排序。\nMYSQL给我们提供了一些有用的函数，比如：char_length。\n通过该函数就能获取字符长度。\n获取字符长度并且排序的sql如下：\nselect * from brand where name like '%苏三%' order by char_length(name) asc limit 5; name字段使用关键字模糊查询之后，再使用char_length函数获取name字段的字符长度，然后按长度升序。\nlocate 有时候我们在查找某个关键字，比如：苏三，需要明确知道它在某个字符串中的位置时，该怎么办呢？\n答：使用locate函数。\n使用locate函数改造之后sql如下：\nselect * from brand where name like '%苏三%' order by char_length(name) asc, locate('苏三',name) asc limit 5,5; 先按长度排序，小的排在前面。如果长度相同，则按关键字从左到右进行排序，越靠左的越排在前面。\n除此之外，我们还可以使用：instr和position函数，它们的功能跟locate函数类似，在这里就不一一介绍了。\nreplace 我们经常会有替换字符串中部分内容的需求，比如：将字符串中的字符A替换成B。\n这种情况就能使用replace函数。\n例如：\nupdate brand set name=REPLACE(name,'A','B') where id=1; 这样就能轻松实现字符替换功能。\n也能用该函数去掉前后空格：\nupdate brand set name=REPLACE(name,' ','') where name like ' %'; update brand set name=REPLACE(name,' ','') where name like '% '; 使用该函数还能替换json格式的数据内容，真的非常有用。\nnow 时间是个好东西，用它可以快速缩小数据范围，我们经常有获取当前时间的需求。\n在MYSQL中获取当前时间，可以使用now()函数，例如：\nselect now() from brand limit 1; 它会包含年月日时分秒。\n如果你还想返回毫秒，可以使用now(3)，例如：\nselect now(3) from brand limit 1; insert into … select 在工作中很多时候需要插入数据。\n传统的插入数据的sql是这样的：\nINSERT INTO `brand`(`id`, `code`, `name`, `edit_date`) VALUES (5, '108', '苏三', '2022-09-02 19:42:21'); 它主要是用于插入少量并且已经确定的数据。但如果有大批量的数据需要插入，特别是是需要插入的数据来源于，另外一张表或者多张表的结果集中。\n这种情况下，使用传统的插入数据的方式，就有点束手无策了。\n这时候就能使用MYSQL提供的：insert into … select语法。\n例如：\nINSERT INTO `brand`(`id`, `code`, `name`, `edit_date`) select null,code,name,now(3) from `order` where code in ('004','005'); 这样就能将order表中的部分数据，非常轻松插入到brand表中。\ninsert into … ignore 不知道你有没有遇到过这样的场景：在插入1000个品牌之前，需要先根据name，判断一下是否存在。如果存在，则不插入数据。如果不存在，才需要插入数据。\n如果直接这样插入数据：\nINSERT INTO `brand`(`id`, `code`, `name`, `edit_date`) VALUES (123, '108', '苏三', now(3)); 肯定不行，因为brand表的name字段创建了唯一索引，同时该表中已经有一条name等于苏三的数据了。\n这就需要在插入之前加一下判断。\n当然很多人通过在sql语句后面拼接not exists语句，也能达到防止出现重复数据的目的，比如：\nINSERT INTO `brand`(`id`, `code`, `name`, `edit_date`) select null,'108', '苏三',now(3) from dual where not exists (select * from `brand` where name='苏三'); 这条sql确实能够满足要求，但是总觉得有些麻烦。那么，有没有更简单的做法呢？\n答：可以使用insert into ... ignore语法。\n例如：\nINSERT ignore INTO `brand`(`id`, `code`, `name`, `edit_date`) VALUES (123, '108', '苏三', now(3)); 这样改造之后，如果brand表中没有name为苏三的数据，则可以直接插入成功。\n但如果brand表中已经存在name为苏三的数据了，则该sql语句也能正常执行，并不会报错。因为它会忽略异常，返回的执行结果影响行数为0，它不会重复插入数据。\nselect … for update MYSQL数据库自带了悲观锁，它是一种排它锁，根据锁的粒度从大到小分为：表锁、间隙锁和行锁。\n在我们的实际业务场景中，有些情况并发量不太高，为了保证数据的正确性，使用悲观锁也可以。\n比如：用户扣减积分，用户的操作并不集中。但也要考虑系统自动赠送积分的并发情况，所以有必要加悲观锁限制一下，防止出现积分加错的情况发生。\n这时候就可以使用MYSQL中的select ... for update语法了。\n例如：\nbegin; select * from `user` where id=1 for update; //业务逻辑处理 update `user` set score=score-1 where id=1; commit; 这样在一个事务中使用for update锁住一行记录，其他事务就不能在该事务提交之前，去更新那一行的数据。\n需要注意的是for update前的id条件，必须是表的主键或者唯一索引，不然行锁可能会失效，有可能变成表锁。\non duplicate key update 通常情况下，我们在插入数据之前，一般会先查询一下，该数据是否存在。如果不存在，则插入数据。如果已存在，则不插入数据，而直接返回结果。\n在没啥并发量的场景中，这种做法是没有什么问题的。但如果插入数据的请求，有一定的并发量，这种做法就可能会产生重复的数据。\n当然防止重复数据的做法很多，比如：加唯一索引、加分布式锁等。\n但这些方案，都没法做到让第二次请求也更新数据，它们一般会判断已经存在就直接返回了。\n这种情况可以使用on duplicate key update语法。\n该语法会在插入数据之前判断，如果主键或唯一索引不存在，则插入数据。如果主键或唯一索引存在，则执行更新操作。\n具体需要更新的字段可以指定，例如：\nINSERT INTO `brand`(`id`, `code`, `name`, `edit_date`) VALUES (123, '108', '苏三', now(3)) on duplicate key update name='苏三',edit_date=now(3); 这样一条语句就能轻松搞定需求，既不会产生重复数据，也能更新最新的数据。\n但需要注意的是，在高并发的场景下使用on duplicate key update语法，可能会存在死锁的问题，所以要根据实际情况酌情使用。\nshow create table 有时候，我们想快速查看某张表的字段情况，通常会使用desc命令，比如：\ndesc `order`; 确实能够看到order表中的字段名称、字段类型、字段长度、是否允许为空，是否主键、默认值等信息。\n但看不到该表的索引信息，如果想看创建了哪些索引，该怎么办呢？\n答：使用show index命令。\n比如：\nshow index from `order`; 也能查出该表所有的索引，但查看字段和索引数据呈现方式，总觉得有点怪怪的，有没有一种更直观的方式？\n答：这就需要使用show create table命令了。\n例如：\nshow create table `order`; 我们能够看到非常完整的建表语句，表名、字段名、字段类型、字段长度、字符集、主键、索引、执行引擎等都能看到。\n非常直接明了。\ncreate table … select 有时候，我们需要快速备份表。\n通常情况下，可以分两步走：\n创建一张临时表 将数据插入临时表 创建临时表可以使用命令：\ncreate table order_2022121819 like `order`; 创建成功之后，就会生成一张名称叫：order_2022121819，表结构跟order一模一样的新表，只是该表的数据为空而已。\n接下来使用命令：\ninsert into order_2022121819 select * from `order`; 执行之后就会将order表的数据插入到order_2022121819表中，也就是实现数据备份的功能。\n但有没有命令，一个命令就能实现上面这两步的功能呢？\n答：用create table … select命令。\n例如：\ncreate table order_2022121820 select * from `order`; 执行完之后，就会将order_2022121820表创建好，并且将order表中的数据自动插入到新创建的order_2022121820中。\n一个命令就能轻松搞定表备份。\nexplain 很多时候，我们优化一条sql语句的性能，需要查看索引执行情况。\n答：可以使用explain命令，查看mysql的执行计划，它会显示索引的使用情况。\n例如：\nexplain select * from `order` where code='002'; 通过这几列可以判断索引使用情况，执行计划包含列的含义如所示：\nid（select唯一标识） select_type（select类型） table（表名称） partitions（匹配的分区） type（连接类型） possible_keys（可能的索引选择） key（实际用到的索引） key_len（实际索引长度） ref（与索引比较的列） rows（预计要检查的行数） filtered（按表条件过滤的行百分比） Extra（附加信息） 说实话，sql语句没有走索引，排除没有建索引之外，最大的可能性是索引失效了。\n下面说说索引失效的常见原因：\n不满足最左前缀原则 范围索引列没有放最后 使用了select * 索引列上有计算 索引列上使用了函数 字符类型没加引号 用is null 和 is neot null 没注意字段是否允许为空 like查询左边有% 使用or关键字时没有注意 如果不是上面的这些原因，则需要再进一步排查一下其他原因。\nshow processlist 有些时候我们线上sql或者数据库出现了问题。比如出现了数据库连接过多问题，或者发现有一条sql语句的执行时间特别长。\n这时候该怎么办呢？\n答：我们可以使用show processlist命令查看当前线程执行情况。\n从执行结果中，我们可以查看当前的连接状态，帮助识别出有问题的查询语句。\nid 线程id User 执行sql的账号 Host 执行sql的数据库的ip和端号 db 数据库名称 Command 执行命令，包括：Daemon、Query、Sleep等。 Time 执行sql所消耗的时间 State 执行状态 info 执行信息，里面可能包含sql信息。 如果发现了异常的sql语句，可以直接kill掉，确保数据库不会出现严重的问题。\nmysqldump 有时候我们需要导出 MYSQL 表中的数据。\n这种情况就可以使用mysqldump工具，该工具会将数据查出来，转换成insert语句，写入到某个文件中，相当于数据备份。\n我们获取到该文件，然后执行相应的insert语句，就能创建相关的表，并且写入数据了，这就相当于数据还原。\nmysqldump命令的语法为：mysqldump -h主机名 -P端口 -u用户名 -p密码 参数1,参数2…. \u003e 文件名称.sql\n备份远程数据库中的数据库：\nmysqldump -h 192.22.25.226 -u root -p123456 dbname \u003e backup.sql ","wordCount":"4020","inLanguage":"zh-cn","datePublished":"2023-06-30T00:00:00Z","dateModified":"2023-06-30T00:00:00Z","author":{"@type":"Person","name":"Lesan"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://lesanouo.github.io/blog/posts/168805440001/"},"publisher":{"@type":"Organization","name":"Lesan's Blog","logo":{"@type":"ImageObject","url":"https://lesanouo.github.io/blog/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://lesanouo.github.io/blog/ accesskey=h title="Lesan's Blog (Alt + H)">Lesan's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://lesanouo.github.io/blog/archives title="📚 归档"><span>📚 归档</span></a></li><li><a href=https://lesanouo.github.io/blog/categories/ title="🗃️ 分类"><span>🗃️ 分类</span></a></li><li><a href=https://lesanouo.github.io/blog/tags/ title="🏷️ 标签"><span>🏷️ 标签</span></a></li><li><a href=https://lesanouo.github.io/blog/search/ title="🔎 搜索"><span>🔎 搜索</span></a></li><li><a href=https://lesanouo.github.io/blog/about/ title="👨‍💻 关于我"><span>👨‍💻 关于我</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://lesanouo.github.io/blog/>Home</a>&nbsp;»&nbsp;<a href=https://lesanouo.github.io/blog/posts/>📚 博客</a></div><h1 class="post-title entry-hint-parent">一些简单好用的SQL语法</h1><div class=post-meta><span title='2023-06-30 00:00:00 +0000 UTC'>2023-06-30</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Lesan</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#group_concat aria-label=group_concat>group_concat</a></li><li><a href=#char_length aria-label=char_length>char_length</a></li><li><a href=#locate aria-label=locate>locate</a></li><li><a href=#replace aria-label=replace>replace</a></li><li><a href=#now aria-label=now>now</a></li><li><a href=#insert-into--select aria-label="insert into &mldr; select">insert into &mldr; select</a></li><li><a href=#insert-into--ignore aria-label="insert into &mldr; ignore">insert into &mldr; ignore</a></li><li><a href=#select--for-update aria-label="select &mldr; for update">select &mldr; for update</a></li><li><a href=#on-duplicate-key-update aria-label="on duplicate key update">on duplicate key update</a></li><li><a href=#show-create-table aria-label="show create table">show create table</a></li><li><a href=#create-table--select aria-label="create table &mldr; select">create table &mldr; select</a></li><li><a href=#explain aria-label=explain>explain</a></li><li><a href=#show-processlist aria-label="show processlist">show processlist</a></li><li><a href=#mysqldump aria-label=mysqldump>mysqldump</a></li></ul></div></details></div><div class=post-content><p>本篇文章分享网上看到的一些非常有用的 SQL 语句，并不复杂，希望大家要用到的时候能想起来有这么一些东西。</p><p>下面以最经典的数据库之一 MySQL 的语法为例，其实很多语法和函数其他的数据库也是支持的。</p><h2 id=group_concat>group_concat<a hidden class=anchor aria-hidden=true href=#group_concat>#</a></h2><p>在我们平常的工作中，使用group by进行分组的场景，是非常多的。</p><p>比如想统计出用户表中，名称不同的用户的具体名称有哪些？</p><p>具体sql如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>select</span><span class=w> </span><span class=n>name</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=o>`</span><span class=k>user</span><span class=o>`</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>group</span><span class=w> </span><span class=k>by</span><span class=w> </span><span class=n>name</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>但如果想把name相同的code拼接在一起，放到另外一列中该怎么办呢？</p><p>答：使用<code>group_concat</code>函数。</p><p>例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>select</span><span class=w> </span><span class=n>name</span><span class=p>,</span><span class=n>group_concat</span><span class=p>(</span><span class=n>code</span><span class=p>)</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=o>`</span><span class=k>user</span><span class=o>`</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>group</span><span class=w> </span><span class=k>by</span><span class=w> </span><span class=n>name</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>使用<code>group_concat</code>函数，可以轻松的把分组后，name相同的数据拼接到一起，组成一个字符串，用<code>逗号</code>分隔。</p><h2 id=char_length>char_length<a hidden class=anchor aria-hidden=true href=#char_length>#</a></h2><p>有时候我们需要获取字符的<code>长度</code>，然后根据字符的长度进行<code>排序</code>。</p><p>MYSQL给我们提供了一些有用的函数，比如：<code>char_length</code>。</p><p>通过该函数就能获取字符长度。</p><p>获取字符长度并且排序的sql如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>brand</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>name</span><span class=w> </span><span class=k>like</span><span class=w> </span><span class=s1>&#39;%苏三%&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>order</span><span class=w> </span><span class=k>by</span><span class=w> </span><span class=k>char_length</span><span class=p>(</span><span class=n>name</span><span class=p>)</span><span class=w> </span><span class=k>asc</span><span class=w> </span><span class=k>limit</span><span class=w> </span><span class=mi>5</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>name字段使用关键字<code>模糊查询</code>之后，再使用<code>char_length</code>函数获取name字段的字符长度，然后按长度<code>升序</code>。</p><h2 id=locate>locate<a hidden class=anchor aria-hidden=true href=#locate>#</a></h2><p>有时候我们在查找某个关键字，比如：苏三，需要明确知道它在某个字符串中的位置时，该怎么办呢？</p><p>答：使用<code>locate</code>函数。</p><p>使用locate函数改造之后sql如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>brand</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>name</span><span class=w> </span><span class=k>like</span><span class=w> </span><span class=s1>&#39;%苏三%&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>order</span><span class=w> </span><span class=k>by</span><span class=w> </span><span class=k>char_length</span><span class=p>(</span><span class=n>name</span><span class=p>)</span><span class=w> </span><span class=k>asc</span><span class=p>,</span><span class=w> </span><span class=n>locate</span><span class=p>(</span><span class=s1>&#39;苏三&#39;</span><span class=p>,</span><span class=n>name</span><span class=p>)</span><span class=w> </span><span class=k>asc</span><span class=w> </span><span class=k>limit</span><span class=w> </span><span class=mi>5</span><span class=p>,</span><span class=mi>5</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>先按长度排序，小的排在前面。如果长度相同，则按关键字从左到右进行排序，越靠左的越排在前面。</p><p>除此之外，我们还可以使用：<code>instr</code>和<code>position</code>函数，它们的功能跟<code>locate</code>函数类似，在这里就不一一介绍了。</p><h2 id=replace>replace<a hidden class=anchor aria-hidden=true href=#replace>#</a></h2><p>我们经常会有替换字符串中部分内容的需求，比如：将字符串中的字符A替换成B。</p><p>这种情况就能使用<code>replace</code>函数。</p><p>例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>update</span><span class=w> </span><span class=n>brand</span><span class=w> </span><span class=k>set</span><span class=w> </span><span class=n>name</span><span class=o>=</span><span class=k>REPLACE</span><span class=p>(</span><span class=n>name</span><span class=p>,</span><span class=s1>&#39;A&#39;</span><span class=p>,</span><span class=s1>&#39;B&#39;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>where</span><span class=w> </span><span class=n>id</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>这样就能轻松实现字符替换功能。</p><p>也能用该函数去掉<code>前后空格</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>update</span><span class=w> </span><span class=n>brand</span><span class=w> </span><span class=k>set</span><span class=w> </span><span class=n>name</span><span class=o>=</span><span class=k>REPLACE</span><span class=p>(</span><span class=n>name</span><span class=p>,</span><span class=s1>&#39; &#39;</span><span class=p>,</span><span class=s1>&#39;&#39;</span><span class=p>)</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>name</span><span class=w> </span><span class=k>like</span><span class=w> </span><span class=s1>&#39; %&#39;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>update</span><span class=w> </span><span class=n>brand</span><span class=w> </span><span class=k>set</span><span class=w> </span><span class=n>name</span><span class=o>=</span><span class=k>REPLACE</span><span class=p>(</span><span class=n>name</span><span class=p>,</span><span class=s1>&#39; &#39;</span><span class=p>,</span><span class=s1>&#39;&#39;</span><span class=p>)</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>name</span><span class=w> </span><span class=k>like</span><span class=w> </span><span class=s1>&#39;% &#39;</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>使用该函数还能替换<code>json格式</code>的数据内容，真的非常有用。</p><h2 id=now>now<a hidden class=anchor aria-hidden=true href=#now>#</a></h2><p>时间是个好东西，用它可以快速缩小数据范围，我们经常有获取当前时间的需求。</p><p>在MYSQL中获取<code>当前时间</code>，可以使用<code>now()</code>函数，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>select</span><span class=w> </span><span class=n>now</span><span class=p>()</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>brand</span><span class=w> </span><span class=k>limit</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>它会包含年月日时分秒。</p><p>如果你还想返回毫秒，可以使用now(3)，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>select</span><span class=w> </span><span class=n>now</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>brand</span><span class=w> </span><span class=k>limit</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><h2 id=insert-into--select>insert into &mldr; select<a hidden class=anchor aria-hidden=true href=#insert-into--select>#</a></h2><p>在工作中很多时候需要插入数据。</p><p>传统的插入数据的sql是这样的：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>INSERT</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=o>`</span><span class=n>brand</span><span class=o>`</span><span class=p>(</span><span class=o>`</span><span class=n>id</span><span class=o>`</span><span class=p>,</span><span class=w> </span><span class=o>`</span><span class=n>code</span><span class=o>`</span><span class=p>,</span><span class=w> </span><span class=o>`</span><span class=n>name</span><span class=o>`</span><span class=p>,</span><span class=w> </span><span class=o>`</span><span class=n>edit_date</span><span class=o>`</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>VALUES</span><span class=w> </span><span class=p>(</span><span class=mi>5</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;108&#39;</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;苏三&#39;</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;2022-09-02 19:42:21&#39;</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><p>它主要是用于插入少量并且已经确定的数据。但如果有大批量的数据需要插入，特别是是需要插入的数据来源于，另外一张表或者多张表的结果集中。</p><p>这种情况下，使用传统的插入数据的方式，就有点束手无策了。</p><p>这时候就能使用MYSQL提供的：insert into &mldr; select语法。</p><p>例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>INSERT</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=o>`</span><span class=n>brand</span><span class=o>`</span><span class=p>(</span><span class=o>`</span><span class=n>id</span><span class=o>`</span><span class=p>,</span><span class=w> </span><span class=o>`</span><span class=n>code</span><span class=o>`</span><span class=p>,</span><span class=w> </span><span class=o>`</span><span class=n>name</span><span class=o>`</span><span class=p>,</span><span class=w> </span><span class=o>`</span><span class=n>edit_date</span><span class=o>`</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>select</span><span class=w> </span><span class=k>null</span><span class=p>,</span><span class=n>code</span><span class=p>,</span><span class=n>name</span><span class=p>,</span><span class=n>now</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=o>`</span><span class=k>order</span><span class=o>`</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>code</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=p>(</span><span class=s1>&#39;004&#39;</span><span class=p>,</span><span class=s1>&#39;005&#39;</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><p>这样就能将order表中的部分数据，非常轻松插入到brand表中。</p><h2 id=insert-into--ignore>insert into &mldr; ignore<a hidden class=anchor aria-hidden=true href=#insert-into--ignore>#</a></h2><p>不知道你有没有遇到过这样的场景：在插入1000个品牌之前，需要先根据name，判断一下是否存在。如果存在，则不插入数据。如果不存在，才需要插入数据。</p><p>如果直接这样插入数据：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>INSERT</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=o>`</span><span class=n>brand</span><span class=o>`</span><span class=p>(</span><span class=o>`</span><span class=n>id</span><span class=o>`</span><span class=p>,</span><span class=w> </span><span class=o>`</span><span class=n>code</span><span class=o>`</span><span class=p>,</span><span class=w> </span><span class=o>`</span><span class=n>name</span><span class=o>`</span><span class=p>,</span><span class=w> </span><span class=o>`</span><span class=n>edit_date</span><span class=o>`</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>VALUES</span><span class=w> </span><span class=p>(</span><span class=mi>123</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;108&#39;</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;苏三&#39;</span><span class=p>,</span><span class=w> </span><span class=n>now</span><span class=p>(</span><span class=mi>3</span><span class=p>));</span><span class=w>
</span></span></span></code></pre></div><p>肯定不行，因为brand表的name字段创建了唯一索引，同时该表中已经有一条name等于苏三的数据了。</p><p>这就需要在插入之前加一下判断。</p><p>当然很多人通过在sql语句后面拼接not exists语句，也能达到防止出现重复数据的目的，比如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>INSERT</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=o>`</span><span class=n>brand</span><span class=o>`</span><span class=p>(</span><span class=o>`</span><span class=n>id</span><span class=o>`</span><span class=p>,</span><span class=w> </span><span class=o>`</span><span class=n>code</span><span class=o>`</span><span class=p>,</span><span class=w> </span><span class=o>`</span><span class=n>name</span><span class=o>`</span><span class=p>,</span><span class=w> </span><span class=o>`</span><span class=n>edit_date</span><span class=o>`</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>select</span><span class=w> </span><span class=k>null</span><span class=p>,</span><span class=s1>&#39;108&#39;</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;苏三&#39;</span><span class=p>,</span><span class=n>now</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>from</span><span class=w> </span><span class=n>dual</span><span class=w> </span><span class=k>where</span><span class=w>  </span><span class=k>not</span><span class=w> </span><span class=k>exists</span><span class=w> </span><span class=p>(</span><span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=o>`</span><span class=n>brand</span><span class=o>`</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>name</span><span class=o>=</span><span class=s1>&#39;苏三&#39;</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><p>这条sql确实能够满足要求，但是总觉得有些麻烦。那么，有没有更简单的做法呢？</p><p>答：可以使用<code>insert into ... ignore</code>语法。</p><p>例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>INSERT</span><span class=w> </span><span class=k>ignore</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=o>`</span><span class=n>brand</span><span class=o>`</span><span class=p>(</span><span class=o>`</span><span class=n>id</span><span class=o>`</span><span class=p>,</span><span class=w> </span><span class=o>`</span><span class=n>code</span><span class=o>`</span><span class=p>,</span><span class=w> </span><span class=o>`</span><span class=n>name</span><span class=o>`</span><span class=p>,</span><span class=w> </span><span class=o>`</span><span class=n>edit_date</span><span class=o>`</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>VALUES</span><span class=w> </span><span class=p>(</span><span class=mi>123</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;108&#39;</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;苏三&#39;</span><span class=p>,</span><span class=w> </span><span class=n>now</span><span class=p>(</span><span class=mi>3</span><span class=p>));</span><span class=w>
</span></span></span></code></pre></div><p>这样改造之后，如果brand表中没有name为苏三的数据，则可以直接插入成功。</p><p>但如果brand表中已经存在name为苏三的数据了，则该sql语句也能正常执行，并不会报错。因为它会忽略异常，返回的执行结果影响行数为0，它不会重复插入数据。</p><h2 id=select--for-update>select &mldr; for update<a hidden class=anchor aria-hidden=true href=#select--for-update>#</a></h2><p>MYSQL数据库自带了<code>悲观锁</code>，它是一种排它锁，根据锁的粒度从大到小分为：<code>表锁</code>、<code>间隙锁</code>和<code>行锁</code>。</p><p>在我们的实际业务场景中，有些情况并发量不太高，为了保证数据的正确性，使用悲观锁也可以。</p><p>比如：用户扣减积分，用户的操作并不集中。但也要考虑系统自动赠送积分的并发情况，所以有必要加悲观锁限制一下，防止出现积分加错的情况发生。</p><p>这时候就可以使用MYSQL中的<code>select ... for update</code>语法了。</p><p>例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>begin</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=o>`</span><span class=k>user</span><span class=o>`</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>id</span><span class=o>=</span><span class=mi>1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>for</span><span class=w> </span><span class=k>update</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>//</span><span class=err>业务逻辑处理</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>update</span><span class=w> </span><span class=o>`</span><span class=k>user</span><span class=o>`</span><span class=w> </span><span class=k>set</span><span class=w> </span><span class=n>score</span><span class=o>=</span><span class=n>score</span><span class=o>-</span><span class=mi>1</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>id</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>commit</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>这样在一个事务中使用<code>for update</code>锁住一行记录，其他事务就不能在该事务提交之前，去更新那一行的数据。</p><p>需要注意的是for update前的id条件，必须是表的<code>主键</code>或者<code>唯一索引</code>，不然行锁可能会失效，有可能变成<code>表锁</code>。</p><h2 id=on-duplicate-key-update>on duplicate key update<a hidden class=anchor aria-hidden=true href=#on-duplicate-key-update>#</a></h2><p>通常情况下，我们在插入数据之前，一般会先查询一下，该数据是否存在。如果不存在，则插入数据。如果已存在，则不插入数据，而直接返回结果。</p><p>在没啥并发量的场景中，这种做法是没有什么问题的。但如果插入数据的请求，有一定的并发量，这种做法就可能会产生重复的数据。</p><p>当然防止重复数据的做法很多，比如：<code>加唯一索引</code>、<code>加分布式锁</code>等。</p><p>但这些方案，都没法做到让第二次请求也更新数据，它们一般会判断已经存在就直接返回了。</p><p>这种情况可以使用<code>on duplicate key update</code>语法。</p><p>该语法会在插入数据之前判断，如果主键或唯一索引不存在，则插入数据。如果主键或唯一索引存在，则执行更新操作。</p><p>具体需要更新的字段可以指定，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>INSERT</span><span class=w>  </span><span class=k>INTO</span><span class=w> </span><span class=o>`</span><span class=n>brand</span><span class=o>`</span><span class=p>(</span><span class=o>`</span><span class=n>id</span><span class=o>`</span><span class=p>,</span><span class=w> </span><span class=o>`</span><span class=n>code</span><span class=o>`</span><span class=p>,</span><span class=w> </span><span class=o>`</span><span class=n>name</span><span class=o>`</span><span class=p>,</span><span class=w> </span><span class=o>`</span><span class=n>edit_date</span><span class=o>`</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>VALUES</span><span class=w> </span><span class=p>(</span><span class=mi>123</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;108&#39;</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;苏三&#39;</span><span class=p>,</span><span class=w> </span><span class=n>now</span><span class=p>(</span><span class=mi>3</span><span class=p>))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>on</span><span class=w> </span><span class=n>duplicate</span><span class=w> </span><span class=k>key</span><span class=w> </span><span class=k>update</span><span class=w> </span><span class=n>name</span><span class=o>=</span><span class=s1>&#39;苏三&#39;</span><span class=p>,</span><span class=n>edit_date</span><span class=o>=</span><span class=n>now</span><span class=p>(</span><span class=mi>3</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><p>这样一条语句就能轻松搞定需求，既不会产生重复数据，也能更新最新的数据。</p><p>但需要注意的是，在高并发的场景下使用<code>on duplicate key update</code>语法，可能会存在<code>死锁</code>的问题，所以要根据实际情况酌情使用。</p><h2 id=show-create-table>show create table<a hidden class=anchor aria-hidden=true href=#show-create-table>#</a></h2><p>有时候，我们想快速查看某张表的字段情况，通常会使用<code>desc</code>命令，比如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>desc</span><span class=w> </span><span class=o>`</span><span class=k>order</span><span class=o>`</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>确实能够看到order表中的字段名称、字段类型、字段长度、是否允许为空，是否主键、默认值等信息。</p><p>但看不到该表的索引信息，如果想看创建了哪些索引，该怎么办呢？</p><p>答：使用show index命令。</p><p>比如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>show</span><span class=w> </span><span class=k>index</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=o>`</span><span class=k>order</span><span class=o>`</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>也能查出该表所有的索引，但查看字段和索引数据呈现方式，总觉得有点怪怪的，有没有一种更直观的方式？</p><p>答：这就需要使用<code>show create table</code>命令了。</p><p>例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>show</span><span class=w> </span><span class=k>create</span><span class=w> </span><span class=k>table</span><span class=w> </span><span class=o>`</span><span class=k>order</span><span class=o>`</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>我们能够看到非常完整的建表语句，表名、字段名、字段类型、字段长度、字符集、主键、索引、执行引擎等都能看到。</p><p>非常直接明了。</p><h2 id=create-table--select>create table &mldr; select<a hidden class=anchor aria-hidden=true href=#create-table--select>#</a></h2><p>有时候，我们需要快速备份表。</p><p>通常情况下，可以分两步走：</p><ol><li>创建一张临时表</li><li>将数据插入临时表</li></ol><p>创建临时表可以使用命令：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>create</span><span class=w> </span><span class=k>table</span><span class=w> </span><span class=n>order_2022121819</span><span class=w> </span><span class=k>like</span><span class=w> </span><span class=o>`</span><span class=k>order</span><span class=o>`</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>创建成功之后，就会生成一张名称叫：order_2022121819，表结构跟order一模一样的<code>新表</code>，只是该表的<code>数据为空</code>而已。</p><p>接下来使用命令：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>insert</span><span class=w> </span><span class=k>into</span><span class=w> </span><span class=n>order_2022121819</span><span class=w> </span><span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=o>`</span><span class=k>order</span><span class=o>`</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>执行之后就会将order表的数据插入到order_2022121819表中，也就是实现数据备份的功能。</p><p>但有没有命令，一个命令就能实现上面这两步的功能呢？</p><p>答：用create table &mldr; select命令。</p><p>例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>create</span><span class=w> </span><span class=k>table</span><span class=w> </span><span class=n>order_2022121820</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=o>`</span><span class=k>order</span><span class=o>`</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>执行完之后，就会将order_2022121820表创建好，并且将order表中的数据自动插入到新创建的order_2022121820中。</p><p>一个命令就能轻松搞定<code>表备份</code>。</p><h2 id=explain>explain<a hidden class=anchor aria-hidden=true href=#explain>#</a></h2><p>很多时候，我们优化一条sql语句的性能，需要查看索引执行情况。</p><p>答：可以使用explain命令，查看mysql的执行计划，它会显示索引的使用情况。</p><p>例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>explain</span><span class=w> </span><span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=o>`</span><span class=k>order</span><span class=o>`</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>code</span><span class=o>=</span><span class=s1>&#39;002&#39;</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>通过这几列可以判断索引使用情况，执行计划包含列的含义如所示：</p><ol><li>id（select唯一标识）</li><li>select_type（select类型）</li><li>table（表名称）</li><li>partitions（匹配的分区）</li><li>type（连接类型）</li><li>possible_keys（可能的索引选择）</li><li>key（实际用到的索引）</li><li>key_len（实际索引长度）</li><li>ref（与索引比较的列）</li><li>rows（预计要检查的行数）</li><li>filtered（按表条件过滤的行百分比）</li><li>Extra（附加信息）</li></ol><p>说实话，sql语句没有走索引，排除没有建索引之外，最大的可能性是索引失效了。</p><p>下面说说索引失效的常见原因：</p><ol><li>不满足最左前缀原则</li><li>范围索引列没有放最后</li><li>使用了select *</li><li>索引列上有计算</li><li>索引列上使用了函数</li><li>字符类型没加引号</li><li>用is null 和 is neot null 没注意字段是否允许为空</li><li>like查询左边有%</li><li>使用or关键字时没有注意</li></ol><p>如果不是上面的这些原因，则需要再进一步排查一下其他原因。</p><h2 id=show-processlist>show processlist<a hidden class=anchor aria-hidden=true href=#show-processlist>#</a></h2><p>有些时候我们线上sql或者数据库出现了问题。比如出现了数据库连接过多问题，或者发现有一条sql语句的执行时间特别长。</p><p>这时候该怎么办呢？</p><p>答：我们可以使用<code>show processlist</code>命令查看<code>当前线程执行情况</code>。</p><p>从执行结果中，我们可以查看当前的连接状态，帮助识别出有问题的查询语句。</p><ul><li>id 线程id</li><li>User 执行sql的账号</li><li>Host 执行sql的数据库的ip和端号</li><li>db 数据库名称</li><li>Command 执行命令，包括：Daemon、Query、Sleep等。</li><li>Time 执行sql所消耗的时间</li><li>State 执行状态</li><li>info 执行信息，里面可能包含sql信息。</li></ul><p>如果发现了异常的sql语句，可以直接kill掉，确保数据库不会出现严重的问题。</p><h2 id=mysqldump>mysqldump<a hidden class=anchor aria-hidden=true href=#mysqldump>#</a></h2><p>有时候我们需要导出 MYSQL 表中的数据。</p><p>这种情况就可以使用<code>mysqldump</code>工具，该工具会将数据查出来，转换成insert语句，写入到某个文件中，相当于<code>数据备份</code>。</p><p>我们获取到该文件，然后执行相应的insert语句，就能创建相关的表，并且写入数据了，这就相当于<code>数据还原</code>。</p><p>mysqldump命令的语法为：mysqldump -h主机名 -P端口 -u用户名 -p密码 参数1,参数2&mldr;. > 文件名称.sql</p><p>备份远程数据库中的数据库：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=n>mysqldump</span><span class=w> </span><span class=o>-</span><span class=n>h</span><span class=w> </span><span class=mi>192</span><span class=p>.</span><span class=mi>22</span><span class=p>.</span><span class=mi>25</span><span class=p>.</span><span class=mi>226</span><span class=w> </span><span class=o>-</span><span class=n>u</span><span class=w> </span><span class=n>root</span><span class=w> </span><span class=o>-</span><span class=n>p123456</span><span class=w> </span><span class=n>dbname</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>backup</span><span class=p>.</span><span class=k>sql</span><span class=w>
</span></span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://lesanouo.github.io/blog/tags/sql/>SQL</a></li></ul><nav class=paginav><a class=prev href=https://lesanouo.github.io/blog/posts/168805440002/><span class=title>«</span><br><span>SpringBoot自建starter库</span>
</a><a class=next href=https://lesanouo.github.io/blog/posts/snippet/js/><span class=title>»</span><br><span>JavaScript 代码片段</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://lesanouo.github.io/blog/>Lesan's Blog</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>