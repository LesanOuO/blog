<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Linux 代码片段 | Lesan's Blog</title><meta name=keywords content="Linux"><meta name=description content="Linux关机,重启
# 关机
shutdown -h now

# 重启
shutdown -r now
查看系统,CPU信息
# 查看系统内核信息
uname -a

# 查看系统内核版本
cat /proc/version

# 查看当前用户环境变量
env

cat /proc/cpuinfo

# 查看有几个逻辑cpu, 包括cpu型号
cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c

# 查看有几颗cpu,每颗分别是几核
cat /proc/cpuinfo | grep physical | uniq -c

# 查看当前CPU运行在32bit还是64bit模式下, 如果是运行在32bit下也不代表CPU不支持64bit
getconf LONG_BIT

# 结果大于0, 说明支持64bit计算. lm指long mode, 支持lm则是64bit
cat /proc/cpuinfo | grep flags | grep ' lm ' | wc -l
建立软连接
ln -s /usr/local/jdk1.8/ jdk
rpm相关
# 查看是否通过rpm安装了该软件
rpm -qa | grep 软件名
sshkey
# 创建sshkey
ssh-keygen -t rsa -C your_email@example.com

#id_rsa.pub 的内容拷贝到要控制的服务器的 home/username/.ssh/authorized_keys 中,如果没有则新建(.ssh权限为700, authorized_keys权限为600)
命令重命名
# 在各个用户的.bash_profile中添加重命名配置
alias ll='ls -alF'
同步服务器时间
sudo ntpdate -u ntp.api.bz
后台运行
# 后台运行,并且有nohup.out输出
nohup xxx &

# 后台运行, 不输出任何日志
nohup xxx > /dev/null &

# 后台运行, 并将错误信息做标准输出到日志中
nohup xxx >out.log 2>&amp;1 &
强制活动用户退出
# 命令来完成强制活动用户退出.其中TTY表示终端名称
pkill -kill -t [TTY]
查看命令路径
which <命令>
查看进程所有打开最大fd数
ulimit -n
配置dns
vim /etc/resolv.conf
nslookup,查看域名路由表
nslookup google.com
last,最近登录信息列表
# 最近登录的5个账号
last -n 5
设置固定ip
ifconfig em1  192.168.5.177 netmask 255.255.255.0
查看进程内加载的环境变量
# 也可以去 cd /proc 目录下, 查看进程内存中加载的东西
ps eww -p  XXXXX(进程号)
查看进程树找到服务器进程
ps auwxf
查看进程启动路径
cd /proc/xxx(进程号)
ls -all
# cwd对应的是启动路径
添加用户,配置sudo权限
# 新增用户
useradd 用户名
passwd 用户名

#增加sudo权限
vim /etc/sudoers
# 修改文件里面的
# root    ALL=(ALL)       ALL
# 用户名 ALL=(ALL)       ALL
强制关闭进程名包含xxx的所有进程
ps aux|grep xxx | grep -v grep | awk '{print $2}' | xargs kill -9
vim操作
#normal模式下 g表示全局, x表示查找的内容, y表示替换后的内容
:%s/x/y/g

#normal模式下
0  # 光标移到行首(数字0)
$  # 光标移至行尾
shift + g # 跳到文件最后
gg # 跳到文件头

# 显示行号
:set nu

# 去除行号
:set nonu

# 检索
/xxx(检索内容)  # 从头检索, 按n查找下一个
?xxx(检索内容)  # 从尾部检索
打开只读文件,修改后需要保存时(不用切换用户即可保存的方式)
# 在normal模式下
:w !sudo tee %
查看磁盘, 文件目录基本信息
# 查看磁盘挂载情况
mount

# 查看磁盘分区信息
df

# 查看目录及子目录大小
du -H -h

# 查看当前目录下各个文件, 文件夹占了多少空间, 不会递归
du -sh *
wc命令
# 查看文件里有多少行
wc -l filename

# 看文件里有多少个word
wc -w filename

# 文件里最长的那一行是多少个字
wc -L filename

# 统计字节数
wc -c
压缩命令
tar czvf xxx.tar 压缩目录

zip -r xxx.zip 压缩目录
解压缩命令
tar zxvf xxx.tar

# 解压到指定文件夹
tar zxvf xxx.tar -C /xxx/yyy/

unzip xxx.zip
变更文件所属用户, 用户组
chown eagleye.eagleye xxx.log
cp, scp, mkdir
#复制
cp xxx.log

# 复制并强制覆盖同名文件
cp -f xxx.log

# 复制文件夹
cp -r xxx(源文件夹) yyy(目标文件夹)

# 远程复制
scp -P ssh端口 username@10.10.10.101:/home/username/xxx /home/xxx

# 级联创建目录
mkdir -p /xxx/yyy/zzz

# 批量创建文件夹, 会在test,main下都创建java, resources文件夹
mkdir -p src/{test,main}/{java,resources}
比较两个文件
diff -u 1.txt 2.txt
日志输出的字节数,可以用作性能测试
# 如果做性能测试, 可以每执行一次, 往日志里面输出 “.” , 这样日志中的字节数就是实际的性能测试运行的次数, 还可以看见实时速率.
tail -f xxx.log | pv -bt
查看, 去除特殊字符
# 查看特殊字符
cat -v xxx.sh

# 去除特殊字符
sed -i 's/^M//g’ env.sh  去除文件的特殊字符, 比如^M:  需要这样输入: ctrl+v+enter
处理因系统原因引起的文件中特殊字符的问题
# 可以转换为该系统下的文件格式
cat file.sh > file.sh_bak

# 先将file.sh中文件内容复制下来然后运行, 然后粘贴内容, 最后ctrl + d 保存退出
cat > file1.sh

# 在vim中通过如下设置文件编码和文件格式
:set fileencodings=utf-8 ，然后 w （存盘）一下即可转化为 utf8 格式，
:set fileformat=unix

# 在mac下使用dos2unix进行文件格式化
find . -name &#34;*.sh&#34; | xargs dos2unix
tee, 重定向的同时输出到屏幕
awk ‘{print $0}’ xxx.log | tee test.log
grep
# 反向匹配, 查找不包含xxx的内容
grep -v xxx

# 排除所有空行
grep -v '^/pre>'

# 返回结果 2,则说明第二行是空行
grep -n “^$” 111.txt

# 查询以abc开头的行
grep -n “^abc” 111.txt

# 同时列出该词语出现在文章的第几行
grep 'xxx' -n xxx.log

# 计算一下该字串出现的次数
grep 'xxx' -c xxx.log

# 比对的时候，不计较大小写的不同
grep 'xxx' -i xxx.log
awk
# 以':' 为分隔符,如果第五域有user则输出该行
awk -F ':' '{if ($5 ~ /user/) print $0}' /etc/passwd

# 统计单个文件中某个字符（串）(中文无效)出现的次数
awk -v RS='character' 'END {print --NR}' xxx.txt
find
# 在目录下找后缀是.mysql的文件
find /home/eagleye -name '*.mysql' -print

# 会从 /usr 目录开始往下找，找最近3天之内存取过的文件。
find /usr -atime 3 –print

# 会从 /usr 目录开始往下找，找最近5天之内修改过的文件。
find /usr -ctime 5 –print

# 会从 /doc 目录开始往下找，找jacky 的、文件名开头是 j的文件。
find /doc -user jacky -name 'j*' –print

# 会从 /doc 目录开始往下找，找寻文件名是 ja 开头或者 ma开头的文件。
find /doc \( -name 'ja*' -o- -name 'ma*' \) –print

#  会从 /doc 目录开始往下找，找到凡是文件名结尾为 bak的文件，把它删除掉。-exec 选项是执行的意思，rm 是删除命令，{ } 表示文件名，“\;”是规定的命令结尾。
find /doc -name '*bak' -exec rm {} \;
查看什么进程使用了该端口
lsof -i:port
获取本机ip地址
/sbin/ifconfig -a|grep inet|grep -v 127.0.0.1|grep -v inet6|awk '{print $2}'|tr -d &#34;addr:&#34;
iptables
# 查看iptables状态
service iptables status

# 要封停一个ip
iptables -I INPUT -s ***.***.***.*** -j DROP

# 要解封一个IP，使用下面这条命令：
iptables -D INPUT -s ***.***.***.*** -j DROP

备注: 参数-I是表示Insert（添加），-D表示Delete（删除）。后面跟的是规则，INPUT表示入站，***.***.***.***表示要封停的IP，DROP表示放弃连接。

#开启9090端口的访问
/sbin/iptables -I INPUT -p tcp --dport 9090 -j ACCEPT

# 防火墙开启、关闭、重启
/etc/init.d/iptables status
/etc/init.d/iptables start
/etc/init.d/iptables stop
/etc/init.d/iptables restart
nc命令, tcp调试利器
#给某一个endpoint发送TCP请求,就将data的内容发送到对端
nc 192.168.0.11 8000 < data.txt

#nc可以当做服务器，监听某个端口号,把某一次请求的内容存储到received_data里
nc -l 8000 > received_data

#上边只监听一次，如果多次可以加上-k参数
nc -lk 8000
tcpdump
# dump出本机12301端口的tcp包
tcpdump -i em1 tcp port 12301 -s 1500 -w abc.pcap
跟踪网络路由路径
# traceroute默认使用udp方式, 如果是-I则改成icmp方式
traceroute -I www.163.com

# 从ttl第3跳跟踪
traceroute -M 3 www.163.com

# 加上端口跟踪
traceroute -p 8080 192.168.10.11
ss
# 显示本地打开的所有端口
ss -l

# 显示每个进程具体打开的socket
ss -pl

# 显示所有tcp socket
ss -t -a

# 显示所有的UDP Socekt
ss -u -a

# 显示所有已建立的SMTP连接
ss -o state established '( dport = :smtp or sport = :smtp )'

# 显示所有已建立的HTTP连接
ss -o state established '( dport = :http or sport = :http )'

找出所有连接X服务器的进程
ss -x src /tmp/.X11-unix/*

列出当前socket统计信息
ss -s

解释：netstat是遍历/proc下面每个PID目录，ss直接读/proc/net下面的统计信息。所以ss执行的时候消耗资源以及消耗的时间都比netstat少很多
netstat
# 输出每个ip的连接数，以及总的各个状态的连接数
netstat -n | awk '/^tcp/ {n=split($(NF-1),array,&#34;:&#34;);if(n<=2)++S[array[(1)]];else++S[array[(4)]];++s[$NF];++N} END {for(a in S){printf(&#34;%-20s %s\n&#34;, a, S[a]);++I}printf(&#34;%-20s %s\n&#34;,&#34;TOTAL_IP&#34;,I);for(a in s) printf(&#34;%-20s %s\n&#34;,a, s[a]);printf(&#34;%-20s %s\n&#34;,&#34;TOTAL_LINK&#34;,N);}'

# 统计所有连接状态,
# CLOSED：无连接是活动的或正在进行
# LISTEN：服务器在等待进入呼叫
# SYN_RECV：一个连接请求已经到达，等待确认
# SYN_SENT：应用已经开始，打开一个连接
# ESTABLISHED：正常数据传输状态
# FIN_WAIT1：应用说它已经完成
# FIN_WAIT2：另一边已同意释放
# ITMED_WAIT：等待所有分组死掉
# CLOSING：两边同时尝试关闭
# TIME_WAIT：主动关闭连接一端还没有等到另一端反馈期间的状态
# LAST_ACK：等待所有分组死掉
netstat -n | awk '/^tcp/ {++state[$NF]} END {for(key in state) print key,&#34;\t&#34;,state[key]}'

# 查找较多time_wait连接
netstat -n|grep TIME_WAIT|awk '{print $5}'|sort|uniq -c|sort -rn|head -n20
top
dmesg,查看系统日志
iostat,磁盘IO情况监控
iostat -xz 1

# r/s, w/s, rkB/s, wkB/s：分别表示每秒读写次数和每秒读写数据量（千字节）。读写量过大，可能会引起性能问题。
# await：IO操作的平均等待时间，单位是毫秒。这是应用程序在和磁盘交互时，需要消耗的时间，包括IO等待和实际操作的耗时。如果这个数值过大，可能是硬件设备遇到了瓶颈或者出现故障。
# avgqu-sz：向设备发出的请求平均数量。如果这个数值大于1，可能是硬件设备已经饱和（部分前端硬件设备支持并行写入）。
# %util：设备利用率。这个数值表示设备的繁忙程度，经验值是如果超过60，可能会影响IO性能（可以参照IO操作平均等待时间）。如果到达100%，说明硬件设备已经饱和。
# 如果显示的是逻辑设备的数据，那么设备利用率不代表后端实际的硬件设备已经饱和。值得注意的是，即使IO性能不理想，也不一定意味这应用程序性能会不好，可以利用诸如预读取、写缓存等策略提升应用性能。
free,内存使用情况
free -m

eg:

     total       used       free     shared    buffers     cached
Mem:          1002        769        232          0         62        421
-/+ buffers/cache:          286        715
Swap:          1153          0       1153

第一部分Mem行:
total 内存总数: 1002M
used 已经使用的内存数: 769M
free 空闲的内存数: 232M
shared 当前已经废弃不用,总是0
buffers Buffer 缓存内存数: 62M
cached Page 缓存内存数:421M

关系：total(1002M) = used(769M) + free(232M)

第二部分(-/+ buffers/cache):
(-buffers/cache) used内存数：286M (指的第一部分Mem行中的used – buffers – cached)
(+buffers/cache) free内存数: 715M (指的第一部分Mem行中的free + buffers + cached)

可见-buffers/cache反映的是被程序实实在在吃掉的内存,而+buffers/cache反映的是可以挪用的内存总数.

第三部分是指交换分区
sar,查看网络吞吐状态
# sar命令在这里可以查看网络设备的吞吐率。在排查性能问题时，可以通过网络设备的吞吐量，判断网络设备是否已经饱和
sar -n DEV 1

# sar命令在这里用于查看TCP连接状态，其中包括：
# active/s：每秒本地发起的TCP连接数，既通过connect调用创建的TCP连接；
# passive/s：每秒远程发起的TCP连接数，即通过accept调用创建的TCP连接；
# retrans/s：每秒TCP重传数量；
# TCP连接数可以用来判断性能问题是否由于建立了过多的连接，进一步可以判断是主动发起的连接，还是被动接受的连接。TCP重传可能是因为网络环境恶劣，或者服务器压力过大导致丢包
sar -n TCP,ETCP 1
vmstat, 给定时间监控CPU使用率, 内存使用, 虚拟内存交互, IO读写
# 2表示每2秒采集一次状态信息, 1表示只采集一次(忽略既是一直采集)
vmstat 2 1
"><meta name=author content="Lesan"><link rel=canonical href=https://lesanouo.github.io/blog/posts/snippet/linux/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://lesanouo.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://lesanouo.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://lesanouo.github.io/blog/favicon.ico><link rel=apple-touch-icon href=https://lesanouo.github.io/blog/favicon.ico><link rel=mask-icon href=https://lesanouo.github.io/blog/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-cn href=https://lesanouo.github.io/blog/posts/snippet/linux/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:url" content="https://lesanouo.github.io/blog/posts/snippet/linux/"><meta property="og:site_name" content="Lesan's Blog"><meta property="og:title" content="Linux 代码片段"><meta property="og:description" content="Linux关机,重启 # 关机 shutdown -h now # 重启 shutdown -r now 查看系统,CPU信息 # 查看系统内核信息 uname -a # 查看系统内核版本 cat /proc/version # 查看当前用户环境变量 env cat /proc/cpuinfo # 查看有几个逻辑cpu, 包括cpu型号 cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c # 查看有几颗cpu,每颗分别是几核 cat /proc/cpuinfo | grep physical | uniq -c # 查看当前CPU运行在32bit还是64bit模式下, 如果是运行在32bit下也不代表CPU不支持64bit getconf LONG_BIT # 结果大于0, 说明支持64bit计算. lm指long mode, 支持lm则是64bit cat /proc/cpuinfo | grep flags | grep ' lm ' | wc -l 建立软连接 ln -s /usr/local/jdk1.8/ jdk rpm相关 # 查看是否通过rpm安装了该软件 rpm -qa | grep 软件名 sshkey # 创建sshkey ssh-keygen -t rsa -C your_email@example.com #id_rsa.pub 的内容拷贝到要控制的服务器的 home/username/.ssh/authorized_keys 中,如果没有则新建(.ssh权限为700, authorized_keys权限为600) 命令重命名 # 在各个用户的.bash_profile中添加重命名配置 alias ll='ls -alF' 同步服务器时间 sudo ntpdate -u ntp.api.bz 后台运行 # 后台运行,并且有nohup.out输出 nohup xxx & # 后台运行, 不输出任何日志 nohup xxx > /dev/null & # 后台运行, 并将错误信息做标准输出到日志中 nohup xxx >out.log 2>&amp;1 & 强制活动用户退出 # 命令来完成强制活动用户退出.其中TTY表示终端名称 pkill -kill -t [TTY] 查看命令路径 which <命令> 查看进程所有打开最大fd数 ulimit -n 配置dns vim /etc/resolv.conf nslookup,查看域名路由表 nslookup google.com last,最近登录信息列表 # 最近登录的5个账号 last -n 5 设置固定ip ifconfig em1 192.168.5.177 netmask 255.255.255.0 查看进程内加载的环境变量 # 也可以去 cd /proc 目录下, 查看进程内存中加载的东西 ps eww -p XXXXX(进程号) 查看进程树找到服务器进程 ps auwxf 查看进程启动路径 cd /proc/xxx(进程号) ls -all # cwd对应的是启动路径 添加用户,配置sudo权限 # 新增用户 useradd 用户名 passwd 用户名 #增加sudo权限 vim /etc/sudoers # 修改文件里面的 # root ALL=(ALL) ALL # 用户名 ALL=(ALL) ALL 强制关闭进程名包含xxx的所有进程 ps aux|grep xxx | grep -v grep | awk '{print $2}' | xargs kill -9 vim操作 #normal模式下 g表示全局, x表示查找的内容, y表示替换后的内容 :%s/x/y/g #normal模式下 0 # 光标移到行首(数字0) $ # 光标移至行尾 shift + g # 跳到文件最后 gg # 跳到文件头 # 显示行号 :set nu # 去除行号 :set nonu # 检索 /xxx(检索内容) # 从头检索, 按n查找下一个 ?xxx(检索内容) # 从尾部检索 打开只读文件,修改后需要保存时(不用切换用户即可保存的方式) # 在normal模式下 :w !sudo tee % 查看磁盘, 文件目录基本信息 # 查看磁盘挂载情况 mount # 查看磁盘分区信息 df # 查看目录及子目录大小 du -H -h # 查看当前目录下各个文件, 文件夹占了多少空间, 不会递归 du -sh * wc命令 # 查看文件里有多少行 wc -l filename # 看文件里有多少个word wc -w filename # 文件里最长的那一行是多少个字 wc -L filename # 统计字节数 wc -c 压缩命令 tar czvf xxx.tar 压缩目录 zip -r xxx.zip 压缩目录 解压缩命令 tar zxvf xxx.tar # 解压到指定文件夹 tar zxvf xxx.tar -C /xxx/yyy/ unzip xxx.zip 变更文件所属用户, 用户组 chown eagleye.eagleye xxx.log cp, scp, mkdir #复制 cp xxx.log # 复制并强制覆盖同名文件 cp -f xxx.log # 复制文件夹 cp -r xxx(源文件夹) yyy(目标文件夹) # 远程复制 scp -P ssh端口 username@10.10.10.101:/home/username/xxx /home/xxx # 级联创建目录 mkdir -p /xxx/yyy/zzz # 批量创建文件夹, 会在test,main下都创建java, resources文件夹 mkdir -p src/{test,main}/{java,resources} 比较两个文件 diff -u 1.txt 2.txt 日志输出的字节数,可以用作性能测试 # 如果做性能测试, 可以每执行一次, 往日志里面输出 “.” , 这样日志中的字节数就是实际的性能测试运行的次数, 还可以看见实时速率. tail -f xxx.log | pv -bt 查看, 去除特殊字符 # 查看特殊字符 cat -v xxx.sh # 去除特殊字符 sed -i 's/^M//g’ env.sh 去除文件的特殊字符, 比如^M: 需要这样输入: ctrl+v+enter 处理因系统原因引起的文件中特殊字符的问题 # 可以转换为该系统下的文件格式 cat file.sh > file.sh_bak # 先将file.sh中文件内容复制下来然后运行, 然后粘贴内容, 最后ctrl + d 保存退出 cat > file1.sh # 在vim中通过如下设置文件编码和文件格式 :set fileencodings=utf-8 ，然后 w （存盘）一下即可转化为 utf8 格式， :set fileformat=unix # 在mac下使用dos2unix进行文件格式化 find . -name &#34;*.sh&#34; | xargs dos2unix tee, 重定向的同时输出到屏幕 awk ‘{print $0}’ xxx.log | tee test.log grep # 反向匹配, 查找不包含xxx的内容 grep -v xxx # 排除所有空行 grep -v '^/pre>' # 返回结果 2,则说明第二行是空行 grep -n “^$” 111.txt # 查询以abc开头的行 grep -n “^abc” 111.txt # 同时列出该词语出现在文章的第几行 grep 'xxx' -n xxx.log # 计算一下该字串出现的次数 grep 'xxx' -c xxx.log # 比对的时候，不计较大小写的不同 grep 'xxx' -i xxx.log awk # 以':' 为分隔符,如果第五域有user则输出该行 awk -F ':' '{if ($5 ~ /user/) print $0}' /etc/passwd # 统计单个文件中某个字符（串）(中文无效)出现的次数 awk -v RS='character' 'END {print --NR}' xxx.txt find # 在目录下找后缀是.mysql的文件 find /home/eagleye -name '*.mysql' -print # 会从 /usr 目录开始往下找，找最近3天之内存取过的文件。 find /usr -atime 3 –print # 会从 /usr 目录开始往下找，找最近5天之内修改过的文件。 find /usr -ctime 5 –print # 会从 /doc 目录开始往下找，找jacky 的、文件名开头是 j的文件。 find /doc -user jacky -name 'j*' –print # 会从 /doc 目录开始往下找，找寻文件名是 ja 开头或者 ma开头的文件。 find /doc \( -name 'ja*' -o- -name 'ma*' \) –print # 会从 /doc 目录开始往下找，找到凡是文件名结尾为 bak的文件，把它删除掉。-exec 选项是执行的意思，rm 是删除命令，{ } 表示文件名，“\;”是规定的命令结尾。 find /doc -name '*bak' -exec rm {} \; 查看什么进程使用了该端口 lsof -i:port 获取本机ip地址 /sbin/ifconfig -a|grep inet|grep -v 127.0.0.1|grep -v inet6|awk '{print $2}'|tr -d &#34;addr:&#34; iptables # 查看iptables状态 service iptables status # 要封停一个ip iptables -I INPUT -s ***.***.***.*** -j DROP # 要解封一个IP，使用下面这条命令： iptables -D INPUT -s ***.***.***.*** -j DROP 备注: 参数-I是表示Insert（添加），-D表示Delete（删除）。后面跟的是规则，INPUT表示入站，***.***.***.***表示要封停的IP，DROP表示放弃连接。 #开启9090端口的访问 /sbin/iptables -I INPUT -p tcp --dport 9090 -j ACCEPT # 防火墙开启、关闭、重启 /etc/init.d/iptables status /etc/init.d/iptables start /etc/init.d/iptables stop /etc/init.d/iptables restart nc命令, tcp调试利器 #给某一个endpoint发送TCP请求,就将data的内容发送到对端 nc 192.168.0.11 8000 < data.txt #nc可以当做服务器，监听某个端口号,把某一次请求的内容存储到received_data里 nc -l 8000 > received_data #上边只监听一次，如果多次可以加上-k参数 nc -lk 8000 tcpdump # dump出本机12301端口的tcp包 tcpdump -i em1 tcp port 12301 -s 1500 -w abc.pcap 跟踪网络路由路径 # traceroute默认使用udp方式, 如果是-I则改成icmp方式 traceroute -I www.163.com # 从ttl第3跳跟踪 traceroute -M 3 www.163.com # 加上端口跟踪 traceroute -p 8080 192.168.10.11 ss # 显示本地打开的所有端口 ss -l # 显示每个进程具体打开的socket ss -pl # 显示所有tcp socket ss -t -a # 显示所有的UDP Socekt ss -u -a # 显示所有已建立的SMTP连接 ss -o state established '( dport = :smtp or sport = :smtp )' # 显示所有已建立的HTTP连接 ss -o state established '( dport = :http or sport = :http )' 找出所有连接X服务器的进程 ss -x src /tmp/.X11-unix/* 列出当前socket统计信息 ss -s 解释：netstat是遍历/proc下面每个PID目录，ss直接读/proc/net下面的统计信息。所以ss执行的时候消耗资源以及消耗的时间都比netstat少很多 netstat # 输出每个ip的连接数，以及总的各个状态的连接数 netstat -n | awk '/^tcp/ {n=split($(NF-1),array,&#34;:&#34;);if(n<=2)++S[array[(1)]];else++S[array[(4)]];++s[$NF];++N} END {for(a in S){printf(&#34;%-20s %s\n&#34;, a, S[a]);++I}printf(&#34;%-20s %s\n&#34;,&#34;TOTAL_IP&#34;,I);for(a in s) printf(&#34;%-20s %s\n&#34;,a, s[a]);printf(&#34;%-20s %s\n&#34;,&#34;TOTAL_LINK&#34;,N);}' # 统计所有连接状态, # CLOSED：无连接是活动的或正在进行 # LISTEN：服务器在等待进入呼叫 # SYN_RECV：一个连接请求已经到达，等待确认 # SYN_SENT：应用已经开始，打开一个连接 # ESTABLISHED：正常数据传输状态 # FIN_WAIT1：应用说它已经完成 # FIN_WAIT2：另一边已同意释放 # ITMED_WAIT：等待所有分组死掉 # CLOSING：两边同时尝试关闭 # TIME_WAIT：主动关闭连接一端还没有等到另一端反馈期间的状态 # LAST_ACK：等待所有分组死掉 netstat -n | awk '/^tcp/ {++state[$NF]} END {for(key in state) print key,&#34;\t&#34;,state[key]}' # 查找较多time_wait连接 netstat -n|grep TIME_WAIT|awk '{print $5}'|sort|uniq -c|sort -rn|head -n20 top dmesg,查看系统日志 iostat,磁盘IO情况监控 iostat -xz 1 # r/s, w/s, rkB/s, wkB/s：分别表示每秒读写次数和每秒读写数据量（千字节）。读写量过大，可能会引起性能问题。 # await：IO操作的平均等待时间，单位是毫秒。这是应用程序在和磁盘交互时，需要消耗的时间，包括IO等待和实际操作的耗时。如果这个数值过大，可能是硬件设备遇到了瓶颈或者出现故障。 # avgqu-sz：向设备发出的请求平均数量。如果这个数值大于1，可能是硬件设备已经饱和（部分前端硬件设备支持并行写入）。 # %util：设备利用率。这个数值表示设备的繁忙程度，经验值是如果超过60，可能会影响IO性能（可以参照IO操作平均等待时间）。如果到达100%，说明硬件设备已经饱和。 # 如果显示的是逻辑设备的数据，那么设备利用率不代表后端实际的硬件设备已经饱和。值得注意的是，即使IO性能不理想，也不一定意味这应用程序性能会不好，可以利用诸如预读取、写缓存等策略提升应用性能。 free,内存使用情况 free -m eg: total used free shared buffers cached Mem: 1002 769 232 0 62 421 -/+ buffers/cache: 286 715 Swap: 1153 0 1153 第一部分Mem行: total 内存总数: 1002M used 已经使用的内存数: 769M free 空闲的内存数: 232M shared 当前已经废弃不用,总是0 buffers Buffer 缓存内存数: 62M cached Page 缓存内存数:421M 关系：total(1002M) = used(769M) + free(232M) 第二部分(-/+ buffers/cache): (-buffers/cache) used内存数：286M (指的第一部分Mem行中的used – buffers – cached) (+buffers/cache) free内存数: 715M (指的第一部分Mem行中的free + buffers + cached) 可见-buffers/cache反映的是被程序实实在在吃掉的内存,而+buffers/cache反映的是可以挪用的内存总数. 第三部分是指交换分区 sar,查看网络吞吐状态 # sar命令在这里可以查看网络设备的吞吐率。在排查性能问题时，可以通过网络设备的吞吐量，判断网络设备是否已经饱和 sar -n DEV 1 # sar命令在这里用于查看TCP连接状态，其中包括： # active/s：每秒本地发起的TCP连接数，既通过connect调用创建的TCP连接； # passive/s：每秒远程发起的TCP连接数，即通过accept调用创建的TCP连接； # retrans/s：每秒TCP重传数量； # TCP连接数可以用来判断性能问题是否由于建立了过多的连接，进一步可以判断是主动发起的连接，还是被动接受的连接。TCP重传可能是因为网络环境恶劣，或者服务器压力过大导致丢包 sar -n TCP,ETCP 1 vmstat, 给定时间监控CPU使用率, 内存使用, 虚拟内存交互, IO读写 # 2表示每2秒采集一次状态信息, 1表示只采集一次(忽略既是一直采集) vmstat 2 1 "><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-02-16T00:00:00+00:00"><meta property="article:modified_time" content="2022-02-16T00:00:00+00:00"><meta property="article:tag" content="Linux"><meta name=twitter:card content="summary"><meta name=twitter:title content="Linux 代码片段"><meta name=twitter:description content="Linux关机,重启
# 关机
shutdown -h now

# 重启
shutdown -r now
查看系统,CPU信息
# 查看系统内核信息
uname -a

# 查看系统内核版本
cat /proc/version

# 查看当前用户环境变量
env

cat /proc/cpuinfo

# 查看有几个逻辑cpu, 包括cpu型号
cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c

# 查看有几颗cpu,每颗分别是几核
cat /proc/cpuinfo | grep physical | uniq -c

# 查看当前CPU运行在32bit还是64bit模式下, 如果是运行在32bit下也不代表CPU不支持64bit
getconf LONG_BIT

# 结果大于0, 说明支持64bit计算. lm指long mode, 支持lm则是64bit
cat /proc/cpuinfo | grep flags | grep ' lm ' | wc -l
建立软连接
ln -s /usr/local/jdk1.8/ jdk
rpm相关
# 查看是否通过rpm安装了该软件
rpm -qa | grep 软件名
sshkey
# 创建sshkey
ssh-keygen -t rsa -C your_email@example.com

#id_rsa.pub 的内容拷贝到要控制的服务器的 home/username/.ssh/authorized_keys 中,如果没有则新建(.ssh权限为700, authorized_keys权限为600)
命令重命名
# 在各个用户的.bash_profile中添加重命名配置
alias ll='ls -alF'
同步服务器时间
sudo ntpdate -u ntp.api.bz
后台运行
# 后台运行,并且有nohup.out输出
nohup xxx &

# 后台运行, 不输出任何日志
nohup xxx > /dev/null &

# 后台运行, 并将错误信息做标准输出到日志中
nohup xxx >out.log 2>&amp;1 &
强制活动用户退出
# 命令来完成强制活动用户退出.其中TTY表示终端名称
pkill -kill -t [TTY]
查看命令路径
which <命令>
查看进程所有打开最大fd数
ulimit -n
配置dns
vim /etc/resolv.conf
nslookup,查看域名路由表
nslookup google.com
last,最近登录信息列表
# 最近登录的5个账号
last -n 5
设置固定ip
ifconfig em1  192.168.5.177 netmask 255.255.255.0
查看进程内加载的环境变量
# 也可以去 cd /proc 目录下, 查看进程内存中加载的东西
ps eww -p  XXXXX(进程号)
查看进程树找到服务器进程
ps auwxf
查看进程启动路径
cd /proc/xxx(进程号)
ls -all
# cwd对应的是启动路径
添加用户,配置sudo权限
# 新增用户
useradd 用户名
passwd 用户名

#增加sudo权限
vim /etc/sudoers
# 修改文件里面的
# root    ALL=(ALL)       ALL
# 用户名 ALL=(ALL)       ALL
强制关闭进程名包含xxx的所有进程
ps aux|grep xxx | grep -v grep | awk '{print $2}' | xargs kill -9
vim操作
#normal模式下 g表示全局, x表示查找的内容, y表示替换后的内容
:%s/x/y/g

#normal模式下
0  # 光标移到行首(数字0)
$  # 光标移至行尾
shift + g # 跳到文件最后
gg # 跳到文件头

# 显示行号
:set nu

# 去除行号
:set nonu

# 检索
/xxx(检索内容)  # 从头检索, 按n查找下一个
?xxx(检索内容)  # 从尾部检索
打开只读文件,修改后需要保存时(不用切换用户即可保存的方式)
# 在normal模式下
:w !sudo tee %
查看磁盘, 文件目录基本信息
# 查看磁盘挂载情况
mount

# 查看磁盘分区信息
df

# 查看目录及子目录大小
du -H -h

# 查看当前目录下各个文件, 文件夹占了多少空间, 不会递归
du -sh *
wc命令
# 查看文件里有多少行
wc -l filename

# 看文件里有多少个word
wc -w filename

# 文件里最长的那一行是多少个字
wc -L filename

# 统计字节数
wc -c
压缩命令
tar czvf xxx.tar 压缩目录

zip -r xxx.zip 压缩目录
解压缩命令
tar zxvf xxx.tar

# 解压到指定文件夹
tar zxvf xxx.tar -C /xxx/yyy/

unzip xxx.zip
变更文件所属用户, 用户组
chown eagleye.eagleye xxx.log
cp, scp, mkdir
#复制
cp xxx.log

# 复制并强制覆盖同名文件
cp -f xxx.log

# 复制文件夹
cp -r xxx(源文件夹) yyy(目标文件夹)

# 远程复制
scp -P ssh端口 username@10.10.10.101:/home/username/xxx /home/xxx

# 级联创建目录
mkdir -p /xxx/yyy/zzz

# 批量创建文件夹, 会在test,main下都创建java, resources文件夹
mkdir -p src/{test,main}/{java,resources}
比较两个文件
diff -u 1.txt 2.txt
日志输出的字节数,可以用作性能测试
# 如果做性能测试, 可以每执行一次, 往日志里面输出 “.” , 这样日志中的字节数就是实际的性能测试运行的次数, 还可以看见实时速率.
tail -f xxx.log | pv -bt
查看, 去除特殊字符
# 查看特殊字符
cat -v xxx.sh

# 去除特殊字符
sed -i 's/^M//g’ env.sh  去除文件的特殊字符, 比如^M:  需要这样输入: ctrl+v+enter
处理因系统原因引起的文件中特殊字符的问题
# 可以转换为该系统下的文件格式
cat file.sh > file.sh_bak

# 先将file.sh中文件内容复制下来然后运行, 然后粘贴内容, 最后ctrl + d 保存退出
cat > file1.sh

# 在vim中通过如下设置文件编码和文件格式
:set fileencodings=utf-8 ，然后 w （存盘）一下即可转化为 utf8 格式，
:set fileformat=unix

# 在mac下使用dos2unix进行文件格式化
find . -name &#34;*.sh&#34; | xargs dos2unix
tee, 重定向的同时输出到屏幕
awk ‘{print $0}’ xxx.log | tee test.log
grep
# 反向匹配, 查找不包含xxx的内容
grep -v xxx

# 排除所有空行
grep -v '^/pre>'

# 返回结果 2,则说明第二行是空行
grep -n “^$” 111.txt

# 查询以abc开头的行
grep -n “^abc” 111.txt

# 同时列出该词语出现在文章的第几行
grep 'xxx' -n xxx.log

# 计算一下该字串出现的次数
grep 'xxx' -c xxx.log

# 比对的时候，不计较大小写的不同
grep 'xxx' -i xxx.log
awk
# 以':' 为分隔符,如果第五域有user则输出该行
awk -F ':' '{if ($5 ~ /user/) print $0}' /etc/passwd

# 统计单个文件中某个字符（串）(中文无效)出现的次数
awk -v RS='character' 'END {print --NR}' xxx.txt
find
# 在目录下找后缀是.mysql的文件
find /home/eagleye -name '*.mysql' -print

# 会从 /usr 目录开始往下找，找最近3天之内存取过的文件。
find /usr -atime 3 –print

# 会从 /usr 目录开始往下找，找最近5天之内修改过的文件。
find /usr -ctime 5 –print

# 会从 /doc 目录开始往下找，找jacky 的、文件名开头是 j的文件。
find /doc -user jacky -name 'j*' –print

# 会从 /doc 目录开始往下找，找寻文件名是 ja 开头或者 ma开头的文件。
find /doc \( -name 'ja*' -o- -name 'ma*' \) –print

#  会从 /doc 目录开始往下找，找到凡是文件名结尾为 bak的文件，把它删除掉。-exec 选项是执行的意思，rm 是删除命令，{ } 表示文件名，“\;”是规定的命令结尾。
find /doc -name '*bak' -exec rm {} \;
查看什么进程使用了该端口
lsof -i:port
获取本机ip地址
/sbin/ifconfig -a|grep inet|grep -v 127.0.0.1|grep -v inet6|awk '{print $2}'|tr -d &#34;addr:&#34;
iptables
# 查看iptables状态
service iptables status

# 要封停一个ip
iptables -I INPUT -s ***.***.***.*** -j DROP

# 要解封一个IP，使用下面这条命令：
iptables -D INPUT -s ***.***.***.*** -j DROP

备注: 参数-I是表示Insert（添加），-D表示Delete（删除）。后面跟的是规则，INPUT表示入站，***.***.***.***表示要封停的IP，DROP表示放弃连接。

#开启9090端口的访问
/sbin/iptables -I INPUT -p tcp --dport 9090 -j ACCEPT

# 防火墙开启、关闭、重启
/etc/init.d/iptables status
/etc/init.d/iptables start
/etc/init.d/iptables stop
/etc/init.d/iptables restart
nc命令, tcp调试利器
#给某一个endpoint发送TCP请求,就将data的内容发送到对端
nc 192.168.0.11 8000 < data.txt

#nc可以当做服务器，监听某个端口号,把某一次请求的内容存储到received_data里
nc -l 8000 > received_data

#上边只监听一次，如果多次可以加上-k参数
nc -lk 8000
tcpdump
# dump出本机12301端口的tcp包
tcpdump -i em1 tcp port 12301 -s 1500 -w abc.pcap
跟踪网络路由路径
# traceroute默认使用udp方式, 如果是-I则改成icmp方式
traceroute -I www.163.com

# 从ttl第3跳跟踪
traceroute -M 3 www.163.com

# 加上端口跟踪
traceroute -p 8080 192.168.10.11
ss
# 显示本地打开的所有端口
ss -l

# 显示每个进程具体打开的socket
ss -pl

# 显示所有tcp socket
ss -t -a

# 显示所有的UDP Socekt
ss -u -a

# 显示所有已建立的SMTP连接
ss -o state established '( dport = :smtp or sport = :smtp )'

# 显示所有已建立的HTTP连接
ss -o state established '( dport = :http or sport = :http )'

找出所有连接X服务器的进程
ss -x src /tmp/.X11-unix/*

列出当前socket统计信息
ss -s

解释：netstat是遍历/proc下面每个PID目录，ss直接读/proc/net下面的统计信息。所以ss执行的时候消耗资源以及消耗的时间都比netstat少很多
netstat
# 输出每个ip的连接数，以及总的各个状态的连接数
netstat -n | awk '/^tcp/ {n=split($(NF-1),array,&#34;:&#34;);if(n<=2)++S[array[(1)]];else++S[array[(4)]];++s[$NF];++N} END {for(a in S){printf(&#34;%-20s %s\n&#34;, a, S[a]);++I}printf(&#34;%-20s %s\n&#34;,&#34;TOTAL_IP&#34;,I);for(a in s) printf(&#34;%-20s %s\n&#34;,a, s[a]);printf(&#34;%-20s %s\n&#34;,&#34;TOTAL_LINK&#34;,N);}'

# 统计所有连接状态,
# CLOSED：无连接是活动的或正在进行
# LISTEN：服务器在等待进入呼叫
# SYN_RECV：一个连接请求已经到达，等待确认
# SYN_SENT：应用已经开始，打开一个连接
# ESTABLISHED：正常数据传输状态
# FIN_WAIT1：应用说它已经完成
# FIN_WAIT2：另一边已同意释放
# ITMED_WAIT：等待所有分组死掉
# CLOSING：两边同时尝试关闭
# TIME_WAIT：主动关闭连接一端还没有等到另一端反馈期间的状态
# LAST_ACK：等待所有分组死掉
netstat -n | awk '/^tcp/ {++state[$NF]} END {for(key in state) print key,&#34;\t&#34;,state[key]}'

# 查找较多time_wait连接
netstat -n|grep TIME_WAIT|awk '{print $5}'|sort|uniq -c|sort -rn|head -n20
top
dmesg,查看系统日志
iostat,磁盘IO情况监控
iostat -xz 1

# r/s, w/s, rkB/s, wkB/s：分别表示每秒读写次数和每秒读写数据量（千字节）。读写量过大，可能会引起性能问题。
# await：IO操作的平均等待时间，单位是毫秒。这是应用程序在和磁盘交互时，需要消耗的时间，包括IO等待和实际操作的耗时。如果这个数值过大，可能是硬件设备遇到了瓶颈或者出现故障。
# avgqu-sz：向设备发出的请求平均数量。如果这个数值大于1，可能是硬件设备已经饱和（部分前端硬件设备支持并行写入）。
# %util：设备利用率。这个数值表示设备的繁忙程度，经验值是如果超过60，可能会影响IO性能（可以参照IO操作平均等待时间）。如果到达100%，说明硬件设备已经饱和。
# 如果显示的是逻辑设备的数据，那么设备利用率不代表后端实际的硬件设备已经饱和。值得注意的是，即使IO性能不理想，也不一定意味这应用程序性能会不好，可以利用诸如预读取、写缓存等策略提升应用性能。
free,内存使用情况
free -m

eg:

     total       used       free     shared    buffers     cached
Mem:          1002        769        232          0         62        421
-/+ buffers/cache:          286        715
Swap:          1153          0       1153

第一部分Mem行:
total 内存总数: 1002M
used 已经使用的内存数: 769M
free 空闲的内存数: 232M
shared 当前已经废弃不用,总是0
buffers Buffer 缓存内存数: 62M
cached Page 缓存内存数:421M

关系：total(1002M) = used(769M) + free(232M)

第二部分(-/+ buffers/cache):
(-buffers/cache) used内存数：286M (指的第一部分Mem行中的used – buffers – cached)
(+buffers/cache) free内存数: 715M (指的第一部分Mem行中的free + buffers + cached)

可见-buffers/cache反映的是被程序实实在在吃掉的内存,而+buffers/cache反映的是可以挪用的内存总数.

第三部分是指交换分区
sar,查看网络吞吐状态
# sar命令在这里可以查看网络设备的吞吐率。在排查性能问题时，可以通过网络设备的吞吐量，判断网络设备是否已经饱和
sar -n DEV 1

# sar命令在这里用于查看TCP连接状态，其中包括：
# active/s：每秒本地发起的TCP连接数，既通过connect调用创建的TCP连接；
# passive/s：每秒远程发起的TCP连接数，即通过accept调用创建的TCP连接；
# retrans/s：每秒TCP重传数量；
# TCP连接数可以用来判断性能问题是否由于建立了过多的连接，进一步可以判断是主动发起的连接，还是被动接受的连接。TCP重传可能是因为网络环境恶劣，或者服务器压力过大导致丢包
sar -n TCP,ETCP 1
vmstat, 给定时间监控CPU使用率, 内存使用, 虚拟内存交互, IO读写
# 2表示每2秒采集一次状态信息, 1表示只采集一次(忽略既是一直采集)
vmstat 2 1
"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"📚 博客","item":"https://lesanouo.github.io/blog/posts/"},{"@type":"ListItem","position":2,"name":"Linux 代码片段","item":"https://lesanouo.github.io/blog/posts/snippet/linux/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Linux 代码片段","name":"Linux 代码片段","description":"Linux关机,重启 # 关机 shutdown -h now # 重启 shutdown -r now 查看系统,CPU信息 # 查看系统内核信息 uname -a # 查看系统内核版本 cat /proc/version # 查看当前用户环境变量 env cat /proc/cpuinfo # 查看有几个逻辑cpu, 包括cpu型号 cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c # 查看有几颗cpu,每颗分别是几核 cat /proc/cpuinfo | grep physical | uniq -c # 查看当前CPU运行在32bit还是64bit模式下, 如果是运行在32bit下也不代表CPU不支持64bit getconf LONG_BIT # 结果大于0, 说明支持64bit计算. lm指long mode, 支持lm则是64bit cat /proc/cpuinfo | grep flags | grep \u0026#39; lm \u0026#39; | wc -l 建立软连接 ln -s /usr/local/jdk1.8/ jdk rpm相关 # 查看是否通过rpm安装了该软件 rpm -qa | grep 软件名 sshkey # 创建sshkey ssh-keygen -t rsa -C your_email@example.com #id_rsa.pub 的内容拷贝到要控制的服务器的 home/username/.ssh/authorized_keys 中,如果没有则新建(.ssh权限为700, authorized_keys权限为600) 命令重命名 # 在各个用户的.bash_profile中添加重命名配置 alias ll=\u0026#39;ls -alF\u0026#39; 同步服务器时间 sudo ntpdate -u ntp.api.bz 后台运行 # 后台运行,并且有nohup.out输出 nohup xxx \u0026amp; # 后台运行, 不输出任何日志 nohup xxx \u0026gt; /dev/null \u0026amp; # 后台运行, 并将错误信息做标准输出到日志中 nohup xxx \u0026gt;out.log 2\u0026gt;\u0026amp;1 \u0026amp; 强制活动用户退出 # 命令来完成强制活动用户退出.其中TTY表示终端名称 pkill -kill -t [TTY] 查看命令路径 which \u0026lt;命令\u0026gt; 查看进程所有打开最大fd数 ulimit -n 配置dns vim /etc/resolv.conf nslookup,查看域名路由表 nslookup google.com last,最近登录信息列表 # 最近登录的5个账号 last -n 5 设置固定ip ifconfig em1 192.168.5.177 netmask 255.255.255.0 查看进程内加载的环境变量 # 也可以去 cd /proc 目录下, 查看进程内存中加载的东西 ps eww -p XXXXX(进程号) 查看进程树找到服务器进程 ps auwxf 查看进程启动路径 cd /proc/xxx(进程号) ls -all # cwd对应的是启动路径 添加用户,配置sudo权限 # 新增用户 useradd 用户名 passwd 用户名 #增加sudo权限 vim /etc/sudoers # 修改文件里面的 # root ALL=(ALL) ALL # 用户名 ALL=(ALL) ALL 强制关闭进程名包含xxx的所有进程 ps aux|grep xxx | grep -v grep | awk \u0026#39;{print $2}\u0026#39; | xargs kill -9 vim操作 #normal模式下 g表示全局, x表示查找的内容, y表示替换后的内容 :%s/x/y/g #normal模式下 0 # 光标移到行首(数字0) $ # 光标移至行尾 shift + g # 跳到文件最后 gg # 跳到文件头 # 显示行号 :set nu # 去除行号 :set nonu # 检索 /xxx(检索内容) # 从头检索, 按n查找下一个 ?xxx(检索内容) # 从尾部检索 打开只读文件,修改后需要保存时(不用切换用户即可保存的方式) # 在normal模式下 :w !sudo tee % 查看磁盘, 文件目录基本信息 # 查看磁盘挂载情况 mount # 查看磁盘分区信息 df # 查看目录及子目录大小 du -H -h # 查看当前目录下各个文件, 文件夹占了多少空间, 不会递归 du -sh * wc命令 # 查看文件里有多少行 wc -l filename # 看文件里有多少个word wc -w filename # 文件里最长的那一行是多少个字 wc -L filename # 统计字节数 wc -c 压缩命令 tar czvf xxx.tar 压缩目录 zip -r xxx.zip 压缩目录 解压缩命令 tar zxvf xxx.tar # 解压到指定文件夹 tar zxvf xxx.tar -C /xxx/yyy/ unzip xxx.zip 变更文件所属用户, 用户组 chown eagleye.eagleye xxx.log cp, scp, mkdir #复制 cp xxx.log # 复制并强制覆盖同名文件 cp -f xxx.log # 复制文件夹 cp -r xxx(源文件夹) yyy(目标文件夹) # 远程复制 scp -P ssh端口 username@10.10.10.101:/home/username/xxx /home/xxx # 级联创建目录 mkdir -p /xxx/yyy/zzz # 批量创建文件夹, 会在test,main下都创建java, resources文件夹 mkdir -p src/{test,main}/{java,resources} 比较两个文件 diff -u 1.txt 2.txt 日志输出的字节数,可以用作性能测试 # 如果做性能测试, 可以每执行一次, 往日志里面输出 “.” , 这样日志中的字节数就是实际的性能测试运行的次数, 还可以看见实时速率. tail -f xxx.log | pv -bt 查看, 去除特殊字符 # 查看特殊字符 cat -v xxx.sh # 去除特殊字符 sed -i \u0026#39;s/^M//g’ env.sh 去除文件的特殊字符, 比如^M: 需要这样输入: ctrl+v+enter 处理因系统原因引起的文件中特殊字符的问题 # 可以转换为该系统下的文件格式 cat file.sh \u0026gt; file.sh_bak # 先将file.sh中文件内容复制下来然后运行, 然后粘贴内容, 最后ctrl + d 保存退出 cat \u0026gt; file1.sh # 在vim中通过如下设置文件编码和文件格式 :set fileencodings=utf-8 ，然后 w （存盘）一下即可转化为 utf8 格式， :set fileformat=unix # 在mac下使用dos2unix进行文件格式化 find . -name \u0026#34;*.sh\u0026#34; | xargs dos2unix tee, 重定向的同时输出到屏幕 awk ‘{print $0}’ xxx.log | tee test.log grep # 反向匹配, 查找不包含xxx的内容 grep -v xxx # 排除所有空行 grep -v \u0026#39;^/pre\u0026gt;\u0026#39; # 返回结果 2,则说明第二行是空行 grep -n “^$” 111.txt # 查询以abc开头的行 grep -n “^abc” 111.txt # 同时列出该词语出现在文章的第几行 grep \u0026#39;xxx\u0026#39; -n xxx.log # 计算一下该字串出现的次数 grep \u0026#39;xxx\u0026#39; -c xxx.log # 比对的时候，不计较大小写的不同 grep \u0026#39;xxx\u0026#39; -i xxx.log awk # 以\u0026#39;:\u0026#39; 为分隔符,如果第五域有user则输出该行 awk -F \u0026#39;:\u0026#39; \u0026#39;{if ($5 ~ /user/) print $0}\u0026#39; /etc/passwd # 统计单个文件中某个字符（串）(中文无效)出现的次数 awk -v RS=\u0026#39;character\u0026#39; \u0026#39;END {print --NR}\u0026#39; xxx.txt find # 在目录下找后缀是.mysql的文件 find /home/eagleye -name \u0026#39;*.mysql\u0026#39; -print # 会从 /usr 目录开始往下找，找最近3天之内存取过的文件。 find /usr -atime 3 –print # 会从 /usr 目录开始往下找，找最近5天之内修改过的文件。 find /usr -ctime 5 –print # 会从 /doc 目录开始往下找，找jacky 的、文件名开头是 j的文件。 find /doc -user jacky -name \u0026#39;j*\u0026#39; –print # 会从 /doc 目录开始往下找，找寻文件名是 ja 开头或者 ma开头的文件。 find /doc \\( -name \u0026#39;ja*\u0026#39; -o- -name \u0026#39;ma*\u0026#39; \\) –print # 会从 /doc 目录开始往下找，找到凡是文件名结尾为 bak的文件，把它删除掉。-exec 选项是执行的意思，rm 是删除命令，{ } 表示文件名，“\\;”是规定的命令结尾。 find /doc -name \u0026#39;*bak\u0026#39; -exec rm {} \\; 查看什么进程使用了该端口 lsof -i:port 获取本机ip地址 /sbin/ifconfig -a|grep inet|grep -v 127.0.0.1|grep -v inet6|awk \u0026#39;{print $2}\u0026#39;|tr -d \u0026#34;addr:\u0026#34; iptables # 查看iptables状态 service iptables status # 要封停一个ip iptables -I INPUT -s ***.***.***.*** -j DROP # 要解封一个IP，使用下面这条命令： iptables -D INPUT -s ***.***.***.*** -j DROP 备注: 参数-I是表示Insert（添加），-D表示Delete（删除）。后面跟的是规则，INPUT表示入站，***.***.***.***表示要封停的IP，DROP表示放弃连接。 #开启9090端口的访问 /sbin/iptables -I INPUT -p tcp --dport 9090 -j ACCEPT # 防火墙开启、关闭、重启 /etc/init.d/iptables status /etc/init.d/iptables start /etc/init.d/iptables stop /etc/init.d/iptables restart nc命令, tcp调试利器 #给某一个endpoint发送TCP请求,就将data的内容发送到对端 nc 192.168.0.11 8000 \u0026lt; data.txt #nc可以当做服务器，监听某个端口号,把某一次请求的内容存储到received_data里 nc -l 8000 \u0026gt; received_data #上边只监听一次，如果多次可以加上-k参数 nc -lk 8000 tcpdump # dump出本机12301端口的tcp包 tcpdump -i em1 tcp port 12301 -s 1500 -w abc.pcap 跟踪网络路由路径 # traceroute默认使用udp方式, 如果是-I则改成icmp方式 traceroute -I www.163.com # 从ttl第3跳跟踪 traceroute -M 3 www.163.com # 加上端口跟踪 traceroute -p 8080 192.168.10.11 ss # 显示本地打开的所有端口 ss -l # 显示每个进程具体打开的socket ss -pl # 显示所有tcp socket ss -t -a # 显示所有的UDP Socekt ss -u -a # 显示所有已建立的SMTP连接 ss -o state established \u0026#39;( dport = :smtp or sport = :smtp )\u0026#39; # 显示所有已建立的HTTP连接 ss -o state established \u0026#39;( dport = :http or sport = :http )\u0026#39; 找出所有连接X服务器的进程 ss -x src /tmp/.X11-unix/* 列出当前socket统计信息 ss -s 解释：netstat是遍历/proc下面每个PID目录，ss直接读/proc/net下面的统计信息。所以ss执行的时候消耗资源以及消耗的时间都比netstat少很多 netstat # 输出每个ip的连接数，以及总的各个状态的连接数 netstat -n | awk \u0026#39;/^tcp/ {n=split($(NF-1),array,\u0026#34;:\u0026#34;);if(n\u0026lt;=2)++S[array[(1)]];else++S[array[(4)]];++s[$NF];++N} END {for(a in S){printf(\u0026#34;%-20s %s\\n\u0026#34;, a, S[a]);++I}printf(\u0026#34;%-20s %s\\n\u0026#34;,\u0026#34;TOTAL_IP\u0026#34;,I);for(a in s) printf(\u0026#34;%-20s %s\\n\u0026#34;,a, s[a]);printf(\u0026#34;%-20s %s\\n\u0026#34;,\u0026#34;TOTAL_LINK\u0026#34;,N);}\u0026#39; # 统计所有连接状态, # CLOSED：无连接是活动的或正在进行 # LISTEN：服务器在等待进入呼叫 # SYN_RECV：一个连接请求已经到达，等待确认 # SYN_SENT：应用已经开始，打开一个连接 # ESTABLISHED：正常数据传输状态 # FIN_WAIT1：应用说它已经完成 # FIN_WAIT2：另一边已同意释放 # ITMED_WAIT：等待所有分组死掉 # CLOSING：两边同时尝试关闭 # TIME_WAIT：主动关闭连接一端还没有等到另一端反馈期间的状态 # LAST_ACK：等待所有分组死掉 netstat -n | awk \u0026#39;/^tcp/ {++state[$NF]} END {for(key in state) print key,\u0026#34;\\t\u0026#34;,state[key]}\u0026#39; # 查找较多time_wait连接 netstat -n|grep TIME_WAIT|awk \u0026#39;{print $5}\u0026#39;|sort|uniq -c|sort -rn|head -n20 top dmesg,查看系统日志 iostat,磁盘IO情况监控 iostat -xz 1 # r/s, w/s, rkB/s, wkB/s：分别表示每秒读写次数和每秒读写数据量（千字节）。读写量过大，可能会引起性能问题。 # await：IO操作的平均等待时间，单位是毫秒。这是应用程序在和磁盘交互时，需要消耗的时间，包括IO等待和实际操作的耗时。如果这个数值过大，可能是硬件设备遇到了瓶颈或者出现故障。 # avgqu-sz：向设备发出的请求平均数量。如果这个数值大于1，可能是硬件设备已经饱和（部分前端硬件设备支持并行写入）。 # %util：设备利用率。这个数值表示设备的繁忙程度，经验值是如果超过60，可能会影响IO性能（可以参照IO操作平均等待时间）。如果到达100%，说明硬件设备已经饱和。 # 如果显示的是逻辑设备的数据，那么设备利用率不代表后端实际的硬件设备已经饱和。值得注意的是，即使IO性能不理想，也不一定意味这应用程序性能会不好，可以利用诸如预读取、写缓存等策略提升应用性能。 free,内存使用情况 free -m eg: total used free shared buffers cached Mem: 1002 769 232 0 62 421 -/+ buffers/cache: 286 715 Swap: 1153 0 1153 第一部分Mem行: total 内存总数: 1002M used 已经使用的内存数: 769M free 空闲的内存数: 232M shared 当前已经废弃不用,总是0 buffers Buffer 缓存内存数: 62M cached Page 缓存内存数:421M 关系：total(1002M) = used(769M) + free(232M) 第二部分(-/+ buffers/cache): (-buffers/cache) used内存数：286M (指的第一部分Mem行中的used – buffers – cached) (+buffers/cache) free内存数: 715M (指的第一部分Mem行中的free + buffers + cached) 可见-buffers/cache反映的是被程序实实在在吃掉的内存,而+buffers/cache反映的是可以挪用的内存总数. 第三部分是指交换分区 sar,查看网络吞吐状态 # sar命令在这里可以查看网络设备的吞吐率。在排查性能问题时，可以通过网络设备的吞吐量，判断网络设备是否已经饱和 sar -n DEV 1 # sar命令在这里用于查看TCP连接状态，其中包括： # active/s：每秒本地发起的TCP连接数，既通过connect调用创建的TCP连接； # passive/s：每秒远程发起的TCP连接数，即通过accept调用创建的TCP连接； # retrans/s：每秒TCP重传数量； # TCP连接数可以用来判断性能问题是否由于建立了过多的连接，进一步可以判断是主动发起的连接，还是被动接受的连接。TCP重传可能是因为网络环境恶劣，或者服务器压力过大导致丢包 sar -n TCP,ETCP 1 vmstat, 给定时间监控CPU使用率, 内存使用, 虚拟内存交互, IO读写 # 2表示每2秒采集一次状态信息, 1表示只采集一次(忽略既是一直采集) vmstat 2 1 ","keywords":["Linux"],"articleBody":"Linux关机,重启 # 关机 shutdown -h now # 重启 shutdown -r now 查看系统,CPU信息 # 查看系统内核信息 uname -a # 查看系统内核版本 cat /proc/version # 查看当前用户环境变量 env cat /proc/cpuinfo # 查看有几个逻辑cpu, 包括cpu型号 cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c # 查看有几颗cpu,每颗分别是几核 cat /proc/cpuinfo | grep physical | uniq -c # 查看当前CPU运行在32bit还是64bit模式下, 如果是运行在32bit下也不代表CPU不支持64bit getconf LONG_BIT # 结果大于0, 说明支持64bit计算. lm指long mode, 支持lm则是64bit cat /proc/cpuinfo | grep flags | grep ' lm ' | wc -l 建立软连接 ln -s /usr/local/jdk1.8/ jdk rpm相关 # 查看是否通过rpm安装了该软件 rpm -qa | grep 软件名 sshkey # 创建sshkey ssh-keygen -t rsa -C your_email@example.com #id_rsa.pub 的内容拷贝到要控制的服务器的 home/username/.ssh/authorized_keys 中,如果没有则新建(.ssh权限为700, authorized_keys权限为600) 命令重命名 # 在各个用户的.bash_profile中添加重命名配置 alias ll='ls -alF' 同步服务器时间 sudo ntpdate -u ntp.api.bz 后台运行 # 后台运行,并且有nohup.out输出 nohup xxx \u0026 # 后台运行, 不输出任何日志 nohup xxx \u003e /dev/null \u0026 # 后台运行, 并将错误信息做标准输出到日志中 nohup xxx \u003eout.log 2\u003e\u00261 \u0026 强制活动用户退出 # 命令来完成强制活动用户退出.其中TTY表示终端名称 pkill -kill -t [TTY] 查看命令路径 which \u003c命令\u003e 查看进程所有打开最大fd数 ulimit -n 配置dns vim /etc/resolv.conf nslookup,查看域名路由表 nslookup google.com last,最近登录信息列表 # 最近登录的5个账号 last -n 5 设置固定ip ifconfig em1 192.168.5.177 netmask 255.255.255.0 查看进程内加载的环境变量 # 也可以去 cd /proc 目录下, 查看进程内存中加载的东西 ps eww -p XXXXX(进程号) 查看进程树找到服务器进程 ps auwxf 查看进程启动路径 cd /proc/xxx(进程号) ls -all # cwd对应的是启动路径 添加用户,配置sudo权限 # 新增用户 useradd 用户名 passwd 用户名 #增加sudo权限 vim /etc/sudoers # 修改文件里面的 # root ALL=(ALL) ALL # 用户名 ALL=(ALL) ALL 强制关闭进程名包含xxx的所有进程 ps aux|grep xxx | grep -v grep | awk '{print $2}' | xargs kill -9 vim操作 #normal模式下 g表示全局, x表示查找的内容, y表示替换后的内容 :%s/x/y/g #normal模式下 0 # 光标移到行首(数字0) $ # 光标移至行尾 shift + g # 跳到文件最后 gg # 跳到文件头 # 显示行号 :set nu # 去除行号 :set nonu # 检索 /xxx(检索内容) # 从头检索, 按n查找下一个 ?xxx(检索内容) # 从尾部检索 打开只读文件,修改后需要保存时(不用切换用户即可保存的方式) # 在normal模式下 :w !sudo tee % 查看磁盘, 文件目录基本信息 # 查看磁盘挂载情况 mount # 查看磁盘分区信息 df # 查看目录及子目录大小 du -H -h # 查看当前目录下各个文件, 文件夹占了多少空间, 不会递归 du -sh * wc命令 # 查看文件里有多少行 wc -l filename # 看文件里有多少个word wc -w filename # 文件里最长的那一行是多少个字 wc -L filename # 统计字节数 wc -c 压缩命令 tar czvf xxx.tar 压缩目录 zip -r xxx.zip 压缩目录 解压缩命令 tar zxvf xxx.tar # 解压到指定文件夹 tar zxvf xxx.tar -C /xxx/yyy/ unzip xxx.zip 变更文件所属用户, 用户组 chown eagleye.eagleye xxx.log cp, scp, mkdir #复制 cp xxx.log # 复制并强制覆盖同名文件 cp -f xxx.log # 复制文件夹 cp -r xxx(源文件夹) yyy(目标文件夹) # 远程复制 scp -P ssh端口 username@10.10.10.101:/home/username/xxx /home/xxx # 级联创建目录 mkdir -p /xxx/yyy/zzz # 批量创建文件夹, 会在test,main下都创建java, resources文件夹 mkdir -p src/{test,main}/{java,resources} 比较两个文件 diff -u 1.txt 2.txt 日志输出的字节数,可以用作性能测试 # 如果做性能测试, 可以每执行一次, 往日志里面输出 “.” , 这样日志中的字节数就是实际的性能测试运行的次数, 还可以看见实时速率. tail -f xxx.log | pv -bt 查看, 去除特殊字符 # 查看特殊字符 cat -v xxx.sh # 去除特殊字符 sed -i 's/^M//g’ env.sh 去除文件的特殊字符, 比如^M: 需要这样输入: ctrl+v+enter 处理因系统原因引起的文件中特殊字符的问题 # 可以转换为该系统下的文件格式 cat file.sh \u003e file.sh_bak # 先将file.sh中文件内容复制下来然后运行, 然后粘贴内容, 最后ctrl + d 保存退出 cat \u003e file1.sh # 在vim中通过如下设置文件编码和文件格式 :set fileencodings=utf-8 ，然后 w （存盘）一下即可转化为 utf8 格式， :set fileformat=unix # 在mac下使用dos2unix进行文件格式化 find . -name \"*.sh\" | xargs dos2unix tee, 重定向的同时输出到屏幕 awk ‘{print $0}’ xxx.log | tee test.log grep # 反向匹配, 查找不包含xxx的内容 grep -v xxx # 排除所有空行 grep -v '^/pre\u003e' # 返回结果 2,则说明第二行是空行 grep -n “^$” 111.txt # 查询以abc开头的行 grep -n “^abc” 111.txt # 同时列出该词语出现在文章的第几行 grep 'xxx' -n xxx.log # 计算一下该字串出现的次数 grep 'xxx' -c xxx.log # 比对的时候，不计较大小写的不同 grep 'xxx' -i xxx.log awk # 以':' 为分隔符,如果第五域有user则输出该行 awk -F ':' '{if ($5 ~ /user/) print $0}' /etc/passwd # 统计单个文件中某个字符（串）(中文无效)出现的次数 awk -v RS='character' 'END {print --NR}' xxx.txt find # 在目录下找后缀是.mysql的文件 find /home/eagleye -name '*.mysql' -print # 会从 /usr 目录开始往下找，找最近3天之内存取过的文件。 find /usr -atime 3 –print # 会从 /usr 目录开始往下找，找最近5天之内修改过的文件。 find /usr -ctime 5 –print # 会从 /doc 目录开始往下找，找jacky 的、文件名开头是 j的文件。 find /doc -user jacky -name 'j*' –print # 会从 /doc 目录开始往下找，找寻文件名是 ja 开头或者 ma开头的文件。 find /doc \\( -name 'ja*' -o- -name 'ma*' \\) –print # 会从 /doc 目录开始往下找，找到凡是文件名结尾为 bak的文件，把它删除掉。-exec 选项是执行的意思，rm 是删除命令，{ } 表示文件名，“\\;”是规定的命令结尾。 find /doc -name '*bak' -exec rm {} \\; 查看什么进程使用了该端口 lsof -i:port 获取本机ip地址 /sbin/ifconfig -a|grep inet|grep -v 127.0.0.1|grep -v inet6|awk '{print $2}'|tr -d \"addr:\" iptables # 查看iptables状态 service iptables status # 要封停一个ip iptables -I INPUT -s ***.***.***.*** -j DROP # 要解封一个IP，使用下面这条命令： iptables -D INPUT -s ***.***.***.*** -j DROP 备注: 参数-I是表示Insert（添加），-D表示Delete（删除）。后面跟的是规则，INPUT表示入站，***.***.***.***表示要封停的IP，DROP表示放弃连接。 #开启9090端口的访问 /sbin/iptables -I INPUT -p tcp --dport 9090 -j ACCEPT # 防火墙开启、关闭、重启 /etc/init.d/iptables status /etc/init.d/iptables start /etc/init.d/iptables stop /etc/init.d/iptables restart nc命令, tcp调试利器 #给某一个endpoint发送TCP请求,就将data的内容发送到对端 nc 192.168.0.11 8000 \u003c data.txt #nc可以当做服务器，监听某个端口号,把某一次请求的内容存储到received_data里 nc -l 8000 \u003e received_data #上边只监听一次，如果多次可以加上-k参数 nc -lk 8000 tcpdump # dump出本机12301端口的tcp包 tcpdump -i em1 tcp port 12301 -s 1500 -w abc.pcap 跟踪网络路由路径 # traceroute默认使用udp方式, 如果是-I则改成icmp方式 traceroute -I www.163.com # 从ttl第3跳跟踪 traceroute -M 3 www.163.com # 加上端口跟踪 traceroute -p 8080 192.168.10.11 ss # 显示本地打开的所有端口 ss -l # 显示每个进程具体打开的socket ss -pl # 显示所有tcp socket ss -t -a # 显示所有的UDP Socekt ss -u -a # 显示所有已建立的SMTP连接 ss -o state established '( dport = :smtp or sport = :smtp )' # 显示所有已建立的HTTP连接 ss -o state established '( dport = :http or sport = :http )' 找出所有连接X服务器的进程 ss -x src /tmp/.X11-unix/* 列出当前socket统计信息 ss -s 解释：netstat是遍历/proc下面每个PID目录，ss直接读/proc/net下面的统计信息。所以ss执行的时候消耗资源以及消耗的时间都比netstat少很多 netstat # 输出每个ip的连接数，以及总的各个状态的连接数 netstat -n | awk '/^tcp/ {n=split($(NF-1),array,\":\");if(n\u003c=2)++S[array[(1)]];else++S[array[(4)]];++s[$NF];++N} END {for(a in S){printf(\"%-20s %s\\n\", a, S[a]);++I}printf(\"%-20s %s\\n\",\"TOTAL_IP\",I);for(a in s) printf(\"%-20s %s\\n\",a, s[a]);printf(\"%-20s %s\\n\",\"TOTAL_LINK\",N);}' # 统计所有连接状态, # CLOSED：无连接是活动的或正在进行 # LISTEN：服务器在等待进入呼叫 # SYN_RECV：一个连接请求已经到达，等待确认 # SYN_SENT：应用已经开始，打开一个连接 # ESTABLISHED：正常数据传输状态 # FIN_WAIT1：应用说它已经完成 # FIN_WAIT2：另一边已同意释放 # ITMED_WAIT：等待所有分组死掉 # CLOSING：两边同时尝试关闭 # TIME_WAIT：主动关闭连接一端还没有等到另一端反馈期间的状态 # LAST_ACK：等待所有分组死掉 netstat -n | awk '/^tcp/ {++state[$NF]} END {for(key in state) print key,\"\\t\",state[key]}' # 查找较多time_wait连接 netstat -n|grep TIME_WAIT|awk '{print $5}'|sort|uniq -c|sort -rn|head -n20 top dmesg,查看系统日志 iostat,磁盘IO情况监控 iostat -xz 1 # r/s, w/s, rkB/s, wkB/s：分别表示每秒读写次数和每秒读写数据量（千字节）。读写量过大，可能会引起性能问题。 # await：IO操作的平均等待时间，单位是毫秒。这是应用程序在和磁盘交互时，需要消耗的时间，包括IO等待和实际操作的耗时。如果这个数值过大，可能是硬件设备遇到了瓶颈或者出现故障。 # avgqu-sz：向设备发出的请求平均数量。如果这个数值大于1，可能是硬件设备已经饱和（部分前端硬件设备支持并行写入）。 # %util：设备利用率。这个数值表示设备的繁忙程度，经验值是如果超过60，可能会影响IO性能（可以参照IO操作平均等待时间）。如果到达100%，说明硬件设备已经饱和。 # 如果显示的是逻辑设备的数据，那么设备利用率不代表后端实际的硬件设备已经饱和。值得注意的是，即使IO性能不理想，也不一定意味这应用程序性能会不好，可以利用诸如预读取、写缓存等策略提升应用性能。 free,内存使用情况 free -m eg: total used free shared buffers cached Mem: 1002 769 232 0 62 421 -/+ buffers/cache: 286 715 Swap: 1153 0 1153 第一部分Mem行: total 内存总数: 1002M used 已经使用的内存数: 769M free 空闲的内存数: 232M shared 当前已经废弃不用,总是0 buffers Buffer 缓存内存数: 62M cached Page 缓存内存数:421M 关系：total(1002M) = used(769M) + free(232M) 第二部分(-/+ buffers/cache): (-buffers/cache) used内存数：286M (指的第一部分Mem行中的used – buffers – cached) (+buffers/cache) free内存数: 715M (指的第一部分Mem行中的free + buffers + cached) 可见-buffers/cache反映的是被程序实实在在吃掉的内存,而+buffers/cache反映的是可以挪用的内存总数. 第三部分是指交换分区 sar,查看网络吞吐状态 # sar命令在这里可以查看网络设备的吞吐率。在排查性能问题时，可以通过网络设备的吞吐量，判断网络设备是否已经饱和 sar -n DEV 1 # sar命令在这里用于查看TCP连接状态，其中包括： # active/s：每秒本地发起的TCP连接数，既通过connect调用创建的TCP连接； # passive/s：每秒远程发起的TCP连接数，即通过accept调用创建的TCP连接； # retrans/s：每秒TCP重传数量； # TCP连接数可以用来判断性能问题是否由于建立了过多的连接，进一步可以判断是主动发起的连接，还是被动接受的连接。TCP重传可能是因为网络环境恶劣，或者服务器压力过大导致丢包 sar -n TCP,ETCP 1 vmstat, 给定时间监控CPU使用率, 内存使用, 虚拟内存交互, IO读写 # 2表示每2秒采集一次状态信息, 1表示只采集一次(忽略既是一直采集) vmstat 2 1 ","wordCount":"4157","inLanguage":"zh-cn","datePublished":"2022-02-16T00:00:00Z","dateModified":"2022-02-16T00:00:00Z","author":{"@type":"Person","name":"Lesan"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://lesanouo.github.io/blog/posts/snippet/linux/"},"publisher":{"@type":"Organization","name":"Lesan's Blog","logo":{"@type":"ImageObject","url":"https://lesanouo.github.io/blog/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://lesanouo.github.io/blog/ accesskey=h title="Lesan's Blog (Alt + H)">Lesan's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://lesanouo.github.io/blog/archives title="📚 归档"><span>📚 归档</span></a></li><li><a href=https://lesanouo.github.io/blog/categories/ title="🗃️ 分类"><span>🗃️ 分类</span></a></li><li><a href=https://lesanouo.github.io/blog/tags/ title="🏷️ 标签"><span>🏷️ 标签</span></a></li><li><a href=https://lesanouo.github.io/blog/search/ title="🔎 搜索"><span>🔎 搜索</span></a></li><li><a href=https://lesanouo.github.io/blog/about/ title="👨‍💻 关于我"><span>👨‍💻 关于我</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://lesanouo.github.io/blog/>Home</a>&nbsp;»&nbsp;<a href=https://lesanouo.github.io/blog/posts/>📚 博客</a></div><h1 class="post-title entry-hint-parent">Linux 代码片段</h1><div class=post-meta><span title='2022-02-16 00:00:00 +0000 UTC'>2022-02-16</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Lesan</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#linux%e5%85%b3%e6%9c%ba%e9%87%8d%e5%90%af aria-label=Linux关机,重启>Linux关机,重启</a></li><li><a href=#%e6%9f%a5%e7%9c%8b%e7%b3%bb%e7%bb%9fcpu%e4%bf%a1%e6%81%af aria-label=查看系统,CPU信息>查看系统,CPU信息</a></li><li><a href=#%e5%bb%ba%e7%ab%8b%e8%bd%af%e8%bf%9e%e6%8e%a5 aria-label=建立软连接>建立软连接</a></li><li><a href=#rpm%e7%9b%b8%e5%85%b3 aria-label=rpm相关>rpm相关</a></li><li><a href=#sshkey aria-label=sshkey>sshkey</a></li><li><a href=#%e5%91%bd%e4%bb%a4%e9%87%8d%e5%91%bd%e5%90%8d aria-label=命令重命名>命令重命名</a></li><li><a href=#%e5%90%8c%e6%ad%a5%e6%9c%8d%e5%8a%a1%e5%99%a8%e6%97%b6%e9%97%b4 aria-label=同步服务器时间>同步服务器时间</a></li><li><a href=#%e5%90%8e%e5%8f%b0%e8%bf%90%e8%a1%8c aria-label=后台运行>后台运行</a></li><li><a href=#%e5%bc%ba%e5%88%b6%e6%b4%bb%e5%8a%a8%e7%94%a8%e6%88%b7%e9%80%80%e5%87%ba aria-label=强制活动用户退出>强制活动用户退出</a></li><li><a href=#%e6%9f%a5%e7%9c%8b%e5%91%bd%e4%bb%a4%e8%b7%af%e5%be%84 aria-label=查看命令路径>查看命令路径</a></li><li><a href=#%e6%9f%a5%e7%9c%8b%e8%bf%9b%e7%a8%8b%e6%89%80%e6%9c%89%e6%89%93%e5%bc%80%e6%9c%80%e5%a4%a7fd%e6%95%b0 aria-label=查看进程所有打开最大fd数>查看进程所有打开最大fd数</a></li><li><a href=#%e9%85%8d%e7%bd%aedns aria-label=配置dns>配置dns</a></li><li><a href=#nslookup%e6%9f%a5%e7%9c%8b%e5%9f%9f%e5%90%8d%e8%b7%af%e7%94%b1%e8%a1%a8 aria-label=nslookup,查看域名路由表>nslookup,查看域名路由表</a></li><li><a href=#last%e6%9c%80%e8%bf%91%e7%99%bb%e5%bd%95%e4%bf%a1%e6%81%af%e5%88%97%e8%a1%a8 aria-label=last,最近登录信息列表>last,最近登录信息列表</a></li><li><a href=#%e8%ae%be%e7%bd%ae%e5%9b%ba%e5%ae%9aip aria-label=设置固定ip>设置固定ip</a></li><li><a href=#%e6%9f%a5%e7%9c%8b%e8%bf%9b%e7%a8%8b%e5%86%85%e5%8a%a0%e8%bd%bd%e7%9a%84%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f aria-label=查看进程内加载的环境变量>查看进程内加载的环境变量</a></li><li><a href=#%e6%9f%a5%e7%9c%8b%e8%bf%9b%e7%a8%8b%e6%a0%91%e6%89%be%e5%88%b0%e6%9c%8d%e5%8a%a1%e5%99%a8%e8%bf%9b%e7%a8%8b aria-label=查看进程树找到服务器进程>查看进程树找到服务器进程</a></li><li><a href=#%e6%9f%a5%e7%9c%8b%e8%bf%9b%e7%a8%8b%e5%90%af%e5%8a%a8%e8%b7%af%e5%be%84 aria-label=查看进程启动路径>查看进程启动路径</a></li><li><a href=#%e6%b7%bb%e5%8a%a0%e7%94%a8%e6%88%b7%e9%85%8d%e7%bd%aesudo%e6%9d%83%e9%99%90 aria-label=添加用户,配置sudo权限>添加用户,配置sudo权限</a></li><li><a href=#%e5%bc%ba%e5%88%b6%e5%85%b3%e9%97%ad%e8%bf%9b%e7%a8%8b%e5%90%8d%e5%8c%85%e5%90%abxxx%e7%9a%84%e6%89%80%e6%9c%89%e8%bf%9b%e7%a8%8b aria-label=强制关闭进程名包含xxx的所有进程>强制关闭进程名包含xxx的所有进程</a></li><li><a href=#vim%e6%93%8d%e4%bd%9c aria-label=vim操作>vim操作</a></li><li><a href=#%e6%89%93%e5%bc%80%e5%8f%aa%e8%af%bb%e6%96%87%e4%bb%b6%e4%bf%ae%e6%94%b9%e5%90%8e%e9%9c%80%e8%a6%81%e4%bf%9d%e5%ad%98%e6%97%b6%e4%b8%8d%e7%94%a8%e5%88%87%e6%8d%a2%e7%94%a8%e6%88%b7%e5%8d%b3%e5%8f%af%e4%bf%9d%e5%ad%98%e7%9a%84%e6%96%b9%e5%bc%8f aria-label=打开只读文件,修改后需要保存时(不用切换用户即可保存的方式)>打开只读文件,修改后需要保存时(不用切换用户即可保存的方式)</a></li><li><a href=#%e6%9f%a5%e7%9c%8b%e7%a3%81%e7%9b%98-%e6%96%87%e4%bb%b6%e7%9b%ae%e5%bd%95%e5%9f%ba%e6%9c%ac%e4%bf%a1%e6%81%af aria-label="查看磁盘, 文件目录基本信息">查看磁盘, 文件目录基本信息</a></li><li><a href=#wc%e5%91%bd%e4%bb%a4 aria-label=wc命令>wc命令</a></li><li><a href=#%e5%8e%8b%e7%bc%a9%e5%91%bd%e4%bb%a4 aria-label=压缩命令>压缩命令</a></li><li><a href=#%e8%a7%a3%e5%8e%8b%e7%bc%a9%e5%91%bd%e4%bb%a4 aria-label=解压缩命令>解压缩命令</a></li><li><a href=#%e5%8f%98%e6%9b%b4%e6%96%87%e4%bb%b6%e6%89%80%e5%b1%9e%e7%94%a8%e6%88%b7-%e7%94%a8%e6%88%b7%e7%bb%84 aria-label="变更文件所属用户, 用户组">变更文件所属用户, 用户组</a></li><li><a href=#cp-scp-mkdir aria-label="cp, scp, mkdir">cp, scp, mkdir</a></li><li><a href=#%e6%af%94%e8%be%83%e4%b8%a4%e4%b8%aa%e6%96%87%e4%bb%b6 aria-label=比较两个文件>比较两个文件</a></li><li><a href=#%e6%97%a5%e5%bf%97%e8%be%93%e5%87%ba%e7%9a%84%e5%ad%97%e8%8a%82%e6%95%b0%e5%8f%af%e4%bb%a5%e7%94%a8%e4%bd%9c%e6%80%a7%e8%83%bd%e6%b5%8b%e8%af%95 aria-label=日志输出的字节数,可以用作性能测试>日志输出的字节数,可以用作性能测试</a></li><li><a href=#%e6%9f%a5%e7%9c%8b-%e5%8e%bb%e9%99%a4%e7%89%b9%e6%ae%8a%e5%ad%97%e7%ac%a6 aria-label="查看, 去除特殊字符">查看, 去除特殊字符</a></li><li><a href=#%e5%a4%84%e7%90%86%e5%9b%a0%e7%b3%bb%e7%bb%9f%e5%8e%9f%e5%9b%a0%e5%bc%95%e8%b5%b7%e7%9a%84%e6%96%87%e4%bb%b6%e4%b8%ad%e7%89%b9%e6%ae%8a%e5%ad%97%e7%ac%a6%e7%9a%84%e9%97%ae%e9%a2%98 aria-label=处理因系统原因引起的文件中特殊字符的问题>处理因系统原因引起的文件中特殊字符的问题</a></li><li><a href=#tee-%e9%87%8d%e5%ae%9a%e5%90%91%e7%9a%84%e5%90%8c%e6%97%b6%e8%be%93%e5%87%ba%e5%88%b0%e5%b1%8f%e5%b9%95 aria-label="tee, 重定向的同时输出到屏幕">tee, 重定向的同时输出到屏幕</a></li><li><a href=#grep aria-label=grep>grep</a></li><li><a href=#awk aria-label=awk>awk</a></li><li><a href=#find aria-label=find>find</a></li><li><a href=#%e6%9f%a5%e7%9c%8b%e4%bb%80%e4%b9%88%e8%bf%9b%e7%a8%8b%e4%bd%bf%e7%94%a8%e4%ba%86%e8%af%a5%e7%ab%af%e5%8f%a3 aria-label=查看什么进程使用了该端口>查看什么进程使用了该端口</a></li><li><a href=#%e8%8e%b7%e5%8f%96%e6%9c%ac%e6%9c%baip%e5%9c%b0%e5%9d%80 aria-label=获取本机ip地址>获取本机ip地址</a></li><li><a href=#iptables aria-label=iptables>iptables</a></li><li><a href=#nc%e5%91%bd%e4%bb%a4-tcp%e8%b0%83%e8%af%95%e5%88%a9%e5%99%a8 aria-label="nc命令, tcp调试利器">nc命令, tcp调试利器</a></li><li><a href=#tcpdump aria-label=tcpdump>tcpdump</a></li><li><a href=#%e8%b7%9f%e8%b8%aa%e7%bd%91%e7%bb%9c%e8%b7%af%e7%94%b1%e8%b7%af%e5%be%84 aria-label=跟踪网络路由路径>跟踪网络路由路径</a></li><li><a href=#ss aria-label=ss>ss</a></li><li><a href=#netstat aria-label=netstat>netstat</a></li><li><a href=#top aria-label=top>top</a></li><li><a href=#dmesg%e6%9f%a5%e7%9c%8b%e7%b3%bb%e7%bb%9f%e6%97%a5%e5%bf%97 aria-label=dmesg,查看系统日志>dmesg,查看系统日志</a></li><li><a href=#iostat%e7%a3%81%e7%9b%98io%e6%83%85%e5%86%b5%e7%9b%91%e6%8e%a7 aria-label=iostat,磁盘IO情况监控>iostat,磁盘IO情况监控</a></li><li><a href=#free%e5%86%85%e5%ad%98%e4%bd%bf%e7%94%a8%e6%83%85%e5%86%b5 aria-label=free,内存使用情况>free,内存使用情况</a></li><li><a href=#sar%e6%9f%a5%e7%9c%8b%e7%bd%91%e7%bb%9c%e5%90%9e%e5%90%90%e7%8a%b6%e6%80%81 aria-label=sar,查看网络吞吐状态>sar,查看网络吞吐状态</a></li><li><a href=#vmstat-%e7%bb%99%e5%ae%9a%e6%97%b6%e9%97%b4%e7%9b%91%e6%8e%a7cpu%e4%bd%bf%e7%94%a8%e7%8e%87-%e5%86%85%e5%ad%98%e4%bd%bf%e7%94%a8-%e8%99%9a%e6%8b%9f%e5%86%85%e5%ad%98%e4%ba%a4%e4%ba%92-io%e8%af%bb%e5%86%99 aria-label="vmstat, 给定时间监控CPU使用率, 内存使用, 虚拟内存交互, IO读写">vmstat, 给定时间监控CPU使用率, 内存使用, 虚拟内存交互, IO读写</a></li></ul></div></details></div><div class=post-content><h2 id=linux关机重启>Linux关机,重启<a hidden class=anchor aria-hidden=true href=#linux关机重启>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 关机</span>
</span></span><span class=line><span class=cl>shutdown -h now
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 重启</span>
</span></span><span class=line><span class=cl>shutdown -r now
</span></span></code></pre></div><h2 id=查看系统cpu信息>查看系统,CPU信息<a hidden class=anchor aria-hidden=true href=#查看系统cpu信息>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 查看系统内核信息</span>
</span></span><span class=line><span class=cl>uname -a
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 查看系统内核版本</span>
</span></span><span class=line><span class=cl>cat /proc/version
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 查看当前用户环境变量</span>
</span></span><span class=line><span class=cl>env
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>cat /proc/cpuinfo
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 查看有几个逻辑cpu, 包括cpu型号</span>
</span></span><span class=line><span class=cl>cat /proc/cpuinfo <span class=p>|</span> grep name <span class=p>|</span> cut -f2 -d: <span class=p>|</span> uniq -c
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 查看有几颗cpu,每颗分别是几核</span>
</span></span><span class=line><span class=cl>cat /proc/cpuinfo <span class=p>|</span> grep physical <span class=p>|</span> uniq -c
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 查看当前CPU运行在32bit还是64bit模式下, 如果是运行在32bit下也不代表CPU不支持64bit</span>
</span></span><span class=line><span class=cl>getconf LONG_BIT
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 结果大于0, 说明支持64bit计算. lm指long mode, 支持lm则是64bit</span>
</span></span><span class=line><span class=cl>cat /proc/cpuinfo <span class=p>|</span> grep flags <span class=p>|</span> grep <span class=s1>&#39; lm &#39;</span> <span class=p>|</span> wc -l
</span></span></code></pre></div><h2 id=建立软连接>建立软连接<a hidden class=anchor aria-hidden=true href=#建立软连接>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>ln -s /usr/local/jdk1.8/ jdk
</span></span></code></pre></div><h2 id=rpm相关>rpm相关<a hidden class=anchor aria-hidden=true href=#rpm相关>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 查看是否通过rpm安装了该软件</span>
</span></span><span class=line><span class=cl>rpm -qa <span class=p>|</span> grep 软件名
</span></span></code></pre></div><h2 id=sshkey>sshkey<a hidden class=anchor aria-hidden=true href=#sshkey>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 创建sshkey</span>
</span></span><span class=line><span class=cl>ssh-keygen -t rsa -C your_email@example.com
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#id_rsa.pub 的内容拷贝到要控制的服务器的 home/username/.ssh/authorized_keys 中,如果没有则新建(.ssh权限为700, authorized_keys权限为600)</span>
</span></span></code></pre></div><h2 id=命令重命名>命令重命名<a hidden class=anchor aria-hidden=true href=#命令重命名>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 在各个用户的.bash_profile中添加重命名配置</span>
</span></span><span class=line><span class=cl><span class=nb>alias</span> <span class=nv>ll</span><span class=o>=</span><span class=s1>&#39;ls -alF&#39;</span>
</span></span></code></pre></div><h2 id=同步服务器时间>同步服务器时间<a hidden class=anchor aria-hidden=true href=#同步服务器时间>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo ntpdate -u ntp.api.bz
</span></span></code></pre></div><h2 id=后台运行>后台运行<a hidden class=anchor aria-hidden=true href=#后台运行>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 后台运行,并且有nohup.out输出</span>
</span></span><span class=line><span class=cl>nohup xxx <span class=p>&amp;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 后台运行, 不输出任何日志</span>
</span></span><span class=line><span class=cl>nohup xxx &gt; /dev/null <span class=p>&amp;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 后台运行, 并将错误信息做标准输出到日志中</span>
</span></span><span class=line><span class=cl>nohup xxx &gt;out.log 2&gt;<span class=p>&amp;</span><span class=m>1</span> <span class=p>&amp;</span>
</span></span></code></pre></div><h2 id=强制活动用户退出>强制活动用户退出<a hidden class=anchor aria-hidden=true href=#强制活动用户退出>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 命令来完成强制活动用户退出.其中TTY表示终端名称</span>
</span></span><span class=line><span class=cl>pkill -kill -t <span class=o>[</span>TTY<span class=o>]</span>
</span></span></code></pre></div><h2 id=查看命令路径>查看命令路径<a hidden class=anchor aria-hidden=true href=#查看命令路径>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>which &lt;命令&gt;
</span></span></code></pre></div><h2 id=查看进程所有打开最大fd数>查看进程所有打开最大fd数<a hidden class=anchor aria-hidden=true href=#查看进程所有打开最大fd数>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>ulimit</span> -n
</span></span></code></pre></div><h2 id=配置dns>配置dns<a hidden class=anchor aria-hidden=true href=#配置dns>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>vim /etc/resolv.conf
</span></span></code></pre></div><h2 id=nslookup查看域名路由表>nslookup,查看域名路由表<a hidden class=anchor aria-hidden=true href=#nslookup查看域名路由表>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>nslookup google.com
</span></span></code></pre></div><h2 id=last最近登录信息列表>last,最近登录信息列表<a hidden class=anchor aria-hidden=true href=#last最近登录信息列表>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 最近登录的5个账号</span>
</span></span><span class=line><span class=cl>last -n <span class=m>5</span>
</span></span></code></pre></div><h2 id=设置固定ip>设置固定ip<a hidden class=anchor aria-hidden=true href=#设置固定ip>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>ifconfig em1  192.168.5.177 netmask 255.255.255.0
</span></span></code></pre></div><h2 id=查看进程内加载的环境变量>查看进程内加载的环境变量<a hidden class=anchor aria-hidden=true href=#查看进程内加载的环境变量>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 也可以去 cd /proc 目录下, 查看进程内存中加载的东西</span>
</span></span><span class=line><span class=cl>ps eww -p  XXXXX<span class=o>(</span>进程号<span class=o>)</span>
</span></span></code></pre></div><h2 id=查看进程树找到服务器进程>查看进程树找到服务器进程<a hidden class=anchor aria-hidden=true href=#查看进程树找到服务器进程>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>ps auwxf
</span></span></code></pre></div><h2 id=查看进程启动路径>查看进程启动路径<a hidden class=anchor aria-hidden=true href=#查看进程启动路径>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>cd</span> /proc/xxx<span class=o>(</span>进程号<span class=o>)</span>
</span></span><span class=line><span class=cl>ls -all
</span></span><span class=line><span class=cl><span class=c1># cwd对应的是启动路径</span>
</span></span></code></pre></div><h2 id=添加用户配置sudo权限>添加用户,配置sudo权限<a hidden class=anchor aria-hidden=true href=#添加用户配置sudo权限>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 新增用户</span>
</span></span><span class=line><span class=cl>useradd 用户名
</span></span><span class=line><span class=cl>passwd 用户名
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#增加sudo权限</span>
</span></span><span class=line><span class=cl>vim /etc/sudoers
</span></span><span class=line><span class=cl><span class=c1># 修改文件里面的</span>
</span></span><span class=line><span class=cl><span class=c1># root    ALL=(ALL)       ALL</span>
</span></span><span class=line><span class=cl><span class=c1># 用户名 ALL=(ALL)       ALL</span>
</span></span></code></pre></div><h2 id=强制关闭进程名包含xxx的所有进程>强制关闭进程名包含xxx的所有进程<a hidden class=anchor aria-hidden=true href=#强制关闭进程名包含xxx的所有进程>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>ps aux<span class=p>|</span>grep xxx <span class=p>|</span> grep -v grep <span class=p>|</span> awk <span class=s1>&#39;{print $2}&#39;</span> <span class=p>|</span> xargs <span class=nb>kill</span> -9
</span></span></code></pre></div><h2 id=vim操作>vim操作<a hidden class=anchor aria-hidden=true href=#vim操作>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1>#normal模式下 g表示全局, x表示查找的内容, y表示替换后的内容</span>
</span></span><span class=line><span class=cl>:%s/x/y/g
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#normal模式下</span>
</span></span><span class=line><span class=cl><span class=m>0</span>  <span class=c1># 光标移到行首(数字0)</span>
</span></span><span class=line><span class=cl>$  <span class=c1># 光标移至行尾</span>
</span></span><span class=line><span class=cl><span class=nb>shift</span> + g <span class=c1># 跳到文件最后</span>
</span></span><span class=line><span class=cl>gg <span class=c1># 跳到文件头</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 显示行号</span>
</span></span><span class=line><span class=cl>:set nu
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 去除行号</span>
</span></span><span class=line><span class=cl>:set nonu
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 检索</span>
</span></span><span class=line><span class=cl>/xxx<span class=o>(</span>检索内容<span class=o>)</span>  <span class=c1># 从头检索, 按n查找下一个</span>
</span></span><span class=line><span class=cl>?xxx<span class=o>(</span>检索内容<span class=o>)</span>  <span class=c1># 从尾部检索</span>
</span></span></code></pre></div><h2 id=打开只读文件修改后需要保存时不用切换用户即可保存的方式>打开只读文件,修改后需要保存时(不用切换用户即可保存的方式)<a hidden class=anchor aria-hidden=true href=#打开只读文件修改后需要保存时不用切换用户即可保存的方式>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 在normal模式下</span>
</span></span><span class=line><span class=cl>:w !sudo tee %
</span></span></code></pre></div><h2 id=查看磁盘-文件目录基本信息>查看磁盘, 文件目录基本信息<a hidden class=anchor aria-hidden=true href=#查看磁盘-文件目录基本信息>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 查看磁盘挂载情况</span>
</span></span><span class=line><span class=cl>mount
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 查看磁盘分区信息</span>
</span></span><span class=line><span class=cl>df
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 查看目录及子目录大小</span>
</span></span><span class=line><span class=cl>du -H -h
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 查看当前目录下各个文件, 文件夹占了多少空间, 不会递归</span>
</span></span><span class=line><span class=cl>du -sh *
</span></span></code></pre></div><h2 id=wc命令>wc命令<a hidden class=anchor aria-hidden=true href=#wc命令>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 查看文件里有多少行</span>
</span></span><span class=line><span class=cl>wc -l filename
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 看文件里有多少个word</span>
</span></span><span class=line><span class=cl>wc -w filename
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 文件里最长的那一行是多少个字</span>
</span></span><span class=line><span class=cl>wc -L filename
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 统计字节数</span>
</span></span><span class=line><span class=cl>wc -c
</span></span></code></pre></div><h2 id=压缩命令>压缩命令<a hidden class=anchor aria-hidden=true href=#压缩命令>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>tar czvf xxx.tar 压缩目录
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>zip -r xxx.zip 压缩目录
</span></span></code></pre></div><h2 id=解压缩命令>解压缩命令<a hidden class=anchor aria-hidden=true href=#解压缩命令>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>tar zxvf xxx.tar
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 解压到指定文件夹</span>
</span></span><span class=line><span class=cl>tar zxvf xxx.tar -C /xxx/yyy/
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>unzip xxx.zip
</span></span></code></pre></div><h2 id=变更文件所属用户-用户组>变更文件所属用户, 用户组<a hidden class=anchor aria-hidden=true href=#变更文件所属用户-用户组>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>chown eagleye.eagleye xxx.log
</span></span></code></pre></div><h2 id=cp-scp-mkdir>cp, scp, mkdir<a hidden class=anchor aria-hidden=true href=#cp-scp-mkdir>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1>#复制</span>
</span></span><span class=line><span class=cl>cp xxx.log
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 复制并强制覆盖同名文件</span>
</span></span><span class=line><span class=cl>cp -f xxx.log
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 复制文件夹</span>
</span></span><span class=line><span class=cl>cp -r xxx<span class=o>(</span>源文件夹<span class=o>)</span> yyy<span class=o>(</span>目标文件夹<span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 远程复制</span>
</span></span><span class=line><span class=cl>scp -P ssh端口 username@10.10.10.101:/home/username/xxx /home/xxx
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 级联创建目录</span>
</span></span><span class=line><span class=cl>mkdir -p /xxx/yyy/zzz
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 批量创建文件夹, 会在test,main下都创建java, resources文件夹</span>
</span></span><span class=line><span class=cl>mkdir -p src/<span class=o>{</span>test,main<span class=o>}</span>/<span class=o>{</span>java,resources<span class=o>}</span>
</span></span></code></pre></div><h2 id=比较两个文件>比较两个文件<a hidden class=anchor aria-hidden=true href=#比较两个文件>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>diff -u 1.txt 2.txt
</span></span></code></pre></div><h2 id=日志输出的字节数可以用作性能测试>日志输出的字节数,可以用作性能测试<a hidden class=anchor aria-hidden=true href=#日志输出的字节数可以用作性能测试>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 如果做性能测试, 可以每执行一次, 往日志里面输出 “.” , 这样日志中的字节数就是实际的性能测试运行的次数, 还可以看见实时速率.</span>
</span></span><span class=line><span class=cl>tail -f xxx.log <span class=p>|</span> pv -bt
</span></span></code></pre></div><h2 id=查看-去除特殊字符>查看, 去除特殊字符<a hidden class=anchor aria-hidden=true href=#查看-去除特殊字符>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 查看特殊字符</span>
</span></span><span class=line><span class=cl>cat -v xxx.sh
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 去除特殊字符</span>
</span></span><span class=line><span class=cl>sed -i <span class=err>&#39;</span>s/^M//g’ env.sh  去除文件的特殊字符, 比如^M:  需要这样输入: ctrl+v+enter
</span></span></code></pre></div><h2 id=处理因系统原因引起的文件中特殊字符的问题>处理因系统原因引起的文件中特殊字符的问题<a hidden class=anchor aria-hidden=true href=#处理因系统原因引起的文件中特殊字符的问题>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 可以转换为该系统下的文件格式</span>
</span></span><span class=line><span class=cl>cat file.sh &gt; file.sh_bak
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 先将file.sh中文件内容复制下来然后运行, 然后粘贴内容, 最后ctrl + d 保存退出</span>
</span></span><span class=line><span class=cl>cat &gt; file1.sh
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 在vim中通过如下设置文件编码和文件格式</span>
</span></span><span class=line><span class=cl>:set <span class=nv>fileencodings</span><span class=o>=</span>utf-8 ，然后 w （存盘）一下即可转化为 utf8 格式，
</span></span><span class=line><span class=cl>:set <span class=nv>fileformat</span><span class=o>=</span>unix
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 在mac下使用dos2unix进行文件格式化</span>
</span></span><span class=line><span class=cl>find . -name <span class=s2>&#34;*.sh&#34;</span> <span class=p>|</span> xargs dos2unix
</span></span></code></pre></div><h2 id=tee-重定向的同时输出到屏幕>tee, 重定向的同时输出到屏幕<a hidden class=anchor aria-hidden=true href=#tee-重定向的同时输出到屏幕>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>awk ‘<span class=o>{</span>print <span class=nv>$0</span><span class=o>}</span>’ xxx.log <span class=p>|</span> tee test.log
</span></span></code></pre></div><h2 id=grep>grep<a hidden class=anchor aria-hidden=true href=#grep>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 反向匹配, 查找不包含xxx的内容</span>
</span></span><span class=line><span class=cl>grep -v xxx
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 排除所有空行</span>
</span></span><span class=line><span class=cl>grep -v <span class=s1>&#39;^/pre&gt;&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 返回结果 2,则说明第二行是空行</span>
</span></span><span class=line><span class=cl>grep -n “^$” 111.txt
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 查询以abc开头的行</span>
</span></span><span class=line><span class=cl>grep -n “^abc” 111.txt
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 同时列出该词语出现在文章的第几行</span>
</span></span><span class=line><span class=cl>grep <span class=s1>&#39;xxx&#39;</span> -n xxx.log
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 计算一下该字串出现的次数</span>
</span></span><span class=line><span class=cl>grep <span class=s1>&#39;xxx&#39;</span> -c xxx.log
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 比对的时候，不计较大小写的不同</span>
</span></span><span class=line><span class=cl>grep <span class=s1>&#39;xxx&#39;</span> -i xxx.log
</span></span></code></pre></div><h2 id=awk>awk<a hidden class=anchor aria-hidden=true href=#awk>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 以&#39;:&#39; 为分隔符,如果第五域有user则输出该行</span>
</span></span><span class=line><span class=cl>awk -F <span class=s1>&#39;:&#39;</span> <span class=s1>&#39;{if ($5 ~ /user/) print $0}&#39;</span> /etc/passwd
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 统计单个文件中某个字符（串）(中文无效)出现的次数</span>
</span></span><span class=line><span class=cl>awk -v <span class=nv>RS</span><span class=o>=</span><span class=s1>&#39;character&#39;</span> <span class=s1>&#39;END {print --NR}&#39;</span> xxx.txt
</span></span></code></pre></div><h2 id=find>find<a hidden class=anchor aria-hidden=true href=#find>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 在目录下找后缀是.mysql的文件</span>
</span></span><span class=line><span class=cl>find /home/eagleye -name <span class=s1>&#39;*.mysql&#39;</span> -print
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 会从 /usr 目录开始往下找，找最近3天之内存取过的文件。</span>
</span></span><span class=line><span class=cl>find /usr -atime <span class=m>3</span> –print
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 会从 /usr 目录开始往下找，找最近5天之内修改过的文件。</span>
</span></span><span class=line><span class=cl>find /usr -ctime <span class=m>5</span> –print
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 会从 /doc 目录开始往下找，找jacky 的、文件名开头是 j的文件。</span>
</span></span><span class=line><span class=cl>find /doc -user jacky -name <span class=s1>&#39;j*&#39;</span> –print
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 会从 /doc 目录开始往下找，找寻文件名是 ja 开头或者 ma开头的文件。</span>
</span></span><span class=line><span class=cl>find /doc <span class=se>\(</span> -name <span class=s1>&#39;ja*&#39;</span> -o- -name <span class=s1>&#39;ma*&#39;</span> <span class=se>\)</span> –print
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#  会从 /doc 目录开始往下找，找到凡是文件名结尾为 bak的文件，把它删除掉。-exec 选项是执行的意思，rm 是删除命令，{ } 表示文件名，“\;”是规定的命令结尾。</span>
</span></span><span class=line><span class=cl>find /doc -name <span class=s1>&#39;*bak&#39;</span> -exec rm <span class=o>{}</span> <span class=se>\;</span>
</span></span></code></pre></div><h2 id=查看什么进程使用了该端口>查看什么进程使用了该端口<a hidden class=anchor aria-hidden=true href=#查看什么进程使用了该端口>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>lsof -i:port
</span></span></code></pre></div><h2 id=获取本机ip地址>获取本机ip地址<a hidden class=anchor aria-hidden=true href=#获取本机ip地址>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>/sbin/ifconfig -a<span class=p>|</span>grep inet<span class=p>|</span>grep -v 127.0.0.1<span class=p>|</span>grep -v inet6<span class=p>|</span>awk <span class=s1>&#39;{print $2}&#39;</span><span class=p>|</span>tr -d <span class=s2>&#34;addr:&#34;</span>
</span></span></code></pre></div><h2 id=iptables>iptables<a hidden class=anchor aria-hidden=true href=#iptables>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 查看iptables状态</span>
</span></span><span class=line><span class=cl>service iptables status
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 要封停一个ip</span>
</span></span><span class=line><span class=cl>iptables -I INPUT -s ***.***.***.*** -j DROP
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 要解封一个IP，使用下面这条命令：</span>
</span></span><span class=line><span class=cl>iptables -D INPUT -s ***.***.***.*** -j DROP
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>备注: 参数-I是表示Insert（添加），-D表示Delete（删除）。后面跟的是规则，INPUT表示入站，***.***.***.***表示要封停的IP，DROP表示放弃连接。
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#开启9090端口的访问</span>
</span></span><span class=line><span class=cl>/sbin/iptables -I INPUT -p tcp --dport <span class=m>9090</span> -j ACCEPT
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 防火墙开启、关闭、重启</span>
</span></span><span class=line><span class=cl>/etc/init.d/iptables status
</span></span><span class=line><span class=cl>/etc/init.d/iptables start
</span></span><span class=line><span class=cl>/etc/init.d/iptables stop
</span></span><span class=line><span class=cl>/etc/init.d/iptables restart
</span></span></code></pre></div><h2 id=nc命令-tcp调试利器>nc命令, tcp调试利器<a hidden class=anchor aria-hidden=true href=#nc命令-tcp调试利器>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1>#给某一个endpoint发送TCP请求,就将data的内容发送到对端</span>
</span></span><span class=line><span class=cl>nc 192.168.0.11 <span class=m>8000</span> &lt; data.txt
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#nc可以当做服务器，监听某个端口号,把某一次请求的内容存储到received_data里</span>
</span></span><span class=line><span class=cl>nc -l <span class=m>8000</span> &gt; received_data
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#上边只监听一次，如果多次可以加上-k参数</span>
</span></span><span class=line><span class=cl>nc -lk <span class=m>8000</span>
</span></span></code></pre></div><h2 id=tcpdump>tcpdump<a hidden class=anchor aria-hidden=true href=#tcpdump>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># dump出本机12301端口的tcp包</span>
</span></span><span class=line><span class=cl>tcpdump -i em1 tcp port <span class=m>12301</span> -s <span class=m>1500</span> -w abc.pcap
</span></span></code></pre></div><h2 id=跟踪网络路由路径>跟踪网络路由路径<a hidden class=anchor aria-hidden=true href=#跟踪网络路由路径>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># traceroute默认使用udp方式, 如果是-I则改成icmp方式</span>
</span></span><span class=line><span class=cl>traceroute -I www.163.com
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 从ttl第3跳跟踪</span>
</span></span><span class=line><span class=cl>traceroute -M <span class=m>3</span> www.163.com
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 加上端口跟踪</span>
</span></span><span class=line><span class=cl>traceroute -p <span class=m>8080</span> 192.168.10.11
</span></span></code></pre></div><h2 id=ss>ss<a hidden class=anchor aria-hidden=true href=#ss>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 显示本地打开的所有端口</span>
</span></span><span class=line><span class=cl>ss -l
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 显示每个进程具体打开的socket</span>
</span></span><span class=line><span class=cl>ss -pl
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 显示所有tcp socket</span>
</span></span><span class=line><span class=cl>ss -t -a
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 显示所有的UDP Socekt</span>
</span></span><span class=line><span class=cl>ss -u -a
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 显示所有已建立的SMTP连接</span>
</span></span><span class=line><span class=cl>ss -o state established <span class=s1>&#39;( dport = :smtp or sport = :smtp )&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 显示所有已建立的HTTP连接</span>
</span></span><span class=line><span class=cl>ss -o state established <span class=s1>&#39;( dport = :http or sport = :http )&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>找出所有连接X服务器的进程
</span></span><span class=line><span class=cl>ss -x src /tmp/.X11-unix/*
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>列出当前socket统计信息
</span></span><span class=line><span class=cl>ss -s
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>解释：netstat是遍历/proc下面每个PID目录，ss直接读/proc/net下面的统计信息。所以ss执行的时候消耗资源以及消耗的时间都比netstat少很多
</span></span></code></pre></div><h2 id=netstat>netstat<a hidden class=anchor aria-hidden=true href=#netstat>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 输出每个ip的连接数，以及总的各个状态的连接数</span>
</span></span><span class=line><span class=cl>netstat -n <span class=p>|</span> awk <span class=s1>&#39;/^tcp/ {n=split($(NF-1),array,&#34;:&#34;);if(n&lt;=2)++S[array[(1)]];else++S[array[(4)]];++s[$NF];++N} END {for(a in S){printf(&#34;%-20s %s\n&#34;, a, S[a]);++I}printf(&#34;%-20s %s\n&#34;,&#34;TOTAL_IP&#34;,I);for(a in s) printf(&#34;%-20s %s\n&#34;,a, s[a]);printf(&#34;%-20s %s\n&#34;,&#34;TOTAL_LINK&#34;,N);}&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 统计所有连接状态,</span>
</span></span><span class=line><span class=cl><span class=c1># CLOSED：无连接是活动的或正在进行</span>
</span></span><span class=line><span class=cl><span class=c1># LISTEN：服务器在等待进入呼叫</span>
</span></span><span class=line><span class=cl><span class=c1># SYN_RECV：一个连接请求已经到达，等待确认</span>
</span></span><span class=line><span class=cl><span class=c1># SYN_SENT：应用已经开始，打开一个连接</span>
</span></span><span class=line><span class=cl><span class=c1># ESTABLISHED：正常数据传输状态</span>
</span></span><span class=line><span class=cl><span class=c1># FIN_WAIT1：应用说它已经完成</span>
</span></span><span class=line><span class=cl><span class=c1># FIN_WAIT2：另一边已同意释放</span>
</span></span><span class=line><span class=cl><span class=c1># ITMED_WAIT：等待所有分组死掉</span>
</span></span><span class=line><span class=cl><span class=c1># CLOSING：两边同时尝试关闭</span>
</span></span><span class=line><span class=cl><span class=c1># TIME_WAIT：主动关闭连接一端还没有等到另一端反馈期间的状态</span>
</span></span><span class=line><span class=cl><span class=c1># LAST_ACK：等待所有分组死掉</span>
</span></span><span class=line><span class=cl>netstat -n <span class=p>|</span> awk <span class=s1>&#39;/^tcp/ {++state[$NF]} END {for(key in state) print key,&#34;\t&#34;,state[key]}&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 查找较多time_wait连接</span>
</span></span><span class=line><span class=cl>netstat -n<span class=p>|</span>grep TIME_WAIT<span class=p>|</span>awk <span class=s1>&#39;{print $5}&#39;</span><span class=p>|</span>sort<span class=p>|</span>uniq -c<span class=p>|</span>sort -rn<span class=p>|</span>head -n20
</span></span></code></pre></div><h2 id=top>top<a hidden class=anchor aria-hidden=true href=#top>#</a></h2><h2 id=dmesg查看系统日志>dmesg,查看系统日志<a hidden class=anchor aria-hidden=true href=#dmesg查看系统日志>#</a></h2><h2 id=iostat磁盘io情况监控>iostat,磁盘IO情况监控<a hidden class=anchor aria-hidden=true href=#iostat磁盘io情况监控>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>iostat -xz <span class=m>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># r/s, w/s, rkB/s, wkB/s：分别表示每秒读写次数和每秒读写数据量（千字节）。读写量过大，可能会引起性能问题。</span>
</span></span><span class=line><span class=cl><span class=c1># await：IO操作的平均等待时间，单位是毫秒。这是应用程序在和磁盘交互时，需要消耗的时间，包括IO等待和实际操作的耗时。如果这个数值过大，可能是硬件设备遇到了瓶颈或者出现故障。</span>
</span></span><span class=line><span class=cl><span class=c1># avgqu-sz：向设备发出的请求平均数量。如果这个数值大于1，可能是硬件设备已经饱和（部分前端硬件设备支持并行写入）。</span>
</span></span><span class=line><span class=cl><span class=c1># %util：设备利用率。这个数值表示设备的繁忙程度，经验值是如果超过60，可能会影响IO性能（可以参照IO操作平均等待时间）。如果到达100%，说明硬件设备已经饱和。</span>
</span></span><span class=line><span class=cl><span class=c1># 如果显示的是逻辑设备的数据，那么设备利用率不代表后端实际的硬件设备已经饱和。值得注意的是，即使IO性能不理想，也不一定意味这应用程序性能会不好，可以利用诸如预读取、写缓存等策略提升应用性能。</span>
</span></span></code></pre></div><h2 id=free内存使用情况>free,内存使用情况<a hidden class=anchor aria-hidden=true href=#free内存使用情况>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>free -m
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>eg:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>     total       used       free     shared    buffers     cached
</span></span><span class=line><span class=cl>Mem:          <span class=m>1002</span>        <span class=m>769</span>        <span class=m>232</span>          <span class=m>0</span>         <span class=m>62</span>        <span class=m>421</span>
</span></span><span class=line><span class=cl>-/+ buffers/cache:          <span class=m>286</span>        <span class=m>715</span>
</span></span><span class=line><span class=cl>Swap:          <span class=m>1153</span>          <span class=m>0</span>       <span class=m>1153</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>第一部分Mem行:
</span></span><span class=line><span class=cl>total 内存总数: 1002M
</span></span><span class=line><span class=cl>used 已经使用的内存数: 769M
</span></span><span class=line><span class=cl>free 空闲的内存数: 232M
</span></span><span class=line><span class=cl>shared 当前已经废弃不用,总是0
</span></span><span class=line><span class=cl>buffers Buffer 缓存内存数: 62M
</span></span><span class=line><span class=cl>cached Page 缓存内存数:421M
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>关系：total<span class=o>(</span>1002M<span class=o>)</span> <span class=o>=</span> used<span class=o>(</span>769M<span class=o>)</span> + free<span class=o>(</span>232M<span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>第二部分<span class=o>(</span>-/+ buffers/cache<span class=o>)</span>:
</span></span><span class=line><span class=cl><span class=o>(</span>-buffers/cache<span class=o>)</span> used内存数：286M <span class=o>(</span>指的第一部分Mem行中的used – buffers – cached<span class=o>)</span>
</span></span><span class=line><span class=cl><span class=o>(</span>+buffers/cache<span class=o>)</span> free内存数: 715M <span class=o>(</span>指的第一部分Mem行中的free + buffers + cached<span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>可见-buffers/cache反映的是被程序实实在在吃掉的内存,而+buffers/cache反映的是可以挪用的内存总数.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>第三部分是指交换分区
</span></span></code></pre></div><h2 id=sar查看网络吞吐状态>sar,查看网络吞吐状态<a hidden class=anchor aria-hidden=true href=#sar查看网络吞吐状态>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># sar命令在这里可以查看网络设备的吞吐率。在排查性能问题时，可以通过网络设备的吞吐量，判断网络设备是否已经饱和</span>
</span></span><span class=line><span class=cl>sar -n DEV <span class=m>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># sar命令在这里用于查看TCP连接状态，其中包括：</span>
</span></span><span class=line><span class=cl><span class=c1># active/s：每秒本地发起的TCP连接数，既通过connect调用创建的TCP连接；</span>
</span></span><span class=line><span class=cl><span class=c1># passive/s：每秒远程发起的TCP连接数，即通过accept调用创建的TCP连接；</span>
</span></span><span class=line><span class=cl><span class=c1># retrans/s：每秒TCP重传数量；</span>
</span></span><span class=line><span class=cl><span class=c1># TCP连接数可以用来判断性能问题是否由于建立了过多的连接，进一步可以判断是主动发起的连接，还是被动接受的连接。TCP重传可能是因为网络环境恶劣，或者服务器压力过大导致丢包</span>
</span></span><span class=line><span class=cl>sar -n TCP,ETCP <span class=m>1</span>
</span></span></code></pre></div><h2 id=vmstat-给定时间监控cpu使用率-内存使用-虚拟内存交互-io读写>vmstat, 给定时间监控CPU使用率, 内存使用, 虚拟内存交互, IO读写<a hidden class=anchor aria-hidden=true href=#vmstat-给定时间监控cpu使用率-内存使用-虚拟内存交互-io读写>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 2表示每2秒采集一次状态信息, 1表示只采集一次(忽略既是一直采集)</span>
</span></span><span class=line><span class=cl>vmstat <span class=m>2</span> <span class=m>1</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://lesanouo.github.io/blog/tags/linux/>Linux</a></li></ul><nav class=paginav><a class=prev href=https://lesanouo.github.io/blog/posts/knowledge/rabbitmq%E7%AC%94%E8%AE%B0/><span class=title>«</span><br><span>RabbitMQ笔记</span>
</a><a class=next href=https://lesanouo.github.io/blog/posts/snippet/maven-aliyun-nexus/><span class=title>»</span><br><span>Maven 阿里云镜像</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://lesanouo.github.io/blog/>Lesan's Blog</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>