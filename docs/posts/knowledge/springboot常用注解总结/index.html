<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>SpringBoot常用注解总结 | Lesan's Blog</title><meta name=keywords content="SpringBoot"><meta name=description content="简介
基于 SpringBoot 平台开发的项目数不胜数，与常规的基于Spring开发的项目最大的不同之处，SpringBoot 里面提供了大量的注解用于快速开发，而且非常简单，基本可以做到开箱即用！"><meta name=author content="Lesan"><link rel=canonical href=https://lesanouo.github.io/blog/posts/knowledge/springboot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E6%80%BB%E7%BB%93/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://lesanouo.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://lesanouo.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://lesanouo.github.io/blog/favicon.ico><link rel=apple-touch-icon href=https://lesanouo.github.io/blog/favicon.ico><link rel=mask-icon href=https://lesanouo.github.io/blog/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-cn href=https://lesanouo.github.io/blog/posts/knowledge/springboot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E6%80%BB%E7%BB%93/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:url" content="https://lesanouo.github.io/blog/posts/knowledge/springboot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E6%80%BB%E7%BB%93/"><meta property="og:site_name" content="Lesan's Blog"><meta property="og:title" content="SpringBoot常用注解总结"><meta property="og:description" content="简介 基于 SpringBoot 平台开发的项目数不胜数，与常规的基于Spring开发的项目最大的不同之处，SpringBoot 里面提供了大量的注解用于快速开发，而且非常简单，基本可以做到开箱即用！"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-11-26T00:00:00+00:00"><meta property="article:modified_time" content="2022-11-26T00:00:00+00:00"><meta property="article:tag" content="SpringBoot"><meta name=twitter:card content="summary"><meta name=twitter:title content="SpringBoot常用注解总结"><meta name=twitter:description content="简介
基于 SpringBoot 平台开发的项目数不胜数，与常规的基于Spring开发的项目最大的不同之处，SpringBoot 里面提供了大量的注解用于快速开发，而且非常简单，基本可以做到开箱即用！"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"📚 博客","item":"https://lesanouo.github.io/blog/posts/"},{"@type":"ListItem","position":2,"name":"SpringBoot常用注解总结","item":"https://lesanouo.github.io/blog/posts/knowledge/springboot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E6%80%BB%E7%BB%93/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"SpringBoot常用注解总结","name":"SpringBoot常用注解总结","description":"简介 基于 SpringBoot 平台开发的项目数不胜数，与常规的基于Spring开发的项目最大的不同之处，SpringBoot 里面提供了大量的注解用于快速开发，而且非常简单，基本可以做到开箱即用！\n","keywords":["SpringBoot"],"articleBody":"简介 基于 SpringBoot 平台开发的项目数不胜数，与常规的基于Spring开发的项目最大的不同之处，SpringBoot 里面提供了大量的注解用于快速开发，而且非常简单，基本可以做到开箱即用！\n注解总结 SpringMVC 相关注解 @Controller 通常用于修饰controller层的组件，由控制器负责将用户发来的URL请求转发到对应的服务接口，通常还需要配合注解@RequestMapping使用。\n@RequestMapping 提供路由信息，负责URL到Controller中具体函数的映射，当用于方法上时，可以指定请求协议，比如GET、POST、PUT、DELETE等等。\n@RequestBody 表示请求体的Content-Type必须为application/json格式的数据，接收到数据之后会自动将数据绑定到Java对象上去。\n@ResponseBody 表示该方法的返回结果直接写入HTTP response body中，返回数据的格式为application/json。\n比如，请求参数为json格式，返回参数也为json格式，示例代码如下：\n@Controller @RequestMapping(\"api\") public class LoginController { /** * 登录请求，post请求协议，请求参数数据格式为json * @param request */ @RequestMapping(value = \"login\", method = RequestMethod.POST) @ResponseBody public ResponseEntity login(@RequestBody UserLoginDTO request){ //...业务处理 return new ResponseEntity(HttpStatus.OK); } } @RestController 和@Controller一样，用于标注控制层组件，不同的地方在于：它是@ResponseBody和@Controller的合集，也就是说，在当@RestController用在类上时，表示当前类里面所有对外暴露的接口方法，返回数据的格式都为application/json。\n@RequestParam 用于接收请求参数为表单类型的数据，通常用在方法的参数前面，示范代码如下：\n@RequestMapping(value = \"login\", method = RequestMethod.POST) @ResponseBody public ResponseEntity login(@RequestParam(value = \"userName\",required = true) String userName, @RequestParam(value = \"userPwd\",required = true) String userPwd){ //...业务处理 return new ResponseEntity(HttpStatus.OK); } @PathVariable 用于获取请求路径中的参数，通常用于restful风格的api上，示范代码如下：\n@RequestMapping(value = \"queryProduct/{id}\", method = RequestMethod.POST) @ResponseBody public ResponseEntity queryProduct(@PathVariable(\"id\") String id){ //...业务处理 return new ResponseEntity(HttpStatus.OK); } @GetMapping 除了@RequestMapping可以指定请求方式之外，还有一些其他的注解，可以用于标注接口路径请求，比如GetMapping用在方法上时，表示只支持get请求方法，等价于@RequestMapping(value=\"/get\",method=RequestMethod.GET)。\n@PostMapping 用在方法上，表示只支持post方式的请求。\n@PutMapping 用在方法上，表示只支持put方式的请求，通常表示更新某些资源的意思。\n@DeleteMapping 用在方法上，表示只支持delete方式的请求，通常表示删除某些资源的意思。\nbean 相关注解 @Service 通常用于修饰service层的组件，声明一个对象，会将类对象实例化并注入到bean容器里面。\n@Component 泛指组件，当组件不好归类的时候，可以使用这个注解进行标注，功能类似于于@Service。\n@Repository 通常用于修饰dao层的组件，@Repository注解属于Spring里面最先引入的一批注解，它用于将数据访问层 (DAO层) 的类标识为Spring Bean，具体只需将该注解标注在DAO类上即可，示例代码如下：\n@Repository public interface RoleRepository extends JpaRepository\u003cRole,Long\u003e { //具体的方法 } 为什么现在使用的很少呢？\n主要是因为当我们配置服务启动自动扫描dao层包时，Spring会自动帮我们创建一个实现类，然后注入到bean容器里面。当某些类无法被扫描到时，我们可以显式的在数据持久类上标注@Repository注解，Spring会自动帮我们声明对象。\n@Bean 相当于 xml 中配置 Bean，意思是产生一个 bean 对象，并交给spring管理，示例代码如下：\n@Configuration public class AppConfig { //相当于 xml 中配置 Bean @Bean public Uploader initFileUploader() { return new FileUploader(); } } @Autowired 自动导入依赖的bean对象，默认时按照byType方式导入对象，而且导入的对象必须存在，当需要导入的对象并不存在时，我们可以通过配置required = false来关闭强制验证。\n@Resource 也是自动导入依赖的bean对象，由JDK提供，默认是按照byName方式导入依赖的对象；而@Autowired默认时按照byType方式导入对象，当然@Resource还可以配置成通过byType方式导入对象。\n/** * 通过名称导入（默认通过名称导入依赖对象） */ @Resource(name = \"deptService\") private DeptService deptService; /** * 通过类型导入 */ @Resource(type = RoleRepository.class) private DeptService deptService; @Qualifier 当有多个同一类型的bean时，使用@Autowired导入会报错，提示当前对象并不是唯一，Spring不知道导入哪个依赖，这个时候，我们可以使用@Qualifier进行更细粒度的控制，选择其中一个候选者，一般于@Autowired搭配使用，示例如下：\n@Autowired @Qualifier(\"deptService\") private DeptService deptService; @Scope 用于生命一个spring bean的作用域，作用的范围一共有以下几种：\nsingleton：唯一 bean 实例，Spring 中的 bean 默认都是单例的。 prototype：每次请求都会创建一个新的 bean 实例，对象多例。 request：每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。 session：每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。 /** * 单例对象 */ @RestController @Scope(\"singleton\") public class HelloController { } 配置相关注解 @Configuration 表示声明一个 Java 形式的配置类，Spring Boot 提倡基于 Java 的配置，相当于你之前在 xml 中配置 bean，比如声明一个配置类AppConfig，然后初始化一个Uploader对象。\n@Configuration public class AppConfig { @Bean public Uploader initOSSUploader() { return new OSSUploader(); } } @EnableAutoConfiguration @EnableAutoConfiguration可以帮助Spring Boot应用将所有符合条件的@Configuration配置类，全部都加载到当前Spring Boot里，并创建对应配置类的Bean，并把该Bean实体交给IoC容器进行管理。\n某些场景下，如果我们想要避开某些配置类的扫描（包括避开一些第三方jar包下面的配置，可以这样处理。\n@Configuration @EnableAutoConfiguration(exclude = { org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration.class}) public class AppConfig { //具有业务方法 } @ComponentScan 标注哪些路径下的类需要被Spring扫描，用于自动发现和装配一些Bean对象，默认配置是扫描当前文件夹下和子目录下的所有类，如果我们想指定扫描某些包路径，可以这样处理。\n@ComponentScan(basePackages = {\"com.xxx.a\", \"com.xxx.b\", \"com.xxx.c\"}) @SpringBootApplication 等价于使用@Configuration、@EnableAutoConfiguration、@ComponentScan这三个注解，通常用于全局启动类上，示例如下：\n@SpringBootApplication public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } 把@SpringBootApplication换成@Configuration、@EnableAutoConfiguration、@ComponentScan这三个注解，一样可以启动成功，@SpringBootApplication只是将这三个注解进行了简化！\n@EnableTransactionManagement 表示开启事务支持，等同于 xml 配置方式的\n@Conditional 从 Spring4 开始，可以通过@Conditional注解实现按条件装载bean对象，目前 Spring Boot 源码中大量扩展了@Condition注解，用于实现智能的自动化配置，满足各种使用场景。下面我给大家列举几个常用的注解：\n@ConditionalOnBean：当某个特定的Bean存在时，配置生效 @ConditionalOnMissingBean：当某个特定的Bean不存在时，配置生效 @ConditionalOnClass：当Classpath里存在指定的类，配置生效 @ConditionalOnMissingClass：当Classpath里不存在指定的类，配置生效 @ConditionalOnExpression：当给定的SpEL表达式计算结果为true，配置生效 @ConditionalOnProperty：当指定的配置属性有一个明确的值并匹配，配置生效 具体的应用案例如下：\n@Configuration public class ConditionalConfig { /** * 当AppConfig对象存在时，创建一个A对象 */ @ConditionalOnBean(AppConfig.class) @Bean public A createA(){ return new A(); } /** * 当AppConfig对象不存在时，创建一个B对象 */ @ConditionalOnMissingBean(AppConfig.class) @Bean public B createB(){ return new B(); } /** * 当KafkaTemplate类存在时，创建一个C对象 */ @ConditionalOnClass(KafkaTemplate.class) @Bean public C createC(){ return new C(); } /** * 当KafkaTemplate类不存在时，创建一个D对象 */ @ConditionalOnMissingClass(KafkaTemplate.class) @Bean public D createD(){ return new D(); } /** * 当enableConfig的配置为true，创建一个E对象 */ @ConditionalOnExpression(\"${enableConfig:false}\") @Bean public E createE(){ return new E(); } /** * 当filter.loginFilter的配置为true，创建一个F对象 */ @ConditionalOnProperty(prefix = \"filter\",name = \"loginFilter\",havingValue = \"true\") @Bean public F createF(){ return new F(); } } @value 可以在任意 Spring 管理的 Bean 中通过这个注解获取任何来源配置的属性值，比如你在application.properties文件里，定义了一个参数变量！\nconfig.name=zhangsan\n在任意的bean容器里面，可以通过@Value注解注入参数，获取参数变量值。\n@RestController public class HelloController { @Value(\"${config.name}\") private String config; @GetMapping(\"config\") public String config(){ return JSON.toJSONString(config); } } @ConfigurationProperties 上面@Value在每个类中获取属性配置值的做法，其实是不推荐的。\n一般在企业项目开发中，不会使用那么杂乱无章的写法而且维护也麻烦，通常会一次性读取一个 Java 配置类，然后在需要使用的地方直接引用这个类就可以多次访问了，方便维护，示例如下：\n首先，在application.properties文件里定义好参数变量。\nconfig.name=demo_1 config.value=demo_value_1 然后，创建一个 Java 配置类，将参数变量注入即可！\n@Component @ConfigurationProperties(prefix = \"config\") public class Config { public String name; public String value; //...get、set } 最后，在需要使用的地方，通过IOC注入Config对象即可！\n@PropertySource 这个注解是用来读取我们自定义的配置文件的，比如导入test.properties和bussiness.properties两个配置文件，用法如下：\n@SpringBootApplication @PropertySource(value = {\"test.properties\",\"bussiness.properties\"}) public class PropertyApplication { public static void main(String[] args) { SpringApplication.run(PropertyApplication.class, args); } } @ImportResource 用来加载 xml 配置文件，比如导入自定义的aaa.xml文件，用法如下：\n@ImportResource(locations = \"classpath:aaa.xml\") @SpringBootApplication public class PropertyApplication { public static void main(String[] args) { SpringApplication.run(PropertyApplication.class, args); } } 异常处理相关注解 @ControllerAdvice 和 @ExceptionHandler 通常组合使用，用于处理全局异常，示例代码如下：\n@ControllerAdvice @Configuration @Slf4j public class GlobalExceptionConfig { private static final Integer GLOBAL_ERROR_CODE = 500; @ExceptionHandler(value = Exception.class) @ResponseBody public void exceptionHandler(HttpServletRequest request, HttpServletResponse response, Exception e) throws Exception { log.error(\"【统一异常处理器】\", e); ResultMsg\u003cObject\u003e resultMsg = new ResultMsg\u003c\u003e(); resultMsg.setCode(GLOBAL_ERROR_CODE); if (e instanceof CommonException) { CommonException ex = (CommonException) e; if(ex.getErrCode() != 0) { resultMsg.setCode(ex.getErrCode()); } resultMsg.setMsg(ex.getErrMsg()); }else { resultMsg.setMsg(CommonErrorMsg.SYSTEM_ERROR.getMessage()); } WebUtil.buildPrintWriter(response, resultMsg); } } 测试相关注解 @ActiveProfiles 一般作用于测试类上， 用于声明生效的 Spring 配置文件，比如指定application-dev.properties配置文件。\n@RunWith 和 @SpringBootTest 一般作用于测试类上， 用于单元测试用，示例如下：\n@ActiveProfiles(\"dev\") @RunWith(SpringRunner.class) @SpringBootTest public class TestJunit { @Test public void executeTask() { //测试... } } ","wordCount":"3992","inLanguage":"zh-cn","datePublished":"2022-11-26T00:00:00Z","dateModified":"2022-11-26T00:00:00Z","author":{"@type":"Person","name":"Lesan"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://lesanouo.github.io/blog/posts/knowledge/springboot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E6%80%BB%E7%BB%93/"},"publisher":{"@type":"Organization","name":"Lesan's Blog","logo":{"@type":"ImageObject","url":"https://lesanouo.github.io/blog/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://lesanouo.github.io/blog/ accesskey=h title="Lesan's Blog (Alt + H)">Lesan's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://lesanouo.github.io/blog/archives title="📚 归档"><span>📚 归档</span></a></li><li><a href=https://lesanouo.github.io/blog/categories/ title="🗃️ 分类"><span>🗃️ 分类</span></a></li><li><a href=https://lesanouo.github.io/blog/tags/ title="🏷️ 标签"><span>🏷️ 标签</span></a></li><li><a href=https://lesanouo.github.io/blog/search/ title="🔎 搜索"><span>🔎 搜索</span></a></li><li><a href=https://lesanouo.github.io/blog/about/ title="👨‍💻 关于我"><span>👨‍💻 关于我</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://lesanouo.github.io/blog/>Home</a>&nbsp;»&nbsp;<a href=https://lesanouo.github.io/blog/posts/>📚 博客</a></div><h1 class="post-title entry-hint-parent">SpringBoot常用注解总结</h1><div class=post-meta><span title='2022-11-26 00:00:00 +0000 UTC'>2022-11-26</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Lesan</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e7%ae%80%e4%bb%8b aria-label=简介>简介</a></li><li><a href=#%e6%b3%a8%e8%a7%a3%e6%80%bb%e7%bb%93 aria-label=注解总结>注解总结</a><ul><li><a href=#springmvc-%e7%9b%b8%e5%85%b3%e6%b3%a8%e8%a7%a3 aria-label="SpringMVC 相关注解">SpringMVC 相关注解</a></li><li><a href=#bean-%e7%9b%b8%e5%85%b3%e6%b3%a8%e8%a7%a3 aria-label="bean 相关注解">bean 相关注解</a></li><li><a href=#%e9%85%8d%e7%bd%ae%e7%9b%b8%e5%85%b3%e6%b3%a8%e8%a7%a3 aria-label=配置相关注解>配置相关注解</a></li><li><a href=#%e5%bc%82%e5%b8%b8%e5%a4%84%e7%90%86%e7%9b%b8%e5%85%b3%e6%b3%a8%e8%a7%a3 aria-label=异常处理相关注解>异常处理相关注解</a></li><li><a href=#%e6%b5%8b%e8%af%95%e7%9b%b8%e5%85%b3%e6%b3%a8%e8%a7%a3 aria-label=测试相关注解>测试相关注解</a></li></ul></li></ul></div></details></div><div class=post-content><h2 id=简介>简介<a hidden class=anchor aria-hidden=true href=#简介>#</a></h2><p>基于 SpringBoot 平台开发的项目数不胜数，与常规的基于Spring开发的项目最大的不同之处，SpringBoot 里面提供了大量的注解用于快速开发，而且非常简单，基本可以做到开箱即用！</p><h2 id=注解总结>注解总结<a hidden class=anchor aria-hidden=true href=#注解总结>#</a></h2><h3 id=springmvc-相关注解>SpringMVC 相关注解<a hidden class=anchor aria-hidden=true href=#springmvc-相关注解>#</a></h3><ul><li>@Controller</li></ul><p>通常用于修饰<code>controller</code>层的组件，由控制器负责将用户发来的URL请求转发到对应的服务接口，通常还需要配合注解<code>@RequestMapping</code>使用。</p><ul><li>@RequestMapping</li></ul><p>提供路由信息，负责<code>URL</code>到<code>Controller</code>中具体函数的映射，当用于方法上时，可以指定请求协议，比如<code>GET</code>、<code>POST</code>、<code>PUT</code>、<code>DELETE</code>等等。</p><ul><li>@RequestBody</li></ul><p>表示请求体的<code>Content-Type</code>必须为<code>application/json</code>格式的数据，接收到数据之后会自动将数据绑定到<code>Java</code>对象上去。</p><ul><li>@ResponseBody</li></ul><p>表示该方法的返回结果直接写入<code>HTTP response body</code>中，返回数据的格式为<code>application/json</code>。</p><p>比如，请求参数为json格式，返回参数也为json格式，示例代码如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Controller</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@RequestMapping</span><span class=p>(</span><span class=s>&#34;api&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>LoginController</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * 登录请求，post请求协议，请求参数数据格式为json
</span></span></span><span class=line><span class=cl><span class=cm>     * @param request
</span></span></span><span class=line><span class=cl><span class=cm>     */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@RequestMapping</span><span class=p>(</span><span class=n>value</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;login&#34;</span><span class=p>,</span><span class=w> </span><span class=n>method</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>RequestMethod</span><span class=p>.</span><span class=na>POST</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@ResponseBody</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>ResponseEntity</span><span class=w> </span><span class=nf>login</span><span class=p>(</span><span class=nd>@RequestBody</span><span class=w> </span><span class=n>UserLoginDTO</span><span class=w> </span><span class=n>request</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>//...业务处理</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ResponseEntity</span><span class=p>(</span><span class=n>HttpStatus</span><span class=p>.</span><span class=na>OK</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><ul><li>@RestController</li></ul><p>和<code>@Controller</code>一样，用于标注控制层组件，不同的地方在于：它是<code>@ResponseBody</code>和<code>@Controller</code>的合集，也就是说，在当<code>@RestController</code>用在类上时，表示当前类里面所有对外暴露的接口方法，返回数据的格式都为<code>application/json</code>。</p><ul><li>@RequestParam</li></ul><p>用于接收请求参数为表单类型的数据，通常用在方法的参数前面，示范代码如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@RequestMapping</span><span class=p>(</span><span class=n>value</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;login&#34;</span><span class=p>,</span><span class=w> </span><span class=n>method</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>RequestMethod</span><span class=p>.</span><span class=na>POST</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@ResponseBody</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=n>ResponseEntity</span><span class=w> </span><span class=nf>login</span><span class=p>(</span><span class=nd>@RequestParam</span><span class=p>(</span><span class=n>value</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;userName&#34;</span><span class=p>,</span><span class=n>required</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>true</span><span class=p>)</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=n>userName</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=nd>@RequestParam</span><span class=p>(</span><span class=n>value</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;userPwd&#34;</span><span class=p>,</span><span class=n>required</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>true</span><span class=p>)</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=n>userPwd</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>//...业务处理</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ResponseEntity</span><span class=p>(</span><span class=n>HttpStatus</span><span class=p>.</span><span class=na>OK</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><ul><li>@PathVariable</li></ul><p>用于获取请求路径中的参数，通常用于restful风格的api上，示范代码如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@RequestMapping</span><span class=p>(</span><span class=n>value</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;queryProduct/{id}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>method</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>RequestMethod</span><span class=p>.</span><span class=na>POST</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@ResponseBody</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=n>ResponseEntity</span><span class=w> </span><span class=nf>queryProduct</span><span class=p>(</span><span class=nd>@PathVariable</span><span class=p>(</span><span class=s>&#34;id&#34;</span><span class=p>)</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=n>id</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>//...业务处理</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ResponseEntity</span><span class=p>(</span><span class=n>HttpStatus</span><span class=p>.</span><span class=na>OK</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><ul><li>@GetMapping</li></ul><p>除了<code>@RequestMapping</code>可以指定请求方式之外，还有一些其他的注解，可以用于标注接口路径请求，比如<code>GetMapping</code>用在方法上时，表示只支持<code>get</code>请求方法，等价于<code>@RequestMapping(value="/get",method=RequestMethod.GET)</code>。</p><ul><li>@PostMapping</li></ul><p>用在方法上，表示只支持<code>post</code>方式的请求。</p><ul><li>@PutMapping</li></ul><p>用在方法上，表示只支持<code>put</code>方式的请求，通常表示更新某些资源的意思。</p><ul><li>@DeleteMapping</li></ul><p>用在方法上，表示只支持<code>delete</code>方式的请求，通常表示删除某些资源的意思。</p><h3 id=bean-相关注解>bean 相关注解<a hidden class=anchor aria-hidden=true href=#bean-相关注解>#</a></h3><ul><li>@Service</li></ul><p>通常用于修饰service层的组件，声明一个对象，会将类对象实例化并注入到bean容器里面。</p><ul><li>@Component</li></ul><p>泛指组件，当组件不好归类的时候，可以使用这个注解进行标注，功能类似于于<code>@Service</code>。</p><ul><li>@Repository</li></ul><p>通常用于修饰<code>dao</code>层的组件，<code>@Repository</code>注解属于<code>Spring</code>里面最先引入的一批注解，它用于将数据访问层 (<code>DAO层</code>) 的类标识为<code>Spring Bean</code>，具体只需将该注解标注在DAO类上即可，示例代码如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Repository</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>interface</span> <span class=nc>RoleRepository</span><span class=w> </span><span class=kd>extends</span><span class=w> </span><span class=n>JpaRepository</span><span class=o>&lt;</span><span class=n>Role</span><span class=p>,</span><span class=n>Long</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>//具体的方法</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>为什么现在使用的很少呢？</p><p>主要是因为当我们配置服务启动自动扫描<code>dao</code>层包时，<code>Spring</code>会自动帮我们创建一个实现类，然后注入到<code>bean</code>容器里面。当某些类无法被扫描到时，我们可以显式的在数据持久类上标注<code>@Repository</code>注解，<code>Spring</code>会自动帮我们声明对象。</p><ul><li>@Bean</li></ul><p>相当于 <code>xml</code> 中配置 <code>Bean</code>，意思是产生一个 <code>bean</code> 对象，并交给<code>spring</code>管理，示例代码如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Configuration</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>AppConfig</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>//相当于 xml 中配置 Bean</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Bean</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>Uploader</span><span class=w> </span><span class=nf>initFileUploader</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>FileUploader</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><ul><li>@Autowired</li></ul><p>自动导入依赖的<code>bean</code>对象，默认时按照<code>byType</code>方式导入对象，而且导入的对象必须存在，当需要导入的对象并不存在时，我们可以通过配置<code>required = false</code>来关闭强制验证。</p><ul><li>@Resource</li></ul><p>也是自动导入依赖的<code>bean</code>对象，由<code>JDK</code>提供，默认是按照<code>byName</code>方式导入依赖的对象；而<code>@Autowired</code>默认时按照<code>byType</code>方式导入对象，当然<code>@Resource</code>还可以配置成通过<code>byType</code>方式导入对象。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * 通过名称导入（默认通过名称导入依赖对象）
</span></span></span><span class=line><span class=cl><span class=cm> */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@Resource</span><span class=p>(</span><span class=n>name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;deptService&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>private</span><span class=w> </span><span class=n>DeptService</span><span class=w> </span><span class=n>deptService</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * 通过类型导入
</span></span></span><span class=line><span class=cl><span class=cm> */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@Resource</span><span class=p>(</span><span class=n>type</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>RoleRepository</span><span class=p>.</span><span class=na>class</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>private</span><span class=w> </span><span class=n>DeptService</span><span class=w> </span><span class=n>deptService</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><ul><li>@Qualifier</li></ul><p>当有多个同一类型的<code>bean</code>时，使用<code>@Autowired</code>导入会报错，提示当前对象并不是唯一，<code>Spring</code>不知道导入哪个依赖，这个时候，我们可以使用<code>@Qualifier</code>进行更细粒度的控制，选择其中一个候选者，一般于<code>@Autowired</code>搭配使用，示例如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Autowired</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@Qualifier</span><span class=p>(</span><span class=s>&#34;deptService&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>private</span><span class=w> </span><span class=n>DeptService</span><span class=w> </span><span class=n>deptService</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><ul><li>@Scope</li></ul><p>用于生命一个<code>spring bean</code>的作用域，作用的范围一共有以下几种：</p><ol><li>singleton：唯一 bean 实例，Spring 中的 bean 默认都是单例的。</li><li>prototype：每次请求都会创建一个新的 bean 实例，对象多例。</li><li>request：每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。</li><li>session：每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * 单例对象
</span></span></span><span class=line><span class=cl><span class=cm> */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@RestController</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@Scope</span><span class=p>(</span><span class=s>&#34;singleton&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>HelloController</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h3 id=配置相关注解>配置相关注解<a hidden class=anchor aria-hidden=true href=#配置相关注解>#</a></h3><ul><li>@Configuration</li></ul><p>表示声明一个 <code>Java</code> 形式的配置类，<code>Spring Boot</code> 提倡基于 <code>Java</code> 的配置，相当于你之前在 <code>xml</code> 中配置 <code>bean</code>，比如声明一个配置类<code>AppConfig</code>，然后初始化一个<code>Uploader</code>对象。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Configuration</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>AppConfig</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Bean</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>Uploader</span><span class=w> </span><span class=nf>initOSSUploader</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>OSSUploader</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><ul><li>@EnableAutoConfiguration</li></ul><p><code>@EnableAutoConfiguration</code>可以帮助<code>Spring Boot</code>应用将所有符合条件的<code>@Configuration</code>配置类，全部都加载到当前<code>Spring Boot</code>里，并创建对应配置类的<code>Bean</code>，并把该<code>Bean</code>实体交给<code>IoC</code>容器进行管理。</p><p>某些场景下，如果我们想要避开某些配置类的扫描（包括避开一些第三方jar包下面的配置，可以这样处理。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Configuration</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@EnableAutoConfiguration</span><span class=p>(</span><span class=n>exclude</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>org</span><span class=p>.</span><span class=na>springframework</span><span class=p>.</span><span class=na>boot</span><span class=p>.</span><span class=na>autoconfigure</span><span class=p>.</span><span class=na>security</span><span class=p>.</span><span class=na>servlet</span><span class=p>.</span><span class=na>SecurityAutoConfiguration</span><span class=p>.</span><span class=na>class</span><span class=p>})</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>AppConfig</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=c1>//具有业务方法</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><ul><li>@ComponentScan</li></ul><p>标注哪些路径下的类需要被<code>Spring</code>扫描，用于自动发现和装配一些<code>Bean</code>对象，默认配置是扫描当前文件夹下和子目录下的所有类，如果我们想指定扫描某些包路径，可以这样处理。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@ComponentScan</span><span class=p>(</span><span class=n>basePackages</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>{</span><span class=s>&#34;com.xxx.a&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;com.xxx.b&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;com.xxx.c&#34;</span><span class=p>})</span><span class=w>
</span></span></span></code></pre></div><ul><li>@SpringBootApplication</li></ul><p>等价于使用<code>@Configuration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code>这三个注解，通常用于全局启动类上，示例如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@SpringBootApplication</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>Application</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>main</span><span class=p>(</span><span class=n>String</span><span class=o>[]</span><span class=w> </span><span class=n>args</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>SpringApplication</span><span class=p>.</span><span class=na>run</span><span class=p>(</span><span class=n>Application</span><span class=p>.</span><span class=na>class</span><span class=p>,</span><span class=w> </span><span class=n>args</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>把<code>@SpringBootApplication</code>换成<code>@Configuration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code>这三个注解，一样可以启动成功，<code>@SpringBootApplication</code>只是将这三个注解进行了简化！</p><ul><li>@EnableTransactionManagement</li></ul><p>表示开启事务支持，等同于 <code>xml</code> 配置方式的<code>&lt;tx:annotation-driven /></code></p><ul><li>@Conditional</li></ul><p>从 <code>Spring4</code> 开始，可以通过<code>@Conditional</code>注解实现按条件装载<code>bean</code>对象，目前 <code>Spring Boot</code> 源码中大量扩展了<code>@Condition</code>注解，用于实现智能的自动化配置，满足各种使用场景。下面我给大家列举几个常用的注解：</p><ol><li>@ConditionalOnBean：当某个特定的Bean存在时，配置生效</li><li>@ConditionalOnMissingBean：当某个特定的Bean不存在时，配置生效</li><li>@ConditionalOnClass：当Classpath里存在指定的类，配置生效</li><li>@ConditionalOnMissingClass：当Classpath里不存在指定的类，配置生效</li><li>@ConditionalOnExpression：当给定的SpEL表达式计算结果为true，配置生效</li><li>@ConditionalOnProperty：当指定的配置属性有一个明确的值并匹配，配置生效</li></ol><p>具体的应用案例如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Configuration</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>ConditionalConfig</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * 当AppConfig对象存在时，创建一个A对象
</span></span></span><span class=line><span class=cl><span class=cm>     */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@ConditionalOnBean</span><span class=p>(</span><span class=n>AppConfig</span><span class=p>.</span><span class=na>class</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Bean</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>A</span><span class=w> </span><span class=nf>createA</span><span class=p>(){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>A</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * 当AppConfig对象不存在时，创建一个B对象
</span></span></span><span class=line><span class=cl><span class=cm>     */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@ConditionalOnMissingBean</span><span class=p>(</span><span class=n>AppConfig</span><span class=p>.</span><span class=na>class</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Bean</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>B</span><span class=w> </span><span class=nf>createB</span><span class=p>(){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>B</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * 当KafkaTemplate类存在时，创建一个C对象
</span></span></span><span class=line><span class=cl><span class=cm>     */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@ConditionalOnClass</span><span class=p>(</span><span class=n>KafkaTemplate</span><span class=p>.</span><span class=na>class</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Bean</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>C</span><span class=w> </span><span class=nf>createC</span><span class=p>(){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>C</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * 当KafkaTemplate类不存在时，创建一个D对象
</span></span></span><span class=line><span class=cl><span class=cm>     */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@ConditionalOnMissingClass</span><span class=p>(</span><span class=n>KafkaTemplate</span><span class=p>.</span><span class=na>class</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Bean</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>D</span><span class=w> </span><span class=nf>createD</span><span class=p>(){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>D</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * 当enableConfig的配置为true，创建一个E对象
</span></span></span><span class=line><span class=cl><span class=cm>     */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@ConditionalOnExpression</span><span class=p>(</span><span class=s>&#34;${enableConfig:false}&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Bean</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>E</span><span class=w> </span><span class=nf>createE</span><span class=p>(){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>E</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * 当filter.loginFilter的配置为true，创建一个F对象
</span></span></span><span class=line><span class=cl><span class=cm>     */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@ConditionalOnProperty</span><span class=p>(</span><span class=n>prefix</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;filter&#34;</span><span class=p>,</span><span class=n>name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;loginFilter&#34;</span><span class=p>,</span><span class=n>havingValue</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;true&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Bean</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>F</span><span class=w> </span><span class=nf>createF</span><span class=p>(){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>F</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><ul><li>@value</li></ul><p>可以在任意 <code>Spring</code> 管理的 <code>Bean</code> 中通过这个注解获取任何来源配置的属性值，比如你在<code>application.properties</code>文件里，定义了一个参数变量！</p><p><code>config.name=zhangsan</code></p><p>在任意的<code>bean</code>容器里面，可以通过<code>@Value</code>注解注入参数，获取参数变量值。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@RestController</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>HelloController</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Value</span><span class=p>(</span><span class=s>&#34;${config.name}&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=n>config</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@GetMapping</span><span class=p>(</span><span class=s>&#34;config&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=nf>config</span><span class=p>(){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>JSON</span><span class=p>.</span><span class=na>toJSONString</span><span class=p>(</span><span class=n>config</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><ul><li>@ConfigurationProperties</li></ul><p>上面<code>@Value</code>在每个类中获取属性配置值的做法，其实是不推荐的。</p><p>一般在企业项目开发中，不会使用那么杂乱无章的写法而且维护也麻烦，通常会一次性读取一个 <code>Java</code> 配置类，然后在需要使用的地方直接引用这个类就可以多次访问了，方便维护，示例如下：</p><p>首先，在<code>application.properties</code>文件里定义好参数变量。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-properties data-lang=properties><span class=line><span class=cl><span class=na>config.name</span><span class=o>=</span><span class=s>demo_1</span>
</span></span><span class=line><span class=cl><span class=na>config.value</span><span class=o>=</span><span class=s>demo_value_1</span>
</span></span></code></pre></div><p>然后，创建一个 <code>Java</code> 配置类，将参数变量注入即可！</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Component</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@ConfigurationProperties</span><span class=p>(</span><span class=n>prefix</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;config&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>Config</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=n>name</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=n>value</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>//...get、set</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>最后，在需要使用的地方，通过<code>IOC</code>注入<code>Config</code>对象即可！</p><ul><li>@PropertySource</li></ul><p>这个注解是用来读取我们自定义的配置文件的，比如导入<code>test.properties</code>和<code>bussiness.properties</code>两个配置文件，用法如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@SpringBootApplication</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@PropertySource</span><span class=p>(</span><span class=n>value</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>{</span><span class=s>&#34;test.properties&#34;</span><span class=p>,</span><span class=s>&#34;bussiness.properties&#34;</span><span class=p>})</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>PropertyApplication</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>main</span><span class=p>(</span><span class=n>String</span><span class=o>[]</span><span class=w> </span><span class=n>args</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>SpringApplication</span><span class=p>.</span><span class=na>run</span><span class=p>(</span><span class=n>PropertyApplication</span><span class=p>.</span><span class=na>class</span><span class=p>,</span><span class=w> </span><span class=n>args</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><ul><li>@ImportResource</li></ul><p>用来加载 <code>xml</code> 配置文件，比如导入自定义的<code>aaa.xml</code>文件，用法如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@ImportResource</span><span class=p>(</span><span class=n>locations</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;classpath:aaa.xml&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@SpringBootApplication</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>PropertyApplication</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>main</span><span class=p>(</span><span class=n>String</span><span class=o>[]</span><span class=w> </span><span class=n>args</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>SpringApplication</span><span class=p>.</span><span class=na>run</span><span class=p>(</span><span class=n>PropertyApplication</span><span class=p>.</span><span class=na>class</span><span class=p>,</span><span class=w> </span><span class=n>args</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h3 id=异常处理相关注解>异常处理相关注解<a hidden class=anchor aria-hidden=true href=#异常处理相关注解>#</a></h3><ul><li>@ControllerAdvice 和 @ExceptionHandler</li></ul><p>通常组合使用，用于处理全局异常，示例代码如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@ControllerAdvice</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@Configuration</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@Slf4j</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>GlobalExceptionConfig</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=n>Integer</span><span class=w> </span><span class=n>GLOBAL_ERROR_CODE</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>500</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@ExceptionHandler</span><span class=p>(</span><span class=n>value</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Exception</span><span class=p>.</span><span class=na>class</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@ResponseBody</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>exceptionHandler</span><span class=p>(</span><span class=n>HttpServletRequest</span><span class=w> </span><span class=n>request</span><span class=p>,</span><span class=w> </span><span class=n>HttpServletResponse</span><span class=w> </span><span class=n>response</span><span class=p>,</span><span class=w> </span><span class=n>Exception</span><span class=w> </span><span class=n>e</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>Exception</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>log</span><span class=p>.</span><span class=na>error</span><span class=p>(</span><span class=s>&#34;【统一异常处理器】&#34;</span><span class=p>,</span><span class=w> </span><span class=n>e</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>ResultMsg</span><span class=o>&lt;</span><span class=n>Object</span><span class=o>&gt;</span><span class=w> </span><span class=n>resultMsg</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ResultMsg</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>resultMsg</span><span class=p>.</span><span class=na>setCode</span><span class=p>(</span><span class=n>GLOBAL_ERROR_CODE</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>e</span><span class=w> </span><span class=k>instanceof</span><span class=w> </span><span class=n>CommonException</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>           </span><span class=n>CommonException</span><span class=w> </span><span class=n>ex</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=n>CommonException</span><span class=p>)</span><span class=w> </span><span class=n>e</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>           </span><span class=k>if</span><span class=p>(</span><span class=n>ex</span><span class=p>.</span><span class=na>getErrCode</span><span class=p>()</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=n>0</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>resultMsg</span><span class=p>.</span><span class=na>setCode</span><span class=p>(</span><span class=n>ex</span><span class=p>.</span><span class=na>getErrCode</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>resultMsg</span><span class=p>.</span><span class=na>setMsg</span><span class=p>(</span><span class=n>ex</span><span class=p>.</span><span class=na>getErrMsg</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>resultMsg</span><span class=p>.</span><span class=na>setMsg</span><span class=p>(</span><span class=n>CommonErrorMsg</span><span class=p>.</span><span class=na>SYSTEM_ERROR</span><span class=p>.</span><span class=na>getMessage</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>WebUtil</span><span class=p>.</span><span class=na>buildPrintWriter</span><span class=p>(</span><span class=n>response</span><span class=p>,</span><span class=w> </span><span class=n>resultMsg</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h3 id=测试相关注解>测试相关注解<a hidden class=anchor aria-hidden=true href=#测试相关注解>#</a></h3><ul><li>@ActiveProfiles</li></ul><p>一般作用于测试类上， 用于声明生效的 <code>Spring</code> 配置文件，比如指定<code>application-dev.properties</code>配置文件。</p><ul><li>@RunWith 和 @SpringBootTest</li></ul><p>一般作用于测试类上， 用于单元测试用，示例如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@ActiveProfiles</span><span class=p>(</span><span class=s>&#34;dev&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@RunWith</span><span class=p>(</span><span class=n>SpringRunner</span><span class=p>.</span><span class=na>class</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@SpringBootTest</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>TestJunit</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Test</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>executeTask</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>//测试...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://lesanouo.github.io/blog/tags/springboot/>SpringBoot</a></li></ul><nav class=paginav><a class=prev href=https://lesanouo.github.io/blog/posts/operation/springboot+redis%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E9%99%90%E6%B5%81/><span class=title>«</span><br><span>SpringBoot+Redis实现接口限流</span>
</a><a class=next href=https://lesanouo.github.io/blog/posts/operation/springboot%E4%BC%98%E5%8C%96controller%E5%B1%82%E4%BB%A3%E7%A0%81/><span class=title>»</span><br><span>SpringBoot优化Controller层代码</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://lesanouo.github.io/blog/>Lesan's Blog</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>