[{"content":"Vue官方构建工具 npm init vue@latest 用ref()定义响应式变量 const count = ref(0) count.value++ 计算属性 计算属性值会基于其响应式依赖被缓存、不要在计算函数中做异步请求或者更改 DOM、避免直接修改计算属性值\nconst publishedBooksMessage = computed(() =\u0026gt; { return author.books.length \u0026gt; 0 ? \u0026#39;Yes\u0026#39; : \u0026#39;No\u0026#39; }) // {{ publishedBooksMessage }} Class 与 Style 绑定 Class绑定：\u0026lt;MyComponent :class=\u0026quot;{ active: isActive }\u0026quot; /\u0026gt;\nStyle绑定：\u0026lt;div :style=\u0026quot;{ color: activeColor, fontSize: fontSize + 'px' }\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\n侦听器 watch 的第一个参数可以是不同形式的“数据源”：它可以是一个 ref (包括计算属性)、一个响应式对象、一个 getter 函数、或多个数据源组成的数组：\nconst x = ref(0) const y = ref(0) // 单个 ref watch(x, (newX) =\u0026gt; { console.log(`x is ${newX}`) }) // getter 函数(当需要侦听响应式对象的属性时，需要使用getter函数：()=\u0026gt;obj.count) watch( () =\u0026gt; x.value + y.value, (sum) =\u0026gt; { console.log(`sum of x + y is: ${sum}`) } ) // 多个来源组成的数组 watch([x, () =\u0026gt; y.value], ([newX, newY]) =\u0026gt; { console.log(`x is ${newX} and y is ${newY}`) }) watchEffect()： watchEffect() 会立即执行一遍回调函数，如果这时函数产生了副作用，Vue 会自动追踪副作用的依赖关系，自动分析出响应源\nwatchEffect(async () =\u0026gt; { const response = await fetch(url.value) data.value = await response.json() }) Props const props = defineProps({ // 基础类型检查 // （给出 `null` 和 `undefined` 值则会跳过任何类型检查） propA: Number, // 多种可能的类型 propB: [String, Number], // 必传，且为 String 类型 propC: { type: String, required: true }, // Number 类型的默认值 propD: { type: Number, default: 100 }, // 对象类型的默认值 propE: { type: Object, // 对象或数组的默认值 // 必须从一个工厂函数返回。 // 该函数接收组件所接收到的原始 prop 作为参数。 default(rawProps) { return { message: \u0026#39;hello\u0026#39; } } }, // 自定义类型校验函数 propF: { validator(value) { // The value must match one of these strings return [\u0026#39;success\u0026#39;, \u0026#39;warning\u0026#39;, \u0026#39;danger\u0026#39;].includes(value) } }, // 函数类型的默认值 propG: { type: Function, // 不像对象或数组的默认，这不是一个工厂函数。这会是一个用来作为默认值的函数 default() { return \u0026#39;Default function\u0026#39; } } }) console.log(props.foo) 事件 const emit = defineEmits([\u0026#39;inFocus\u0026#39;, \u0026#39;submit\u0026#39;]) function buttonClick() { emit(\u0026#39;submit\u0026#39;) } 插槽 // 使用组件 \u0026lt;FancyList :api-url=\u0026#34;url\u0026#34; :per-page=\u0026#34;10\u0026#34;\u0026gt; \u0026lt;template #item=\u0026#34;{ body, username, likes }\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{{ body }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;by {{ username }} | {{ likes }} likes\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/FancyList\u0026gt; // 组件定义 \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;item in items\u0026#34;\u0026gt; \u0026lt;slot name=\u0026#34;item\u0026#34; v-bind=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; ","permalink":"https://lesanouo.github.io/blog/posts/snippet/vue3/","summary":"\u003ch2 id=\"vue官方构建工具-npm-init-vuelatest\"\u003eVue官方构建工具 \u003ccode\u003enpm init vue@latest\u003c/code\u003e\u003c/h2\u003e\n\u003ch2 id=\"用ref定义响应式变量\"\u003e用ref()定义响应式变量\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kr\"\u003econst\u003c/span\u003e \u003cspan class=\"nx\"\u003ecount\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003eref\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nx\"\u003ecount\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003evalue\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"计算属性\"\u003e计算属性\u003c/h2\u003e\n\u003cp\u003e计算属性值会基于其响应式依赖被缓存、不要在计算函数中做异步请求或者更改 DOM、避免直接修改计算属性值\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kr\"\u003econst\u003c/span\u003e \u003cspan class=\"nx\"\u003epublishedBooksMessage\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003ecomputed\u003c/span\u003e\u003cspan class=\"p\"\u003e(()\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"nx\"\u003eauthor\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003ebooks\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003elength\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e \u003cspan class=\"o\"\u003e?\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;Yes\u0026#39;\u003c/span\u003e \u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;No\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e})\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// {{ publishedBooksMessage }}\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"class-与-style-绑定\"\u003eClass 与 Style 绑定\u003c/h2\u003e\n\u003cp\u003eClass绑定：\u003ccode\u003e\u0026lt;MyComponent :class=\u0026quot;{ active: isActive }\u0026quot; /\u0026gt;\u003c/code\u003e\u003c/p\u003e","title":"Vue3 代码片段"},{"content":"修改.gitignore立即生效 git rm -r –cached . git add . git commit -m \u0026#34;update .gitignore\u0026#34; ","permalink":"https://lesanouo.github.io/blog/posts/snippet/git/","summary":"\u003ch2 id=\"修改gitignore立即生效\"\u003e修改.gitignore立即生效\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit rm -r –cached .\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit add .\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit commit -m \u003cspan class=\"s2\"\u003e\u0026#34;update .gitignore\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"Git 代码片段"},{"content":"Cannot read properties of null (reading ‘pickAlgorithm‘) npm cache clear --force ","permalink":"https://lesanouo.github.io/blog/posts/snippet/npm/","summary":"\u003ch2 id=\"cannot-read-properties-of-null-reading-pickalgorithm\"\u003eCannot read properties of null (reading ‘pickAlgorithm‘)\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003enpm cache clear --force\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"NPM 代码片段"},{"content":"从数组中删除重复项 const numbers = [1, 1, 20, 3, 3, 3, 9, 9]; const uniqueNumbers = [...new Set(numbers)]; // -\u0026gt; [1, 20, 3, 9] 在 JavaScript 中，Set 是一个集合，它允许你仅存储唯一值。这意味着删除任何重复的值\n展开运算符\u0026hellip;将任何可迭代对象转换为数组\n较短的 If-Else 的空合并 let maybeSomething; // LONG FORM if(maybeSomething){ console.log(maybeSomething) } else { console.log(\u0026#34;Nothing found\u0026#34;) } // SHORTHAND console.log(maybeSomething ?? \u0026#34;Nothing found\u0026#34;) nullish合并操作 ??，如果没有定义左侧返回右侧。如果是，则返回左侧\n防止崩溃的可选链 const student = { name: \u0026#34;Matt\u0026#34;, age: 27, address: { state: \u0026#34;New York\u0026#34; }, }; // LONG FORM console.log(student \u0026amp;\u0026amp; student.address \u0026amp;\u0026amp; student.address.ZIPCode); // Doesn\u0026#39;t exist - Returns undefined // SHORTHAND console.log(student?.address?.ZIPCode); // Doesn\u0026#39;t exist - Returns undefined 在未定义属性时使用可选链运算符，undefined将返回而不是错误。这可以防止你的代码崩溃\n在没有第三个变量的情况下交换两个变量 let x = 1; let y = 2; // LONGER FORM let temp = x; x = y; y = temp; // SHORTHAND [x, y] = [y, x]; 在 JavaScript 中，你可以使用解构从数组中拆分值\n将任何值转换为布尔值 !!true // true !!2 // true !![] // true !!\u0026#34;Test\u0026#34; // true !!false // false !!0 // false !!\u0026#34;\u0026#34; // false 在 JavaScript 中，你可以使用 !! 在 JS 中将任何内容转换为布尔值\n扩展运算符 const nums1 = [1, 2, 3]; const nums2 = [4, 5, 6]; // LONG FORM let newArray = nums1.concat(nums2); // SHORTHAND newArray = [...nums1, ...nums2]; 使用扩展运算符组合两个数组\nlet numbers = [1, 2, 3]; // LONGER FORM numbers.push(4); numbers.push(5); // SHORTHAND numbers = [...numbers, 4, 5]; 也可以使用此语法代替将值推送到数组\n传播解构 const student = { name: \u0026#34;Matt\u0026#34;, age: 23, city: \u0026#34;Helsinki\u0026#34;, state: \u0026#34;Finland\u0026#34;, }; // LONGER FORM const name = student.name; const age = student.age; const address = { city: student.city, state: student.state }; // SHORTHAND const { name, age, ...address } = student; 使用扩展运算符将剩余元素分配给变量\n使用 \u0026amp;\u0026amp; 进行短路评估 var isReady = true; function doSomething(){ console.log(\u0026#34;Yay!\u0026#34;); } // LONGER FORM if(isReady){ doSomething(); } // SHORTHAND isReady \u0026amp;\u0026amp; doSomething(); 不必用if语句检查某事是否为真，你可以使用\u0026amp;\u0026amp;运算符\n类固醇的字符串 const age = 41; const sentence = `I\u0026#39;m ${age} years old`; // result: I\u0026#39;m 41 years old 通过将字符串包装在反引号内并${}用于嵌入值，从而在字符串之间插入变量\n从数组中查找特定元素 const fruits = [ { type: \u0026#34;Banana\u0026#34;, color: \u0026#34;Yellow\u0026#34; }, { type: \u0026#34;Apple\u0026#34;, color: \u0026#34;Green\u0026#34; } ]; // LONGER FORM let yellowFruit; for (let i = 0; i \u0026lt; fruits.length; ++i) { if (fruits[i].color === \u0026#34;Yellow\u0026#34;) { yellowFruit = fruits[i]; } } // SHORTHAND yellowFruit = fruits.find((fruit) =\u0026gt; fruit.color === \u0026#34;Yellow\u0026#34;); 使用find()方法查找匹配特定条件的元素\n对象属性赋值 const name = \u0026#34;Luis\u0026#34;, city = \u0026#34;Paris\u0026#34;, age = 43, favoriteFood = \u0026#34;Spaghetti\u0026#34;; // LONGER FORM const person = { name: name, city: city, age: age, favoriteFood: favoriteFood }; // SHORTHAND const person = { name, city, age, favoriteFood }; 你是否希望对象键与值具有相同的名称？你可以省略对象文字来执行此操作\n压缩 For 循环 const numbers = [1, 2, 3, 4, 5]; // LONGER FORM for(let i = 0; i \u0026lt; numbers.length; i++){ console.log(numbers[i]); } // SHORTHAND numbers.forEach(number =\u0026gt; console.log(number)); 使用内置forEach()方法通过一行代码循环遍历数组\n默认功能参数 // LONG FORM function pickUp(fruit) { if(fruit === undefined){ console.log(\u0026#34;I picked up a Banana\u0026#34;); } else { console.log(`I picked up a ${fruit}`); } } // SHORTHAND function pickUp(fruit = \u0026#34;Banana\u0026#34;) { console.log(`I picked up a ${fruit}`) } pickUp(\u0026#34;Mango\u0026#34;); // -\u0026gt; I picked up a Mango pickUp(); // -\u0026gt; I picked up a Banana 可以为函数参数提供默认值\n将对象的值收集到数组中 const info = { name: \u0026#34;Matt\u0026#34;, country: \u0026#34;Finland\u0026#34;, age: 35 }; // LONGER FORM let data = []; for (let key in info) { data.push(info[key]); } // SHORTHAND const data = Object.values(info); Object.values()将对象的所有值收集到一个新数组中\n检查一个项目是否存在于数组中 let numbers = [1, 2, 3]; // LONGER FORM const hasNumber1 = numbers.indexOf(1) \u0026gt; -1 // -\u0026gt; True // SHORTHAND/CLEANER APPROACH const hasNumber1 = numbers.includes(1) // -\u0026gt; True 可以使用 includes() 方法，而不是使用 indexOf() 方法来检查元素是否在数组中\n压缩多个条件 const num = 1; // LONGER FORM if(num == 1 || num == 2 || num == 3){ console.log(\u0026#34;Yay\u0026#34;); } // SHORTHAND if([1,2,3].includes(num)){ console.log(\u0026#34;Yay\u0026#34;); } 避免使用长|| 检查多个条件链，你可以使用你刚刚在上一个技巧中学到的东西——即，使用 includes() 方法\n指数运算符 // LONGER FORM Math.pow(4,2); // 16 Math.pow(2,3); // 8 // SHORTHAND 4**2 // 16 2**3 // 8 Math.floor() 简写 // LONG FORM Math.floor(5.25) // -\u0026gt; 5.0 // SHORTHAND ~~5.25 // -\u0026gt; 5.0 用一行代码分配多个值 let num1, num2; // LONGER FORM num1 = 10; num2 = 100; // SHORTHAND [num1, num2] = [10, 100]; student = { name: \u0026#34;Matt\u0026#34;, age: 29, }; // LONGER FORM let name = student.name; let age = student.age; // SHORTHAND let { name, age } = student; 从url获取参数并转为对象 const getParameters = URL =\u0026gt; JSON.parse(`{\u0026#34;${decodeURI(URL.split(\u0026#34;?\u0026#34;)[1]).replace(/\u0026#34;/g, \u0026#39;\\\\\u0026#34;\u0026#39;).replace(/\u0026amp;/g, \u0026#39;\u0026#34;,\u0026#34;\u0026#39;).replace(/=/g, \u0026#39;\u0026#34;:\u0026#34;\u0026#39;)}\u0026#34;}` ) getParameters(\u0026#34;https://www.google.com.hk/search?q=js+md\u0026amp;newwindow=1\u0026#34;); // {q: \u0026#39;js+md\u0026#39;, newwindow: \u0026#39;1\u0026#39;} 检查对象是否为空 const isEmpty = obj =\u0026gt; Reflect.ownKeys(obj).length === 0 \u0026amp;\u0026amp; obj.constructor === Object; isEmpty({}) // true isEmpty({a:\u0026#34;not empty\u0026#34;}) //false 反转字符串 const reverse = str =\u0026gt; str.split(\u0026#39;\u0026#39;).reverse().join(\u0026#39;\u0026#39;); reverse(\u0026#39;this is reverse\u0026#39;); // esrever si siht 生成随机十六进制 const randomHexColor = () =\u0026gt; `#${Math.floor(Math.random() * 0xffffff).toString(16).padEnd(6, \u0026#34;0\u0026#34;)}` console.log(randomHexColor()); // #a2ce5b 检查当前选项卡是否在后台 const isTabActive = () =\u0026gt; !document.hidden; isTabActive() // true|false 检测元素是否处于焦点 const elementIsInFocus = (el) =\u0026gt; (el === document.activeElement); elementIsInFocus(anyElement) // 元素处于焦点返回true，反之返回false 检查设备类型 const judgeDeviceType = () =\u0026gt; /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|OperaMini/i.test(navigator.userAgent) ? \u0026#39;Mobile\u0026#39; : \u0026#39;PC\u0026#39;; judgeDeviceType() // PC | Mobile 文字复制到剪贴板 const copyText = async (text) =\u0026gt; await navigator.clipboard.writeText(text) copyText(\u0026#39;单行代码 前端世界\u0026#39;) 获取选定的文本 const getSelectedText = () =\u0026gt; window.getSelection().toString(); getSelectedText(); 查询某天是否为工作日 const isWeekday = (date) =\u0026gt; date.getDay() % 6 !== 0; isWeekday(new Date(2022, 03, 11)) 转换华氏/摄氏 // 华氏温度转换为摄氏温度 const fahrenheitToCelsius = (fahrenheit) =\u0026gt; (fahrenheit - 32) * 5/9; fahrenheitToCelsius(50); // 10 // 摄氏温度转华氏温度 const celsiusToFahrenheit = (celsius) =\u0026gt; celsius * 9/5 + 32; celsiusToFahrenheit(100) // 212 两日期之间相差的天数 const dayDiff = (date1, date2) =\u0026gt; Math.ceil(Math.abs(date1.getTime() - date2.getTime()) / 86400000); dayDiff(new Date(\u0026#34;2021-10-21\u0026#34;), new Date(\u0026#34;2022-02-12\u0026#34;)) // Result: 114 将 RGB 转换为十六进制 const rgbToHex = (r, g, b) =\u0026gt; \u0026#34;#\u0026#34; + ((1 \u0026lt;\u0026lt; 24) + (r \u0026lt;\u0026lt; 16) + (g \u0026lt;\u0026lt; 8) + b).toString(16).slice(1); rgbToHex(255, 255, 255); // #ffffff 计算数组平均值 const average = (arr) =\u0026gt; arr.reduce((a, b) =\u0026gt; a + b) / arr.length; average([1,9,18,36]) //16 ","permalink":"https://lesanouo.github.io/blog/posts/snippet/js/","summary":"\u003ch2 id=\"从数组中删除重复项\"\u003e从数组中删除重复项\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kr\"\u003econst\u003c/span\u003e \u003cspan class=\"nx\"\u003enumbers\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e20\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e3\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e3\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e3\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e9\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e9\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kr\"\u003econst\u003c/span\u003e \u003cspan class=\"nx\"\u003euniqueNumbers\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e[...\u003c/span\u003e\u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"nx\"\u003eSet\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003enumbers\u003c/span\u003e\u003cspan class=\"p\"\u003e)];\u003c/span\u003e \u003cspan class=\"c1\"\u003e// -\u0026gt; [1, 20, 3, 9]\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在 JavaScript 中，Set 是一个集合，它允许你仅存储唯一值。这意味着删除任何重复的值\u003c/p\u003e\n\u003cp\u003e展开运算符\u0026hellip;将任何可迭代对象转换为数组\u003c/p\u003e\n\u003ch2 id=\"较短的-if-else-的空合并\"\u003e较短的 If-Else 的空合并\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003elet\u003c/span\u003e \u003cspan class=\"nx\"\u003emaybeSomething\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// LONG FORM\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003emaybeSomething\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"nx\"\u003econsole\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003elog\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003emaybeSomething\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"nx\"\u003econsole\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003elog\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;Nothing found\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// SHORTHAND\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"nx\"\u003econsole\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003elog\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003emaybeSomething\u003c/span\u003e \u003cspan class=\"o\"\u003e??\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;Nothing found\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003enullish合并操作 ??，如果没有定义左侧返回右侧。如果是，则返回左侧\u003c/p\u003e","title":"JavaScript 代码片段"},{"content":"Maven添加profiles profiles 标签 \u0026lt;!-- 环境控制 --\u0026gt; \u0026lt;profiles\u0026gt; \u0026lt;!-- 开发 --\u0026gt; \u0026lt;profile\u0026gt; \u0026lt;id\u0026gt;dev\u0026lt;/id\u0026gt; \u0026lt;activation\u0026gt; \u0026lt;!--默认激活配置--\u0026gt; \u0026lt;activeByDefault\u0026gt;true\u0026lt;/activeByDefault\u0026gt; \u0026lt;/activation\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;!--当前环境--\u0026gt; \u0026lt;profile.name\u0026gt;dev\u0026lt;/profile.name\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;/profile\u0026gt; \u0026lt;!-- 生产 --\u0026gt; \u0026lt;profile\u0026gt; \u0026lt;id\u0026gt;prod\u0026lt;/id\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;!--当前环境--\u0026gt; \u0026lt;profile.name\u0026gt;prod\u0026lt;/profile.name\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;/profile\u0026gt; \u0026lt;/profiles\u0026gt; 打包添加resources \u0026lt;!-- 打包 --\u0026gt; \u0026lt;build\u0026gt; ...... \u0026lt;resources\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;src/main/resources\u0026lt;/directory\u0026gt; \u0026lt;filtering\u0026gt;true\u0026lt;/filtering\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;src/main/java\u0026lt;/directory\u0026gt; \u0026lt;includes\u0026gt; \u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt; \u0026lt;include\u0026gt;**/*.json\u0026lt;/include\u0026gt; \u0026lt;include\u0026gt;**/*.ftl\u0026lt;/include\u0026gt; \u0026lt;/includes\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;/resources\u0026gt; \u0026lt;/build\u0026gt; 创建对应文件 分别创建 application.yml 、 application-dev.yml 、 application-prod.yml 文件，dev、prod中写入需要需要区分环境的配置\napplication.yml选中对应环境配置文件 spring: profiles: active: \u0026#39;@profile.name@\u0026#39; ","permalink":"https://lesanouo.github.io/blog/posts/snippet/springboot/","summary":"\u003ch2 id=\"maven添加profiles\"\u003eMaven添加profiles\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eprofiles 标签\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-xml\" data-lang=\"xml\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c\"\u003e\u0026lt;!-- 环境控制 --\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nt\"\u003e\u0026lt;profiles\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"c\"\u003e\u0026lt;!-- 开发 --\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"nt\"\u003e\u0026lt;profile\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nt\"\u003e\u0026lt;id\u0026gt;\u003c/span\u003edev\u003cspan class=\"nt\"\u003e\u0026lt;/id\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nt\"\u003e\u0026lt;activation\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"c\"\u003e\u0026lt;!--默认激活配置--\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"nt\"\u003e\u0026lt;activeByDefault\u0026gt;\u003c/span\u003etrue\u003cspan class=\"nt\"\u003e\u0026lt;/activeByDefault\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nt\"\u003e\u0026lt;/activation\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nt\"\u003e\u0026lt;properties\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"c\"\u003e\u0026lt;!--当前环境--\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"nt\"\u003e\u0026lt;profile.name\u0026gt;\u003c/span\u003edev\u003cspan class=\"nt\"\u003e\u0026lt;/profile.name\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nt\"\u003e\u0026lt;/properties\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"nt\"\u003e\u0026lt;/profile\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"c\"\u003e\u0026lt;!-- 生产 --\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"nt\"\u003e\u0026lt;profile\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nt\"\u003e\u0026lt;id\u0026gt;\u003c/span\u003eprod\u003cspan class=\"nt\"\u003e\u0026lt;/id\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nt\"\u003e\u0026lt;properties\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"c\"\u003e\u0026lt;!--当前环境--\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"nt\"\u003e\u0026lt;profile.name\u0026gt;\u003c/span\u003eprod\u003cspan class=\"nt\"\u003e\u0026lt;/profile.name\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nt\"\u003e\u0026lt;/properties\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"nt\"\u003e\u0026lt;/profile\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nt\"\u003e\u0026lt;/profiles\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e打包添加resources\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-xml\" data-lang=\"xml\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c\"\u003e\u0026lt;!-- 打包 --\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nt\"\u003e\u0026lt;build\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        ......\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"nt\"\u003e\u0026lt;resources\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nt\"\u003e\u0026lt;resource\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"nt\"\u003e\u0026lt;directory\u0026gt;\u003c/span\u003esrc/main/resources\u003cspan class=\"nt\"\u003e\u0026lt;/directory\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"nt\"\u003e\u0026lt;filtering\u0026gt;\u003c/span\u003etrue\u003cspan class=\"nt\"\u003e\u0026lt;/filtering\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nt\"\u003e\u0026lt;/resource\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nt\"\u003e\u0026lt;resource\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"nt\"\u003e\u0026lt;directory\u0026gt;\u003c/span\u003esrc/main/java\u003cspan class=\"nt\"\u003e\u0026lt;/directory\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"nt\"\u003e\u0026lt;includes\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                    \u003cspan class=\"nt\"\u003e\u0026lt;include\u0026gt;\u003c/span\u003e**/*.xml\u003cspan class=\"nt\"\u003e\u0026lt;/include\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                    \u003cspan class=\"nt\"\u003e\u0026lt;include\u0026gt;\u003c/span\u003e**/*.json\u003cspan class=\"nt\"\u003e\u0026lt;/include\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                    \u003cspan class=\"nt\"\u003e\u0026lt;include\u0026gt;\u003c/span\u003e**/*.ftl\u003cspan class=\"nt\"\u003e\u0026lt;/include\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"nt\"\u003e\u0026lt;/includes\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nt\"\u003e\u0026lt;/resource\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"nt\"\u003e\u0026lt;/resources\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nt\"\u003e\u0026lt;/build\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e创建对应文件\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e分别创建 \u003ccode\u003eapplication.yml\u003c/code\u003e 、 \u003ccode\u003eapplication-dev.yml\u003c/code\u003e 、 \u003ccode\u003eapplication-prod.yml\u003c/code\u003e 文件，dev、prod中写入需要需要区分环境的配置\u003c/p\u003e","title":"SpringBoot 代码片段"},{"content":"单线程与多线程可以看作是：\n单线程为在一个单向行驶的道路上，每辆汽车都遵守交通规则 多线程为多条车道，这样在同一时间内，通行的车辆数远远大于单车道 然而扩充了车道后问题就没那么简单了，车道一旦多起来加塞的场景就会越来越多，出现碰撞后也会影响整条马路的通行效率，这样多车道就不一定比单车道更快了\n为了解决汽车频繁变道加塞的问题，可以通过在车道间增加护栏来规范管理\n在程序中处理多线程带来的问题归纳起来就三类：\n线程安全问题 活跃性问题 性能问题 线程安全问题 原子性 有一个非常经典的例子，比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元，两个操作都成功才意味着一次转账最终成功\n试想一下，如果这两个操作不具备原子性，从A的账户扣减了1000元之后，操作突然终止了，账户B没有增加1000元，那问题就大了\n银行转账这个例子有两个步骤，出现了意外后导致转账失败，说明没有原子性\n原子性：即一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行\n原子操作：即不会被线程调度机制打断的操作，没有上下文切换\n在并发编程中很多操作都不是原子操作，出个小题目：\ni = 0; // 操作1 i++; // 操作2 i = j; // 操作3 i = i + 1; // 操作4 上面这四个操作中有哪些是原子操作，哪些不是？不熟悉的人可能认为这些都是原子操作，其实只有操作1是原子操作\n操作1：对基本数据类型变量的赋值是原子操作 操作2：包含三个操作，读取i的值，将i加1，将值赋给i 操作3：读取j的值，将j的值赋给i 操作4：包含三个操作，读取i的值，将i加1，将值赋给i 在单线程环境下上述四个操作都不会出现问题，但是在多线程环境下，如果不通过加锁操作，往往可能得到意料之外的值\n在Java语言中通过可以使用synchronize或者lock来保证原子性\n可见性 可见性：指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值\nclass Test { int i = 50; int j = 0; public void update() { // 线程1执行 i = 100; } public int get() { // 线程2执行 j = i; return j; } } 线程1执行update方法将 i 赋值为100，一般情况下线程1会在自己的工作内存中完成赋值操作，却没有及时将新值刷新到主内存中\n这个时候线程2执行get方法，首先会从主内存中读取i的值，然后加载到自己的工作内存中，这个时候读取到i的值是50，再将50赋值给j，最后返回j的值就是50了。原本期望返回100，结果返回50，这就是可见性问题，线程1对变量i进行了修改，线程2没有立即看到i的新值\n如上图每个线程都有属于自己的工作内存，工作内存和主内存间需要通过store和load等进行交互\n为了解决多线程可见性问题，Java语言提供了 volatile 这个关键字。当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。而普通共享变量不能保证可见性，因为变量被修改后什么时候刷回到主存是不确定的，另外一个线程读的可能就是旧值\n当然Java的锁机制如synchronize和lock也是可以保证可见性的，加锁可以保证在同一时刻只有一个线程在执行同步代码块，释放锁之前会将变量刷回至主存，这样也就保证了可见性\n活跃性问题 上面讲到为了解决 可见性问题，我们可以采取加锁方式解决，但是如果加锁使用不当也容易引入其他问题，比如死锁\n活跃性是指某件正确的事情最终会发生，当某个操作无法继续下去的时候，就会发生活跃性问题\n活跃性问题一般有这样几类：死锁，活锁，饥饿 问题\n死锁 死锁是指多个线程因为环形的等待锁的关系而永远的阻塞下去 活锁 死锁是两个线程都在等待对方释放锁导致阻塞。而活锁的意思是线程没有阻塞，还活着呢。\n当多个线程都在运行并且修改各自的状态，而其他线程彼此依赖这个状态，导致任何一个线程都无法继续执行，只能重复着自身的动作和修改自身的状态，这种场景就是发生了活锁\n如果大家还有疑惑，那我再举一个生活中的例子，大家平时在走路的时候，迎面走来一个人，两个人互相让路，但是又同时走到了一个方向，如果一直这样重复着避让，这俩人就是发生了活锁\n饥饿 如果一个线程无其他异常却迟迟不能继续运行，那基本是处于饥饿状态了\n常见有几种场景:\n高优先级的线程一直在运行消耗CPU，所有的低优先级线程一直处于等待 一些线程被永久堵塞在一个等待进入同步块的状态，而其他线程总是能在它之前持续地对该同步块进行访问 有一个非常经典的饥饿问题就是哲学家用餐问题，如下图所示，有五个哲学家在用餐，每个人必须要同时拿两把叉子才可以开始就餐，如果哲学家1和哲学家3同时开始就餐，那哲学家2、4、5就得饿肚子等待了 性能问题 前面讲到了线程安全和死锁、活锁这些问题会影响多线程执行过程，如果这些都没有发生，多线程并发一定比单线程串行执行快吗，答案是不一定，因为多线程有 创建线程和 线程上下文切换的开销\n创建线程是直接向系统申请资源的，对操作系统来说创建一个线程的代价是十分昂贵的，需要给它分配内存、列入调度等\n线程创建完之后，还会遇到 线程上下文切换 CPU是很宝贵的资源，速度也非常快，为了保证雨露均沾，通常会给不同的线程分配 时间片，当CPU从执行一个线程切换到执行另一个线程时，CPU需要保存当前线程的本地数据、程序指针等状态，并加载下一个要执行的线程的本地数据、程序指针等，这个开关被称为上下文切换\n一般减少上下文切换的方法有：无锁并发编程、CAS 算法、使用协程等\n总结 多线程用好了可以让程序的效率成倍提升，用不好可能比单线程还要慢 ","permalink":"https://lesanouo.github.io/blog/posts/knowledge/multi-thread/","summary":"\u003cp\u003e单线程与多线程可以看作是：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e单线程为在一个单向行驶的道路上，每辆汽车都遵守交通规则\u003c/li\u003e\n\u003cli\u003e多线程为多条车道，这样在同一时间内，通行的车辆数远远大于单车道\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e然而扩充了车道后问题就没那么简单了，车道一旦多起来\u003cstrong\u003e加塞\u003c/strong\u003e的场景就会越来越多，出现碰撞后也会影响整条马路的通行效率，这样多车道就不一定比单车道更快了\u003c/p\u003e","title":"多线程下的琐事"},{"content":"如电脑设置了网络代理，会导致一些软件工具不能正常工作。查找了网上许多解决方案，总结如下。\nGit 设置全局Config代理 git config --global http.proxy http://server:port git config --global https.proxy http://server:port git config --global http.https://github.com.proxy http://server:port git config --global https.https://github.com.proxy http://server:port 去除代理设置 git config --global --unset http.proxy git config --global --unset https.proxy git config --global --unset http.https://github.com.proxy git config --global --unset https.https://github.com.proxy 当我使用这种方式时没有效果\n使用clone时配置代理 git clone -c http.proxy=\u0026#34;server:port\u0026#34; https://github.com/LesanOuO/lesan-homepage.git NPM 全局设置代理 npm config set proxy http://server:port\n配置https代理（设置了proxy就不需要设置https-proxy） npm config set https-proxy http://server:port\n如果需要代理用户名和密码 npm config set proxy http://username:password@server:port npm confit set https-proxy http://username:password@server:port 取消代理 npm config delete proxy npm config delete https-proxy npm config set proxy null npm config set https-proxy null Maven 需要在 settings.xml中配置 proxies节点\n... \u0026lt;proxies\u0026gt; \u0026lt;proxy\u0026gt; \u0026lt;id\u0026gt;optional\u0026lt;/id\u0026gt; \u0026lt;active\u0026gt;true\u0026lt;/active\u0026gt; \u0026lt;protocol\u0026gt;http\u0026lt;/protocol\u0026gt; \u0026lt;host\u0026gt;127.0.0.1\u0026lt;/host\u0026gt; \u0026lt;port\u0026gt;8888\u0026lt;/port\u0026gt; \u0026lt;/proxy\u0026gt; \u0026lt;/proxies\u0026gt; ... Yum 在文件 /etc/yum.conf 中添加以下设置\nproxy=http://192.168.1.1:8080\rproxy_username=username\rproxy_password=password 也可以通过设置环境变量配置\nexport http_proxy=\u0026#34;http://username:password@192.168.1.1:8080\u0026#34;\rexport https_proxy=\u0026#34;http://username:password@192.168.1.1:8080\u0026#34; 清除环境变量取消代理配置 unset http_proxy\n","permalink":"https://lesanouo.github.io/blog/posts/share/proxy-things/","summary":"\u003cp\u003e如电脑设置了网络代理，会导致一些软件工具不能正常工作。查找了网上许多解决方案，总结如下。\u003c/p\u003e\n\u003ch2 id=\"git\"\u003eGit\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e设置全局Config代理\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit config --global http.proxy http://server:port\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit config --global https.proxy http://server:port\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit config --global http.https://github.com.proxy http://server:port\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit config --global https.https://github.com.proxy http://server:port\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e去除代理设置\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit config --global --unset http.proxy\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit config --global --unset https.proxy\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit config --global --unset http.https://github.com.proxy\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit config --global --unset https.https://github.com.proxy\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cblockquote\u003e\n\u003cp\u003e当我使用这种方式时没有效果\u003c/p\u003e","title":"设置网络代理后需要注意"},{"content":"在编写数据库文档时，我们常常需要写表结构文档，这时候就需要一些方法来节约我们写文档的时间。\n我通过网络上的资料，总结了 MySQL 及 SQL Server 的通过SQL语句导出数据库表结构的方法。\nMySQL SELECT COLUMN_NAME 列名, COLUMN_TYPE 数据类型, DATA_TYPE 字段类型, CHARACTER_MAXIMUM_LENGTH 长度, IS_NULLABLE 是否为空, COLUMN_DEFAULT 默认值, COLUMN_COMMENT 备注 FROM INFORMATION_SCHEMA.COLUMNS WHERE table_schema = \u0026#39;数据库名称\u0026#39; -- 数据库名称 AND table_name = \u0026#39;表名\u0026#39; -- 表名 -- 如果不写的话，默认会查询出所有表中的数据，这样可能就分不清到底哪些字段是哪张表中的了，所以还是建议写上要导出的名名称 SQL Server SELECT 表名 = Case When A.colorder=1 Then D.name Else \u0026#39;\u0026#39; End, 表说明 = Case When A.colorder=1 Then isnull(F.value,\u0026#39;\u0026#39;) Else \u0026#39;\u0026#39; End, 字段序号 = A.colorder, 字段名 = A.name, 字段说明 = isnull(G.[value],\u0026#39;\u0026#39;), 标识 = Case When COLUMNPROPERTY( A.id,A.name,\u0026#39;IsIdentity\u0026#39;)=1 Then \u0026#39;√\u0026#39;Else \u0026#39;\u0026#39; End, 主键 = Case When exists(SELECT 1 FROM sysobjects Where xtype=\u0026#39;PK\u0026#39; and parent_obj=A.id and name in ( SELECT name FROM sysindexes WHERE indid in( SELECT indid FROM sysindexkeys WHERE id = A.id AND colid=A.colid))) then \u0026#39;√\u0026#39; else \u0026#39;\u0026#39; end, 类型 = B.name, 占用字节数 = A.Length, 长度 = COLUMNPROPERTY(A.id,A.name,\u0026#39;PRECISION\u0026#39;), 小数位数 = isnull(COLUMNPROPERTY(A.id,A.name,\u0026#39;Scale\u0026#39;),0), 允许空 = Case When A.isnullable=1 Then \u0026#39;√\u0026#39;Else \u0026#39;\u0026#39; End, 默认值 = isnull(E.Text,\u0026#39;\u0026#39;) FROM syscolumns A Left Join systypes B On A.xusertype=B.xusertype Inner Join sysobjects D On A.id=D.id and D.xtype=\u0026#39;U\u0026#39; and D.name\u0026lt;\u0026gt;\u0026#39;dtproperties\u0026#39; Left Join syscomments E on A.cdefault=E.id Left Join sys.extended_properties G on A.id=G.major_id and A.colid=G.minor_id Left Join sys.extended_properties F On D.id=F.major_id and F.minor_id=0 where d.name=\u0026#39;表名\u0026#39; --如果只查询指定表,加上此条件 Order By A.id,A.colorder ","permalink":"https://lesanouo.github.io/blog/posts/share/sql-export-excel/","summary":"\u003cp\u003e在编写数据库文档时，我们常常需要写表结构文档，这时候就需要一些方法来节约我们写文档的时间。\u003c/p\u003e\n\u003cp\u003e我通过网络上的资料，总结了 \u003ccode\u003eMySQL\u003c/code\u003e 及 \u003ccode\u003eSQL Server\u003c/code\u003e 的通过SQL语句导出数据库表结构的方法。\u003c/p\u003e","title":"通过SQL导出数据库表结构"},{"content":"图片文字环绕 .any-shape { width: 300px; float: left; shape-outside: circle(50%); } shape-outside 属性定义了一个可以是非矩形的形状，相邻的内联内容应围绕该形状进行包装。默认情况下，内联内容包围其边距框; shape-outside提供了一种自定义此包装的方法，可以将文本包装在复杂对象周围而不是简单的框中。\n:where() 简化代码 当对多个元素应用相同的样式时，CSS 可能如下：\n.parent div, .parent .title, .parent #article { color: red; } 这样代码看起来可读性不是很好，:where() 伪类这时就派上用场了。:where() 伪类函数接受选择器列表作为它的参数，将会选择所有能被该选择器列表中任何一条规则选中的元素。\n上面的代码使用:where()就可以这么写：\n.parent :where(div, .title, #article) { color: red; } 实现平滑滚动 可以使用CSS的scroll-behavior属性来实现在网页上进行平滑滚动，而无需编写复杂的 JavaScript 或使用插件。可以用于页面锚点之间的滚动或者返回顶部等功能。\nhtml { scroll-behavior: smooth; } 当用户手动导航或者 CSSOM scrolling API 触发滚动操作时，CSS 属性 scroll-behavior 为一个滚动框指定滚动行为，其他任何的滚动，例如那些由于用户行为而产生的滚动，不受这个属性的影响。在根元素中指定这个属性时，它反而适用于视窗。当该属性的值为smooth时就可以实现页面的平滑滚动。\n背景混合模式 在CSS中可以使用 background-blend-mode 来实现元素背景的混合：\n.blend-1 { background-image: url(https://duomly.nyc3.digitaloceanspaces.com/articles/coding/alps-lake.jpg); width: 100vw; height: 500px; background-size: cover; } .blend-2 { background-image: url(https://duomly.nyc3.digitaloceanspaces.com/articles/coding/alps-lake.jpg); width: 100vw; height: 500px; background-color: #20126f; background-size: cover; background-blend-mode: overlay; } 上面的图片是单纯的一张图片背景，下面的图片是背景图片和背景颜色混合而成的。background-blend-mode 属性就用于定义了背景层的混合模式（图片与颜色）。支持的背景混合模式：正常|乘法|屏幕|叠加|变暗|变亮|颜色减淡|饱和度|颜色|亮度；\n图像填充文字效果 要想实现图像填充文字效果，可以设置 background-clip: text 以使文字背景作为整个区域的背景，文字之外的区域将被裁掉。配合透明的文字颜色，就可以实现图像填充文字效果了：\nh1 { background-image: url(\u0026#39;./flower.jpg\u0026#39;); background-clip: text; -webkit-background-clip: text; color: transparent; background-color: white; } 注意，在使用此技术时可以指定一个背景颜色来作为后备值，以防图像因为某种原因而无法加载。\n文字描边效果 在 CSS 中可以使用 text-stroke 属性使文本更易读，它会向文本添加轮廓效果。\nh1 { color: #fff; font-size: 80px; -webkit-text-stroke: 2px crimson; text-stroke: 2px crimson; } 注意，text-stroke 属性值中有两部分，第一部分是文字描边的宽度，第二部分是文字描边的颜色。\n将文本设为大写或小写 大写或小写字母可以不必在 HTML中设置。可以在 CSS 中使用text-transform熟悉来强制任何文本为大写或小写。\n/* 大写 */ .upper { text-transform: uppercase; } /* 小写 */ .lower { text-transform: lowercase; } text-transform 属性专门用于控制文本的大小写，当值为uppercase时会将文本转为大写，当值为capitalize时会将文本转化为小写，当值为capitalize时会将每个单词以大写字母开头。\n暂停/播放伪类 使用 :paused 伪类可以为处于暂停状态的媒体元素设置样式，那自然就还有 :playing 伪类，它可以为处于播放状态的媒体元素设置样式。\nvideo:paused { opacity: 0.6; } 需要注意，目前仅 Safari 支持该伪类:paused\n毛玻璃特效 可以使用 CSS 中的 backdrop-filter 属性来实现毛玻璃特效：\n.login { backdrop-filter: blur(5px); } backdrop-filter 属性可以为一个元素后面区域添加图形效果（如模糊或颜色偏移）。因为它适用于元素背后的所有元素，为了看到效果，必须使元素或其背景至少部分透明。\n自定义光标 我们可以通 CSS 中的cursor属性来自定义光标的样式，只需要指定自定义光标的图片路径即可：\nbody{ cursor: url(\u0026#34;path-to-image.png\u0026#34;), auto; } 文本强调效果 可以使用 text-emphasis 属性将强调标记应用于文本元素。可以指定包括表情符号在内的任何字符串作为强调标记。\nh1 { text-emphasis: \u0026#34;⭐️\u0026#34;; } 注意，text-emphasis 是一个简写属性，用于在一个声明中设置 text-emphasis-style 和 text-emphasis-color。强调装饰符的字号是主文字内容字号的一半，例如假设文字是20px，则上方的强调字符的大小是10px。\n更写书写方向 通常我们常见的网页文字是从左向右布局的，在CSS中可以使用 writing-mode 属性来指定文本在网页上的布局方式，即水平或垂直。该属性有多个属性值：\nhorizontal-tb：水平方向自上而下的书写方式。即 left-right-top-bottom vertical-rl：垂直方向自右而左的书写方式。即 top-bottom-right-left vertical-lr：垂直方向内内容从上到下，水平方向从左到右 sideways-rl：内容垂直方向从上到下排列 sideways-lr：内容垂直方向从下到上排列 h1 { writing-mode: sideways-lr; } 悬停缩放效果 .img-container { height: 250px; width: 250px; overflow: hidden; } .img-container img { height: 100%; width: 100%; object-fit: cover; transition: transform 200m ease-in; } img:hover { transform: scale(1.2); } transform 属性应用于元素的2D或3D转换。这个属性允许将元素旋转，缩放，移动，倾斜等。当值为scale就可以实现元素的 2D 缩放转换。\n裁剪各种形状 可以使用 clip-path 属性来创建各种有趣的视觉效果，例如将元素剪裁成自定义形状，如三角形或六边形。\ndiv { height: 150px; width: 150px; background-color: crimson; } 三角形如下：\nclip-path: polygon(50% 0%, 0% 100%, 100% 100%); 六边形如下：\nclip-path: polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%); 可以使用 clip-path 在线工具在制作各种图形：https://bennettfeely.com/clippy/\n检测属性支持 在 CSS 中可以使用 @support 规则来检测对 CSS 特性的支持：\n@supports (accent-color: #74992e) { blockquote { color: crimson; } } 如果支持该属性将运行内容定义的样式。\n可选项样式 在 CSS 中可以使用 :optional 伪类来设置没有 required 属性的表单字段的样式，例如 input、select 和 textarea。\n*:optional{ background-color: green; } 实现首字下沉 我们可以使用::first-letter来实现文本首字母的下沉：\np.texts:first-letter { font-size: 200%; color: #8A2BE2; } :first-letter选择器用来指定元素第一个字母的样式，它仅适用于在块级元素中。效果如下：\n实现正方形 我们可以通过CSS中的纵横比来实现一个正方形，这样只需要设置一个宽度即可：\n.square { background: #8A2BE2; width: 25rem; aspect-ratio: 1/1; } aspect-ratio 媒体属性可以用来测试视口的宽高比。当然上述例子比较简单，来看看MDN中给出的纵横比的示例：\n/* 最小宽高比 */ @media (min-aspect-ratio: 8/5) { div { background: #9af; /* blue */ } } /* 最大宽高比 */ @media (max-aspect-ratio: 3/2) { div { background: #9ff; /* cyan */ } } /* 明确的宽高比, 放在最下部防止同时满足条件时的覆盖*/ @media (aspect-ratio: 1/1) { div { background: #f9a; /* red */ } } 这里通过媒体查询在页面视口不同纵横比时，显示不同的背景颜色。\n","permalink":"https://lesanouo.github.io/blog/posts/snippet/css/","summary":"\u003ch2 id=\"图片文字环绕\"\u003e图片文字环绕\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-css\" data-lang=\"css\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nc\"\u003eany-shape\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"k\"\u003ewidth\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"mi\"\u003e300\u003c/span\u003e\u003cspan class=\"kt\"\u003epx\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"k\"\u003efloat\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"kc\"\u003eleft\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"k\"\u003eshape-outside\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"nb\"\u003ecircle\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e50\u003c/span\u003e\u003cspan class=\"kt\"\u003e%\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003ccode\u003eshape-outside\u003c/code\u003e 属性定义了一个可以是非矩形的形状，相邻的内联内容应围绕该形状进行包装。默认情况下，内联内容包围其边距框; \u003ccode\u003eshape-outside\u003c/code\u003e提供了一种自定义此包装的方法，可以将文本包装在复杂对象周围而不是简单的框中。\u003c/p\u003e","title":"CSS 代码片段"},{"content":"在代码中遇到了网络请求编程时，往往需要异步编程才能给用户带来良好的体验，不会导致程序完全阻塞。 其中的关键在于：\n异步方法：再执行完成前就立刻返回调用方法，在调用方法执行过程中完成任务 async/await 结构主要分为三个部分： 调用方法：该方法调用异步方法，然后在异步方法回调后继续执行后续程序 异步方法：该方法异步执行程序，在被调用后立即返回到调用方法 await 表达式：用于异步等待，指出需要异步执行的任务，且需要等待其完成。一个方法可以包含多个await 什么是异步 启动程序时，系统会在内存中创建一个新的进程。进程是构成运行程序资源的集合。在进程内部，有称为线程的内核对象，它代表的是真正的执行程序。系统会在 Main 方法的第一行语句就开始线程的执行。\n线程：\n默认情况，一个进程只包含一个线程，从程序的开始到执行结束 线程可以派生自其它线程，所以一个进程可以包含不同状态的多个线程，来执行程序的不同部分 一个进程中的多个线程，将共享该进程的资源 系统为处理器执行所规划的单元是线程，而非进程 下面我们来看一个简单的例子\nclass Program { // 创建计时器 private static readonly Stopwatch Watch = new Stopwatch(); private static void Main(string[] args) { // 启动计时器 Watch.Start(); const string url1 = \u0026#34;http://www.cnblogs.com/\u0026#34;; const string url2 = \u0026#34;http://www.cnblogs.com/liqingwen/\u0026#34;; // 两次调用 CountCharactersAsync 方法（异步下载某网站内容，并统计字符的个数） Task\u0026lt;int\u0026gt; t1 = CountCharactersAsync(1, url1); Task\u0026lt;int\u0026gt; t2 = CountCharactersAsync(2, url2); // 三次调用 ExtraOperation 方法（主要是通过拼接字符串达到耗时操作） for (var i = 0; i \u0026lt; 3; i++) { ExtraOperation(i + 1); } // 控制台输出 Console.WriteLine($\u0026#34;{url1} 的字符个数：{t1.Result}\u0026#34;); Console.WriteLine($\u0026#34;{url2} 的字符个数：{t2.Result}\u0026#34;); Console.Read(); } // 统计字符个数 private static async Task\u0026lt;int\u0026gt; CountCharactersAsync(int id, string address) { var wc = new WebClient(); Console.WriteLine($\u0026#34;开始调用 id = {id}：{Watch.ElapsedMilliseconds} ms\u0026#34;); var result = await wc.DownloadStringTaskAsync(address); Console.WriteLine($\u0026#34;调用完成 id = {id}：{Watch.ElapsedMilliseconds} ms\u0026#34;); return result.Length; } // 额外操作 private static void ExtraOperation(int id) { // 这里是通过拼接字符串进行一些相对耗时的操作，如果对字符串拼接有性能要求的话应该使用 StringBuilder var s = \u0026#34;\u0026#34;; for (var i = 0; i \u0026lt; 6000; i++) { s += i; } Console.WriteLine($\u0026#34;id = {id} 的 ExtraOperation 方法完成：{Watch.ElapsedMilliseconds} ms\u0026#34;); } } 同步情况下的调用顺序为： 异步情况下的调用顺序为： 从上面两种情况可以看出异步编程优势，现在我们来分析一下程序的步骤：\n从 Main 方法执行到 CountCharactersAsync(1, url1) 方法时，该方法会立即返回，然后才会调用它内部的方法开始下载内容。该方法返回的是一个 Task\u0026lt;int\u0026gt; 类型的占位符对象，表示计划进行的工作。这个占位符最终会返回 int 类型的值 这样就可以不必等 CountCharactersAsync(1, url1) 方法执行完成就可以继续进行下一步操作。到执行 CountCharactersAsync(2, url2) 方法时，跟 步骤① 一样返回 Task\u0026lt;int\u0026gt; 对象 然后，Main 方法继续执行三次 ExtraOperation 方法，同时两次 CountCharactersAsync 方法依然在持续工作 t1.Result 和 t2.Result 是指从 CountCharactersAsync 方法调用的 Task\u0026lt;int\u0026gt; 对象取结果，如果还没有结果的话，将阻塞，直有结果返回为止 async/await 结构 async/await 结构主要分为三个部分：\n调用方法：该方法调用异步方法，然后在异步方法回调后继续执行后续程序 异步方法：该方法异步执行程序，在被调用后立即返回到调用方法 await 表达式：用于异步等待，指出需要异步执行的任务，且需要等待其完成。一个方法可以包含多个await 示例结构分析如下： await 都做了些什么 为了了解程序 await 时，C#都做了些什么工作，我们就必须了解以下内容\n方法的状态 首先，方法内所有的本地变量的值都会被记住，包括\n方法的参数 在方法的作用域内定义的任何变量 任何其它变量，比如循环中使用到的计数变量 如果你的方法不是static的，则还要包括this变量。只有记住了this，当方法恢复执行(resume)时，才可以使用当前类的成员变量。 上述的这些都会被存储在.NET垃圾回收堆里的一个对象中。因此，当你使用await时，.NET就会创建这样一个对象，虽然它会占用一些资源，但在大多数情况下并不会导致性能问题。\nC#还要记住在方法内部await执行到了哪里——可以通过使用一个数字来表示当前方法中执行到了哪一个await关键字。\n具体如何使用await表达式？这其实没有限制，例如，await可以被用做一个大表达式的一部分，一个表达式也可能包含多个await.\nint myNum = await AlexsMethodAsync(await myTask, await StuffAsync());\n这样就对.NET运行时提出了额外的需求——当await一个表达式时，需要记住表达式剩余部分的状态。在上面的例子中，当程序执行await StuffAsync()时，await myTask的结果就需要被记录下来。.NET IL会将这类子表达式存储在栈上，因此当使用了await关键字时就需要把这个栈存储下来。\n在这之上，当程序执行到第一个await时，当前方法会返回——除非方法是async void，否则这时就会返回一个Task，因此调用者可以通过某种方式等待任务完成。C# 还必须把操作该返回Task的方法存储下来，这样当我们的方法完成后，前面返回的Task才会变为完成的状态，这样程序才会向上返回一层，回到方法的异步链中去继续执行。我们会在第14章探讨这些额外的机制。\n上下文（Context） C#在使用await时会记录各种各样的上下文，目的是当要继续执行方法时能够恢复这个上下文，这样就尽可能地将await的处理过程变得透明。这些上下文中最重要的就是同步上下文（sychronization context），通过它的帮助可以在指定类型的线程上恢复方法的执行。\n异步方法的结构 关键字：方法头使用 async 修饰。 要求：包含 N（N\u0026gt;0） 个 await 表达式（不存在 await 表达式的话 IDE 会发出警告），表示需要异步执行的任务。 返回类型：只能返回 3 种类型（void、Task 和 Task\u0026lt;T\u0026gt;）。Task 和 Task\u0026lt;T\u0026gt; 标识返回的对象会在将来完成工作，表示调用方法和异步方法可以继续执行。 参数：数量不限，但不能使用 out 和 ref 关键字。 命名约定：方法后缀名应以 Async 结尾。 其它：匿名方法和 Lambda 表达式也可以作为异步对象；async 是一个上下文关键字；关键字 async 必须在返回类型前。 本文参考自：\nhttps://www.cnblogs.com/tuyile006/p/12605523.html\nhttps://www.cnblogs.com/tuyile006/p/12605523.html\n","permalink":"https://lesanouo.github.io/blog/posts/knowledge/csharp-async-await/","summary":"\u003cp\u003e在代码中遇到了网络请求编程时，往往需要异步编程才能给用户带来良好的体验，不会导致程序完全阻塞。\n其中的关键在于：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e异步方法：再执行完成前就立刻返回调用方法，在调用方法执行过程中完成任务\u003c/li\u003e\n\u003cli\u003easync/await 结构主要分为三个部分：\n\u003col\u003e\n\u003cli\u003e调用方法：该方法调用异步方法，然后在异步方法回调后继续执行后续程序\u003c/li\u003e\n\u003cli\u003e异步方法：该方法异步执行程序，在被调用后立即返回到调用方法\u003c/li\u003e\n\u003cli\u003eawait 表达式：用于异步等待，指出需要异步执行的任务，且需要等待其完成。一个方法可以包含多个await\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"什么是异步\"\u003e什么是异步\u003c/h2\u003e\n\u003cp\u003e启动程序时，系统会在内存中创建一个新的进程。进程是构成运行程序资源的集合。在进程内部，有称为线程的内核对象，它代表的是真正的执行程序。系统会在 Main 方法的第一行语句就开始线程的执行。\u003c/p\u003e","title":"C#中async和await异步编程"},{"content":"foreach foreach元素的属性主要有item，index，collection，open，separator，close。\nitem：集合中元素迭代时的别名 index：集合中元素迭代时的索引 open：常用语where语句中，表示以什么开始，比如以\u0026rsquo;(\u0026lsquo;开始 separator：表示在每次进行迭代时的分隔符 close 常用语where语句中，表示以什么结束 在使用foreach的时候最关键的也是最容易出错的就是collection属性，该属性是必须指定的，但是在不同情况下，该属性的值是不一样的，主要有一下3种情况：\n如果传入的是单参数且参数类型是一个List的时候，collection属性值为list 如果传入的是单参数且参数类型是一个array数组的时候，collection的属性值为array 如果传入的参数是多个的时候，我们就需要把它们封装成一个Map了，当然单参数也可以封装成map，实际上如果你在传入参数的时候，在MyBatis里面也是会把它封装成一个Map的，map的key就是参数名，所以这个时候collection属性值就是传入的List或array对象在自己封装的map里面的key //mapper中我们要为这个方法传递的是一个容器,将容器中的元素一个一个的\r//拼接到xml的方法中就要使用这个forEach这个标签了\rpublic List\u0026lt;Entity\u0026gt; queryById(List\u0026lt;String\u0026gt; userids);\r//对应的xml中如下\r\u0026lt;select id=\u0026#34;queryById\u0026#34; resultMap=\u0026#34;BaseReslutMap\u0026#34; \u0026gt;\rselect * FROM entity\rwhere id in\r\u0026lt;foreach collection=\u0026#34;userids\u0026#34; item=\u0026#34;userid\u0026#34; index=\u0026#34;index\u0026#34; open=\u0026#34;(\u0026#34; separator=\u0026#34;,\u0026#34; close=\u0026#34;)\u0026#34;\u0026gt;\r#{userid}\r\u0026lt;/foreach\u0026gt;\r\u0026lt;/select\u0026gt; concat //比如说我们想要进行条件查询,但是几个条件不是每次都要使用,那么我们就可以 //通过判断是否拼接到sql中 \u0026lt;select id=\u0026#34;queryById\u0026#34; resultMap=\u0026#34;BascResultMap\u0026#34; parameterType=\u0026#34;entity\u0026#34;\u0026gt; SELECT * from entity \u0026lt;where\u0026gt; \u0026lt;if test=\u0026#34;name!=null\u0026#34;\u0026gt; name like concat(\u0026#39;%\u0026#39;,concat(#{name},\u0026#39;%\u0026#39;)) \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; choose (when,otherwise) choose标签是按顺序判断其内部when标签中的test条件出否成立，如果有一个成立，则 choose 结束。当 choose 中所有 when 的条件都不满则时，则执行 otherwise 中的sql。类似于Java 的 switch 语句，choose 为 switch，when 为 case，otherwise 则为 default。\n例如下面例子，同样把所有可以限制的条件都写上，方面使用。choose会从上到下选择一个when标签的test为true的sql执行。安全考虑，我们使用where将choose包起来，放置关键字多于错误。\n\u0026lt;!-- choose(判断参数) - 按顺序将实体类 User 第一个不为空的属性作为：where条件 --\u0026gt; \u0026lt;select id=\u0026#34;getUserList_choose\u0026#34; resultMap=\u0026#34;resultMap_user\u0026#34; parameterType=\u0026#34;com.yiibai.pojo.User\u0026#34;\u0026gt; SELECT * FROM User u \u0026lt;where\u0026gt; \u0026lt;choose\u0026gt; \u0026lt;when test=\u0026#34;username !=null \u0026#34;\u0026gt; u.username LIKE CONCAT(CONCAT(\u0026#39;%\u0026#39;, #{username, jdbcType=VARCHAR}),\u0026#39;%\u0026#39;) \u0026lt;/when \u0026gt; \u0026lt;when test=\u0026#34;sex != null and sex != \u0026#39;\u0026#39; \u0026#34;\u0026gt; AND u.sex = #{sex, jdbcType=INTEGER} \u0026lt;/when \u0026gt; \u0026lt;when test=\u0026#34;birthday != null \u0026#34;\u0026gt; AND u.birthday = #{birthday, jdbcType=DATE} \u0026lt;/when \u0026gt; \u0026lt;otherwise\u0026gt; \u0026lt;/otherwise\u0026gt; \u0026lt;/choose\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; selectKey 在insert语句中，在Oracle经常使用序列、在MySQL中使用函数来自动生成插入表的主键，而且需要方法能返回这个生成主键。使用myBatis的selectKey标签可以实现这个效果。\n下面例子，使用mysql数据库自定义函数nextval(\u0026lsquo;student\u0026rsquo;)，用来生成一个key，并把他设置到传入的实体类中的studentId属性上。所以在执行完此方法后，边可以通过这个实体类获取生成的key。\n\u0026lt;!-- 插入学生 自动主键--\u0026gt; \u0026lt;insert id=\u0026#34;createStudentAutoKey\u0026#34; parameterType=\u0026#34;liming.student.manager.data.model.StudentEntity\u0026#34; keyProperty=\u0026#34;studentId\u0026#34;\u0026gt; \u0026lt;selectKey keyProperty=\u0026#34;studentId\u0026#34; resultType=\u0026#34;String\u0026#34; order=\u0026#34;BEFORE\u0026#34;\u0026gt; select nextval(\u0026#39;student\u0026#39;) \u0026lt;/selectKey\u0026gt; INSERT INTO STUDENT_TBL(STUDENT_ID, STUDENT_NAME, STUDENT_SEX, STUDENT_BIRTHDAY, STUDENT_PHOTO, CLASS_ID, PLACE_ID) VALUES (#{studentId}, #{studentName}, #{studentSex}, #{studentBirthday}, #{studentPhoto, javaType=byte[], jdbcType=BLOB, typeHandler=org.apache.ibatis.type.BlobTypeHandler}, #{classId}, #{placeId}) \u0026lt;/insert\u0026gt; 调用接口方法，和获取自动生成key\nStudentEntity entity = new StudentEntity(); entity.setStudentName(\u0026#34;黎明你好\u0026#34;); entity.setStudentSex(1); entity.setStudentBirthday(DateUtil.parse(\u0026#34;1985-05-28\u0026#34;)); entity.setClassId(\u0026#34;20000001\u0026#34;); entity.setPlaceId(\u0026#34;70000001\u0026#34;); this.dynamicSqlMapper.createStudentAutoKey(entity); System.out.println(\u0026#34;新增学生ID: \u0026#34; + entity.getStudentId()); if if标签可用在许多类型的sql语句中，我们以查询为例。首先看一个很普通的查询：\n\u0026lt;!-- 查询学生list，like姓名 --\u0026gt; \u0026lt;select id=\u0026#34;getStudentListLikeName\u0026#34; parameterType=\u0026#34;StudentEntity\u0026#34; resultMap=\u0026#34;studentResultMap\u0026#34;\u0026gt; SELECT * from STUDENT_TBL ST WHERE ST.STUDENT_NAME LIKE CONCAT(CONCAT(\u0026#39;%\u0026#39;, #{studentName}),\u0026#39;%\u0026#39;) \u0026lt;/select\u0026gt; 但是此时如果studentName为null，此语句很可能报错或查询结果为空。此时我们使用if动态sql语句先进行判断，如果值为null或等于空字符串，我们就不进行此条件的判断，增加灵活性。\n参数为实体类StudentEntity。将实体类中所有的属性均进行判断，如果不为空则执行判断条件。\n\u0026lt;!-- 2 if(判断参数) - 将实体类不为空的属性作为where条件 --\u0026gt; \u0026lt;select id=\u0026#34;getStudentList_if\u0026#34; resultMap=\u0026#34;resultMap_studentEntity\u0026#34; parameterType=\u0026#34;liming.student.manager.data.model.StudentEntity\u0026#34;\u0026gt; SELECT ST.STUDENT_ID, ST.STUDENT_NAME, ST.STUDENT_SEX, ST.STUDENT_BIRTHDAY, ST.STUDENT_PHOTO, ST.CLASS_ID, ST.PLACE_ID FROM STUDENT_TBL ST WHERE \u0026lt;if test=\u0026#34;studentName !=null \u0026#34;\u0026gt; ST.STUDENT_NAME LIKE CONCAT(CONCAT(\u0026#39;%\u0026#39;, #{studentName, jdbcType=VARCHAR}),\u0026#39;%\u0026#39;) \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;studentSex != null and studentSex != \u0026#39;\u0026#39; \u0026#34;\u0026gt; AND ST.STUDENT_SEX = #{studentSex, jdbcType=INTEGER} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;studentBirthday != null \u0026#34;\u0026gt; AND ST.STUDENT_BIRTHDAY = #{studentBirthday, jdbcType=DATE} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;classId != null and classId!= \u0026#39;\u0026#39; \u0026#34;\u0026gt; AND ST.CLASS_ID = #{classId, jdbcType=VARCHAR} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;classEntity != null and classEntity.classId !=null and classEntity.classId !=\u0026#39; \u0026#39; \u0026#34;\u0026gt; AND ST.CLASS_ID = #{classEntity.classId, jdbcType=VARCHAR} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;placeId != null and placeId != \u0026#39;\u0026#39; \u0026#34;\u0026gt; AND ST.PLACE_ID = #{placeId, jdbcType=VARCHAR} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;placeEntity != null and placeEntity.placeId != null and placeEntity.placeId != \u0026#39;\u0026#39; \u0026#34;\u0026gt; AND ST.PLACE_ID = #{placeEntity.placeId, jdbcType=VARCHAR} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;studentId != null and studentId != \u0026#39;\u0026#39; \u0026#34;\u0026gt; AND ST.STUDENT_ID = #{studentId, jdbcType=VARCHAR} \u0026lt;/if\u0026gt; \u0026lt;/select\u0026gt; 使用时比较灵活， new一个这样的实体类，我们需要限制那个条件，只需要附上相应的值就会where这个条件，相反不去赋值就可以不在where中判断。\npublic void select_test_2_1() { StudentEntity entity = new StudentEntity(); entity.setStudentName(\u0026#34;\u0026#34;); entity.setStudentSex(1); entity.setStudentBirthday(DateUtil.parse(\u0026#34;1985-05-28\u0026#34;)); entity.setClassId(\u0026#34;20000001\u0026#34;); //entity.setPlaceId(\u0026#34;70000001\u0026#34;); List\u0026lt;StudentEntity\u0026gt; list = this.dynamicSqlMapper.getStudentList_if(entity); for (StudentEntity e : list) { System.out.println(e.toString()); } } if + where 当where中的条件使用的if标签较多时，这样的组合可能会导致错误。我们以在3.1中的查询语句为例子，当java代码按如下方法调用时：\n@Test public void select_test_2_1() { StudentEntity entity = new StudentEntity(); entity.setStudentName(null); entity.setStudentSex(1); List\u0026lt;StudentEntity\u0026gt; list = this.dynamicSqlMapper.getStudentList_if(entity); for (StudentEntity e : list) { System.out.println(e.toString()); } } 如果上面例子，参数studentName为null，将不会进行STUDENT_NAME列的判断，则会直接导“WHERE AND”关键字多余的错误SQL。\n这时我们可以使用where动态语句来解决。这个“where”标签会知道如果它包含的标签中有返回值的话，它就插入一个‘where’。此外，如果标签返回的内容是以AND 或OR 开头的，则它会剔除掉。\n上面例子修改为：\n\u0026lt;!-- 3 select - where/if(判断参数) - 将实体类不为空的属性作为where条件 --\u0026gt; \u0026lt;select id=\u0026#34;getStudentList_whereIf\u0026#34; resultMap=\u0026#34;resultMap_studentEntity\u0026#34; parameterType=\u0026#34;liming.student.manager.data.model.StudentEntity\u0026#34;\u0026gt; SELECT ST.STUDENT_ID, ST.STUDENT_NAME, ST.STUDENT_SEX, ST.STUDENT_BIRTHDAY, ST.STUDENT_PHOTO, ST.CLASS_ID, ST.PLACE_ID FROM STUDENT_TBL ST \u0026lt;where\u0026gt; \u0026lt;if test=\u0026#34;studentName !=null \u0026#34;\u0026gt; ST.STUDENT_NAME LIKE CONCAT(CONCAT(\u0026#39;%\u0026#39;, #{studentName, jdbcType=VARCHAR}),\u0026#39;%\u0026#39;) \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;studentSex != null and studentSex != \u0026#39;\u0026#39; \u0026#34;\u0026gt; AND ST.STUDENT_SEX = #{studentSex, jdbcType=INTEGER} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;studentBirthday != null \u0026#34;\u0026gt; AND ST.STUDENT_BIRTHDAY = #{studentBirthday, jdbcType=DATE} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;classId != null and classId!= \u0026#39;\u0026#39; \u0026#34;\u0026gt; AND ST.CLASS_ID = #{classId, jdbcType=VARCHAR} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;classEntity != null and classEntity.classId !=null and classEntity.classId !=\u0026#39; \u0026#39; \u0026#34;\u0026gt; AND ST.CLASS_ID = #{classEntity.classId, jdbcType=VARCHAR} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;placeId != null and placeId != \u0026#39;\u0026#39; \u0026#34;\u0026gt; AND ST.PLACE_ID = #{placeId, jdbcType=VARCHAR} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;placeEntity != null and placeEntity.placeId != null and placeEntity.placeId != \u0026#39;\u0026#39; \u0026#34;\u0026gt; AND ST.PLACE_ID = #{placeEntity.placeId, jdbcType=VARCHAR} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;studentId != null and studentId != \u0026#39;\u0026#39; \u0026#34;\u0026gt; AND ST.STUDENT_ID = #{studentId, jdbcType=VARCHAR} \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; if + set 当update语句中没有使用if标签时，如果有一个参数为null，都会导致错误。\n当在update语句中使用if标签时，如果前面的if没有执行，则或导致逗号多余错误。使用set标签可以将动态的配置SET 关键字，和剔除追加到条件末尾的任何不相关的逗号。使用if+set标签修改后，如果某项为null则不进行更新，而是保持数据库原值。\n如下示例：\n\u0026lt;!-- 4 if/set(判断参数) - 将实体类不为空的属性更新 --\u0026gt; \u0026lt;update id=\u0026#34;updateStudent_if_set\u0026#34; parameterType=\u0026#34;liming.student.manager.data.model.StudentEntity\u0026#34;\u0026gt; UPDATE STUDENT_TBL \u0026lt;set\u0026gt; \u0026lt;if test=\u0026#34;studentName != null and studentName != \u0026#39;\u0026#39; \u0026#34;\u0026gt; STUDENT_TBL.STUDENT_NAME = #{studentName}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;studentSex != null and studentSex != \u0026#39;\u0026#39; \u0026#34;\u0026gt; STUDENT_TBL.STUDENT_SEX = #{studentSex}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;studentBirthday != null \u0026#34;\u0026gt; STUDENT_TBL.STUDENT_BIRTHDAY = #{studentBirthday}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;studentPhoto != null \u0026#34;\u0026gt; STUDENT_TBL.STUDENT_PHOTO = #{studentPhoto, javaType=byte[], jdbcType=BLOB, typeHandler=org.apache.ibatis.type.BlobTypeHandler}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;classId != \u0026#39;\u0026#39; \u0026#34;\u0026gt; STUDENT_TBL.CLASS_ID = #{classId} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;placeId != \u0026#39;\u0026#39; \u0026#34;\u0026gt; STUDENT_TBL.PLACE_ID = #{placeId} \u0026lt;/if\u0026gt; \u0026lt;/set\u0026gt; WHERE STUDENT_TBL.STUDENT_ID = #{studentId}; \u0026lt;/update\u0026gt; if + trim trim是更灵活的去处多余关键字的标签，他可以实践where和set的效果。\ntrim代替where\n\u0026lt;!-- 5.1if/trim代替where(判断参数) -将实体类不为空的属性作为where条件--\u0026gt; \u0026lt;select id=\u0026#34;getStudentList_if_trim\u0026#34; resultMap=\u0026#34;resultMap_studentEntity\u0026#34;\u0026gt; SELECT ST.STUDENT_ID, ST.STUDENT_NAME, ST.STUDENT_SEX, ST.STUDENT_BIRTHDAY, ST.STUDENT_PHOTO, ST.CLASS_ID, ST.PLACE_ID FROM STUDENT_TBL ST \u0026lt;trim prefix=\u0026#34;WHERE\u0026#34; prefixOverrides=\u0026#34;AND|OR\u0026#34;\u0026gt; \u0026lt;if test=\u0026#34;studentName !=null \u0026#34;\u0026gt; ST.STUDENT_NAME LIKE CONCAT(CONCAT(\u0026#39;%\u0026#39;, #{studentName, jdbcType=VARCHAR}),\u0026#39;%\u0026#39;) \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;studentSex != null and studentSex != \u0026#39;\u0026#39; \u0026#34;\u0026gt; AND ST.STUDENT_SEX = #{studentSex, jdbcType=INTEGER} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;studentBirthday != null \u0026#34;\u0026gt; AND ST.STUDENT_BIRTHDAY = #{studentBirthday, jdbcType=DATE} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;classId != null and classId!= \u0026#39;\u0026#39; \u0026#34;\u0026gt; AND ST.CLASS_ID = #{classId, jdbcType=VARCHAR} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;classEntity != null and classEntity.classId !=null and classEntity.classId !=\u0026#39; \u0026#39; \u0026#34;\u0026gt; AND ST.CLASS_ID = #{classEntity.classId, jdbcType=VARCHAR} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;placeId != null and placeId != \u0026#39;\u0026#39; \u0026#34;\u0026gt; AND ST.PLACE_ID = #{placeId, jdbcType=VARCHAR} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;placeEntity != null and placeEntity.placeId != null and placeEntity.placeId != \u0026#39;\u0026#39; \u0026#34;\u0026gt; AND ST.PLACE_ID = #{placeEntity.placeId, jdbcType=VARCHAR} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;studentId != null and studentId != \u0026#39;\u0026#39; \u0026#34;\u0026gt; AND ST.STUDENT_ID = #{studentId, jdbcType=VARCHAR} \u0026lt;/if\u0026gt; \u0026lt;/trim\u0026gt; \u0026lt;/select\u0026gt; trim代替set\n\u0026lt;!-- 5.2 if/trim代替set(判断参数) - 将实体类不为空的属性更新 --\u0026gt; \u0026lt;update id=\u0026#34;updateStudent_if_trim\u0026#34; parameterType=\u0026#34;liming.student.manager.data.model.StudentEntity\u0026#34;\u0026gt; UPDATE STUDENT_TBL \u0026lt;trim prefix=\u0026#34;SET\u0026#34; suffixOverrides=\u0026#34;,\u0026#34;\u0026gt; \u0026lt;if test=\u0026#34;studentName != null and studentName != \u0026#39;\u0026#39; \u0026#34;\u0026gt; STUDENT_TBL.STUDENT_NAME = #{studentName}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;studentSex != null and studentSex != \u0026#39;\u0026#39; \u0026#34;\u0026gt; STUDENT_TBL.STUDENT_SEX = #{studentSex}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;studentBirthday != null \u0026#34;\u0026gt; STUDENT_TBL.STUDENT_BIRTHDAY = #{studentBirthday}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;studentPhoto != null \u0026#34;\u0026gt; STUDENT_TBL.STUDENT_PHOTO = #{studentPhoto, javaType=byte[], jdbcType=BLOB, typeHandler=org.apache.ibatis.type.BlobTypeHandler}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;classId != \u0026#39;\u0026#39; \u0026#34;\u0026gt; STUDENT_TBL.CLASS_ID = #{classId}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;placeId != \u0026#39;\u0026#39; \u0026#34;\u0026gt; STUDENT_TBL.PLACE_ID = #{placeId} \u0026lt;/if\u0026gt; \u0026lt;/trim\u0026gt; WHERE STUDENT_TBL.STUDENT_ID = #{studentId} \u0026lt;/update\u0026gt; sql sql片段标签\u0026lt;sql\u0026gt;：通过该标签可定义能复用的sql语句片段，在执行sql语句标签中直接引用即可。这样既可以提高编码效率，还能有效简化代码，提高可读性\n需要配置的属性：id=\u0026quot;\u0026quot; \u0026raquo;\u0026gt;表示需要改sql语句片段的唯一标识\n引用：通过\u0026lt;include refid=\u0026quot;\u0026quot; /\u0026gt;标签引用，refid=\u0026quot;\u0026quot; 中的值指向需要引用的\u0026lt;sql\u0026gt;中的id=“”属性\n\u0026lt;!--定义sql片段--\u0026gt; \u0026lt;sql id=\u0026#34;orderAndItem\u0026#34;\u0026gt; o.order_id,o.cid,o.address,o.create_date,o.orderitem_id,i.orderitem_id,i.product_id,i.count \u0026lt;/sql\u0026gt; \u0026lt;select id=\u0026#34;findOrderAndItemsByOid\u0026#34; parameterType=\u0026#34;java.lang.String\u0026#34; resultMap=\u0026#34;BaseResultMap\u0026#34;\u0026gt; select \u0026lt;!--引用sql片段--\u0026gt; \u0026lt;include refid=\u0026#34;orderAndItem\u0026#34; /\u0026gt; from ordertable o join orderitem i on o.orderitem_id = i.orderitem_id where o.order_id = #{orderId} \u0026lt;/select\u0026gt; ","permalink":"https://lesanouo.github.io/blog/posts/snippet/mybatis/","summary":"\u003ch2 id=\"foreach\"\u003eforeach\u003c/h2\u003e\n\u003cp\u003eforeach元素的属性主要有item，index，collection，open，separator，close。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eitem：集合中元素迭代时的别名\u003c/li\u003e\n\u003cli\u003eindex：集合中元素迭代时的索引\u003c/li\u003e\n\u003cli\u003eopen：常用语where语句中，表示以什么开始，比如以\u0026rsquo;(\u0026lsquo;开始\u003c/li\u003e\n\u003cli\u003eseparator：表示在每次进行迭代时的分隔符\u003c/li\u003e\n\u003cli\u003eclose 常用语where语句中，表示以什么结束\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e在使用foreach的时候最关键的也是最容易出错的就是collection属性，该属性是必须指定的，但是在不同情况下，该属性的值是不一样的，主要有一下3种情况：\u003c/p\u003e","title":"Mybatis 代码片段"},{"content":"行转列 使用PIVOT实现 SELECT * FROM student PIVOT ( SUM(score) FOR subject IN (语文, 数学, 英语) ) 分组后使用case进行条件判断处理 当然我们也可以用 CASE WHEN 得到同样的结果，就是写起来麻烦一点。\nSELECT name, MAX( CASE WHEN subject=\u0026#39;语文\u0026#39; THEN score ELSE 0 END) AS \u0026#34;语文\u0026#34;, MAX( CASE WHEN subject=\u0026#39;数学\u0026#39; THEN score ELSE 0 END) AS \u0026#34;数学\u0026#34;, MAX( CASE WHEN subject=\u0026#39;英语\u0026#39; THEN score ELSE 0 END) AS \u0026#34;英语\u0026#34; FROM student GROUP BY name 使用 CASE WHEN 可以得到和 PIVOT 同样的结果，没有 PIVOT 简单直观。\n列转行 使用UNPIVOT实现 SELECT * FROM student1 UNPIVOT ( score FOR subject IN (\u0026#34;语文\u0026#34;,\u0026#34;数学\u0026#34;,\u0026#34;英语\u0026#34;) ) 分组后使用case进行条件判断处理 我们也可以使用下面方法得到同样结果\nSELECT NAME, \u0026#39;语文\u0026#39; AS subject , MAX(\u0026#34;语文\u0026#34;) AS score FROM student1 GROUP BY NAME UNION SELECT NAME, \u0026#39;数学\u0026#39; AS subject , MAX(\u0026#34;数学\u0026#34;) AS score FROM student1 GROUP BY NAME UNION SELECT NAME, \u0026#39;英语\u0026#39; AS subject , MAX(\u0026#34;英语\u0026#34;) AS score FROM student1 GROUP BY NAME UNION \u0026amp; UNION ALL UNION 操作符用于合并两个或多个 SELECT 语句的结果集。\n请注意，UNION 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同。\nSQL UNION 语法\nSELECT column_name(s) FROM table_name1 UNION SELECT column_name(s) FROM table_name2 **注释：**默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。\nSQL UNION ALL 语法\nSELECT column_name(s) FROM table_name1 UNION ALL SELECT column_name(s) FROM table_name2 另外，UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名。\n","permalink":"https://lesanouo.github.io/blog/posts/snippet/sql/","summary":"\u003ch2 id=\"行转列\"\u003e行转列\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e使用PIVOT实现\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sql\" data-lang=\"sql\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eSELECT\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eFROM\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003estudent\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003ePIVOT\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"k\"\u003eSUM\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003escore\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eFOR\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003esubject\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eIN\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"err\"\u003e语文\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"err\"\u003e数学\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"err\"\u003e英语\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e分组后使用case进行条件判断处理\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e当然我们也可以用 CASE WHEN 得到同样的结果，就是写起来麻烦一点。\u003c/p\u003e","title":"SQL 代码片段"},{"content":"索引 MySQL 索引 MySQL 的索引有两种分类方式：逻辑分类和物理分类\n逻辑分类 主键索引：一张表只能有一个主键索引，不允许重复、不允许为 NULL 唯一索引：数据列不允许重复，允许为 NULL 值，一张表可有多个唯一索引，索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一 普通索引：一张表可以创建多个普通索引，一个普通索引可以包含多个字段，允许数据重复，允许 NULL 值插入 全文索引：它查找的是文本中的关键词，主要用于全文检索 单例索引：一个索引只包含一个列，一个表可以有多个单例索引 组合索引：一个组合索引包含两个或两个以上的列。查询的时候遵循 mysql 组合索引的 “最左前缀”原则，即使用 where 时条件要按照建立索引的时候字段的排列方式放置索引才会生效 物理分类 聚簇索引：不是单独的一种索引类型，而是一种数据存储方式。这种存储方式是依靠B+树来实现的，根据表的主键构造一棵B+树且B+树叶子节点存放的都是表的行记录数据时，方可称该主键索引为聚簇索引。聚簇索引也可理解为将数据存储与索引放到了一块，找到索引也就找到了数据。 非聚簇索引：数据和索引是分开的，B+树叶子节点存放的不是数据表的行记录 EXPLAIN 使用格式：EXPLAIN SQL...;\n返回结果包含：\nid:选择标识符 select_type:表示查询的类型。 table:输出结果集的表 partitions:匹配的分区 type:表示表的连接类型 possible_keys:表示查询时，可能使用的索引 key:表示实际使用的索引 key_len:索引字段的长度 ref:列与索引的比较 rows:扫描出的行数(估算的行数) filtered:按表条件过滤的行百分比 Extra:执行情况的描述和说明 SQL Server 索引 唯一索引（UNIQUE）：唯一索引不允许两行具有相同的索引值 主键索引：为表定义一个主键将自动创建主键索引，主键索引是唯一索引的特殊类型。主键索引要求主键中的每个值是唯一的，并且不能为空 聚集索引(Clustered)：表中各行的物理顺序与键值的逻辑（索引）顺序相同，每个表最多只能有一个，设置某列为主键，该列就默认为聚集索引 非聚集索引(NonClustered)：非聚集索引指定表的逻辑顺序。数据存储在一个位置，索引存储在另一个位置，索引中包含指向数据存储位置的指针。可以有多个，小于249个 SQL 优化 总结SQL优化中，就三点:\n最大化利用索引； 尽可能避免全表扫描； 减少无效数据的查询； 避免不走索引的场景 1. 尽量避免在字段开头模糊查询，会导致数据库引擎放弃索引进行全表扫码 例如： SELECT * FROM user WHERE name LIKE '%李%'\n优化方式：尽量在字段后面使用模糊查询，例如： SELECT * FROM user WHERE name LIKE '李%'\n如果需要在前面使用模糊查询，可以使用以下方式：\n使用MySQL内置函数 INSTR(str, substr)，返回匹配子串的位置,类似Java中的 str.indexOf(substr) 使用FullText全文索引，用match against检索 数据量较大的情况，使用ElasticSearch、solr，亿级数据量检索速度秒级 当数据量较少时（几千条），直接用 LIKE '%李%' 2. 尽量避免使用in和not in，会导致全表扫描 SELECT * FROM table WHERE id IN (2,3)\n优化方式：如果是连续数值，可以使用between代替，例如: SELECT * FROM table WHERE id BETWEEN 2 AND 3\n如果是子查询，可以使用 EXISTS或 NOT EXISTS代替，例如: SELECT * FROM table WHERE EXISTS (SELECT id FROM table2 WHERE table.id = table2.id)\n3. 尽量避免使用OR，会导致全表扫描 SELECT * FROM table WHERE id = 1 OR id = 2\n优化方式：可以使用Union，例如: SELECT * FROM table WHERE id = 1 UNION SELECT * FROM table WHERE id = 2\n4. 尽量避免null值的判断 SELECT * FROM table WHERE id IS NULL\n优化方式：可以给字段添加默认值，对默认值进行判断，例如： SELECT * FROM table WHERE id = 默认值\n5. 尽量避免在where条件中等号左侧进行表达式、函数操作 可以将表达式、函数操作移动到等号右侧，例如：\n-- 全表扫码 SELECT * FROM table WHERE score/10 = 9 -- 走索引 SELECT * FROM table WHERE score = 10 * 9 6. 当数据量大时，避免使用where 1=1的条件 通常为了方便拼接查询条件，会使用它来作为条件\n优化方式：用代码拼接sql时进行判断，没where条件就去掉where，有where条件就加and\n7. 查询条件不能用\u0026lt;\u0026gt;或者!= 使用索引列作为条件进行查询时，需要避免使用\u0026lt;\u0026gt;或者!=等判断条件。如确实业务需要，使用到不等于符号，需要在重新评估索引建立，避免在此字段上建立索引，改由查询条件中其他索引字段代替\n8. where条件仅包含复合索引非前置列 如下：复合（联合）索引包含key_part1，key_part2，key_part3三列，但SQL语句没有包含索引前置列\u0026quot;key_part1\u0026quot;，按照MySQL联合索引的最左匹配原则，不会走联合索引 select col1 from table where key_part2=1 and key_part3=2\n9. 隐式类型转换造成不使用索引 如下SQL语句由于索引对列类型为varchar，但给定的值为数值，涉及隐式类型转换，造成不能正确走索引 select col1 from table where col_varchar=123; 10. order by 条件要与where中条件一致，否则order by不会利用索引进行排序 -- 不走age索引 SELECT * FROM t order by age; -- 走age索引 SELECT * FROM t where age \u0026gt; 0 order by age; 当order by 中的字段出现在where条件中时，才会利用索引而不再二次排序，更准确的说，order by 中的字段在执行计划中利用了索引时，不用排序操作\n这个结论不仅对order by有效，对其他需要排序的操作也有效。比如group by 、union 、distinct等\n11. 正确使用hint优化语句 MySQL中可以使用hint指定优化器在执行时选择或忽略特定的索引。一般而言，处于版本变更带来的表结构索引变化，更建议避免使用hint，而是通过Analyze table多收集统计信息。但在特定场合下，指定hint可以排除其他索引干扰而指定更优的执行计划。\nUSE INDEX 在你查询语句中表名的后面，添加 USE INDEX 来提供希望 MySQL 去参考的索引列表，就可以让 MySQL 不再考虑其他可用的索引。例子: SELECT col1 FROM table USE INDEX (mod_time, name)\u0026hellip; IGNORE INDEX 如果只是单纯的想让 MySQL 忽略一个或者多个索引，可以使用 IGNORE INDEX 作为 Hint。例子: SELECT col1 FROM table IGNORE INDEX (priority) \u0026hellip; FORCE INDEX 为强制 MySQL 使用一个特定的索引，可在查询中使用FORCE INDEX 作为Hint。例子: SELECT col1 FROM table FORCE INDEX (mod_time) \u0026hellip; 在查询的时候，数据库系统会自动分析查询语句，并选择一个最合适的索引。但是很多时候，数据库系统的查询优化器并不一定总是能使用最优索引。如果我们知道如何选择索引，可以使用FORCE INDEX强制查询使用指定的索引。\n例如：SELECT * FROM students FORCE INDEX (idx_class_id) WHERE class_id = 1 ORDER BY id DESC;\nSELECT语句其他优化 1. 避免出现select * 首先，select * 操作在任何类型数据库中都不是一个好的SQL编写习惯。\n使用select * 取出全部列，会让优化器无法完成索引覆盖扫描这类优化，会影响优化器对执行计划的选择，也会增加网络带宽消耗，更会带来额外的I/O,内存和CPU消耗。\n建议提出业务实际需要的列数，将指定列名以取代select *。\n2. 避免出现不确定结果的函数 特定针对主从复制这类业务场景。由于原理上从库复制的是主库执行的语句，使用如now()、rand()、sysdate()、current_user()等不确定结果的函数很容易导致主库与从库相应的数据不一致。另外不确定值的函数,产生的SQL语句无法利用query cache。\n3.多表关联查询时，小表在前，大表在后。 在MySQL中，执行 from 后的表关联查询是从左往右执行的（Oracle相反），第一张表会涉及到全表扫描，所以将小表放在前面，先扫小表，扫描快效率较高，在扫描后面的大表，或许只扫描大表的前100行就符合返回条件并return了。\n例如：表1有50条数据，表2有30亿条数据；如果全表扫描表2，你品，那就先去吃个饭再说吧是吧。\n4. 使用表的别名 当在SQL语句中连接多个表时，请使用表的别名并把别名前缀于每个列名上。这样就可以减少解析的时间并减少哪些友列名歧义引起的语法错误。\n5. 用where字句替换HAVING字句 避免使用HAVING字句，因为HAVING只会在检索出所有记录之后才对结果集进行过滤，而where则是在聚合前刷选记录，如果能通过where字句限制记录的数目，那就能减少这方面的开销。HAVING中的条件一般用于聚合函数的过滤，除此之外，应该将条件写在where字句中。\nwhere和having的区别：where后面不能使用组函数\n6.调整Where字句中的连接顺序 MySQL采用从左往右，自上而下的顺序解析where子句。根据这个原理，应将过滤数据多的条件往前放，最快速度缩小结果集。\n增删改 DML 语句优化 1. 大批量插入数据 如果同时执行大量的插入，建议使用多个值的INSERT语句(方法二)。这比使用分开INSERT语句快（方法一），一般情况下批量插入效率有几倍的差别。\n方法一：\ninsert into T values(1,2); insert into T values(1,3); insert into T values(1,4); 方法二：\nInsert into T values(1,2),(1,3),(1,4); 选择后一种方法的原因有三。\n减少SQL语句解析的操作，MySQL没有类似Oracle的share pool，采用方法二，只需要解析一次就能进行数据的插入操作； 在特定场景可以减少对DB连接次数 SQL语句较短，可以减少网络传输的IO。 2. 适当使用commit 适当使用commit可以释放事务占用的资源而减少消耗，commit后能释放的资源如下：\n事务占用的undo数据块； 事务在redo log中记录的数据块； 释放事务施加的，减少锁争用影响性能。特别是在需要使用delete删除大量数据的时候，必须分解删除量并定期commit。 3. 避免重复查询更新的数据 针对业务中经常出现的更新行同时又希望获得改行信息的需求，MySQL并不支持PostgreSQL那样的UPDATE RETURNING语法，在MySQL中可以通过变量实现。\n例如，更新一行记录的时间戳，同时希望查询当前记录中存放的时间戳是什么，简单方法实现：\nUpdate t1 set time=now() where col1=1; Select time from t1 where id =1; 使用变量，可以重写为以下方式：\nUpdate t1 set time=now () where col1=1 and @now: = now (); Select @now; 前后二者都需要两次网络来回，但使用变量避免了再次访问数据表，特别是当t1表数据量较大时，后者比前者快很多。\n4.查询优先还是更新（insert、update、delete）优先 MySQL 还允许改变语句调度的优先级，它可以使来自多个客户端的查询更好地协作，这样单个客户端就不会由于锁定而等待很长时间。改变优先级还可以确保特定类型的查询被处理得更快。我们首先应该确定应用的类型，判断应用是以查询为主还是以更新为主的，是确保查询效率还是确保更新的效率，决定是查询优先还是更新优先。下面我们提到的改变调度策略的方法主要是针对只存在表锁的存储引擎，比如 MyISAM 、MEMROY、MERGE，对于Innodb 存储引擎，语句的执行是由获得行锁的顺序决定的。MySQL 的默认的调度策略可用总结如下：\n1）写入操作优先于读取操作。\n2）对某张数据表的写入操作某一时刻只能发生一次，写入请求按照它们到达的次序来处理。\n3）对某张数据表的多个读取操作可以同时地进行。MySQL 提供了几个语句调节符，允许你修改它的调度策略：\nLOW_PRIORITY关键字应用于DELETE、INSERT、LOAD DATA、REPLACE和UPDATE； HIGH_PRIORITY关键字应用于SELECT和INSERT语句； DELAYED关键字应用于INSERT和REPLACE语句。 如果写入操作是一个 LOW_PRIORITY（低优先级）请求，那么系统就不会认为它的优先级高于读取操作。在这种情况下，如果写入者在等待的时候，第二个读取者到达了，那么就允许第二个读取者插到写入者之前。只有在没有其它的读取者的时候，才允许写入者开始操作。这种调度修改可能存在 LOW_PRIORITY写入操作永远被阻塞的情况。\nSELECT 查询的HIGH_PRIORITY（高优先级）关键字也类似。它允许SELECT 插入正在等待的写入操作之前，即使在正常情况下写入操作的优先级更高。另外一种影响是，高优先级的 SELECT 在正常的 SELECT 语句之前执行，因为这些语句会被写入操作阻塞。如果希望所有支持LOW_PRIORITY 选项的语句都默认地按照低优先级来处理，那么 请使用\u0026ndash;low-priority-updates 选项来启动服务器。通过使用 INSERTHIGH_PRIORITY 来把 INSERT 语句提高到正常的写入优先级，可以消除该选项对单个INSERT语句的影响。\n查询条件优化 1. 对于复杂的查询，可以使用中间临时表暂存数据 2. 优化group by语句 默认情况下，MySQL 会对GROUP BY分组的所有值进行排序，如 “GROUP BY col1，col2，\u0026hellip;.;” 查询的方法如同在查询中指定 “ORDER BY col1，col2，\u0026hellip;;” 如果显式包括一个包含相同的列的 ORDER BY子句，MySQL 可以毫不减速地对它进行优化，尽管仍然进行排序。\n因此，如果查询包括 GROUP BY 但你并不想对分组的值进行排序，你可以指定 ORDER BY NULL禁止排序。例如：\nSELECT col1, col2, COUNT(*) FROM table GROUP BY col1, col2 ORDER BY NULL\n3. 优化join语句 MySQL中可以通过子查询来使用 SELECT 语句来创建一个单列的查询结果，然后把这个结果作为过滤条件用在另一个查询中。使用子查询可以一次性的完成很多逻辑上需要多个步骤才能完成的 SQL 操作，同时也可以避免事务或者表锁死，并且写起来也很容易。但是，有些情况下，子查询可以被更有效率的连接(JOIN)..替代。\n例子：假设要将所有没有订单记录的用户取出来，可以用下面这个查询完成： SELECT col1 FROM customerinfo WHERE CustomerID NOT in (SELECT CustomerID FROM salesinfo )\n如果使用连接(JOIN).. 来完成这个查询工作，速度将会有所提升。尤其是当 salesinfo表中对 CustomerID 建有索引的话，性能将会更好，查询如下：\nSELECT col1 FROM customerinfo LEFT JOIN salesinfoON customerinfo.CustomerID=salesinfo.CustomerID WHERE salesinfo.CustomerID IS NULL 4. 优化union查询 MySQL通过创建并填充临时表的方式来执行union查询。除非确实要消除重复的行，否则建议使用union all。原因在于如果没有all这个关键词，MySQL会给临时表加上distinct选项，这会导致对整个临时表的数据做唯一性校验，这样做的消耗相当高。\n高效：\nSELECT COL1, COL2, COL3 FROM TABLE WHERE COL1 = 10 UNION ALL SELECT COL1, COL2, COL3 FROM TABLE WHERE COL3= \u0026#39;TEST\u0026#39;; 低效：\nSELECT COL1, COL2, COL3 FROM TABLE WHERE COL1 = 10 UNION SELECT COL1, COL2, COL3 FROM TABLE WHERE COL3= \u0026#39;TEST\u0026#39;; 5. 拆分复杂SQL为多个小SQL，避免大事务 简单的SQL容易使用到MySQL的QUERY CACHE； 减少锁表时间特别是使用MyISAM存储引擎的表； 可以使用多核CPU。 6. 使用truncate代替delete 当删除全表中记录时，使用delete语句的操作会被记录到undo块中，删除记录也记录binlog，当确认需要删除全表时，会产生很大量的binlog并占用大量的undo数据块，此时既没有很好的效率也占用了大量的资源。\n使用truncate替代，不会记录可恢复的信息，数据不能被恢复。也因此使用truncate操作有其极少的资源占用与极快的时间。另外，使用truncate可以回收表的水位，使自增字段值归零。\n7. 使用合理的分页方式以提高分页效率 使用合理的分页方式以提高分页效率 针对展现等分页需求，合适的分页方式能够提高分页的效率。\n案例1：\nselect * from t where thread_id = 10000 and deleted = 0 order by gmt_create asc limit 0, 15; 上述例子通过一次性根据过滤条件取出所有字段进行排序返回。数据访问开销=索引IO+索引全部记录结果对应的表数据IO。因此，该种写法越翻到后面执行效率越差，时间越长，尤其表数据量很大的时候。\n适用场景：当中间结果集很小（10000行以下）或者查询条件复杂（指涉及多个不同查询字段或者多表连接）时适用。\n案例2：\nselect t.* from (select id from t where thread_id = 10000 and deleted = 0 order by gmt_create asc limit 0, 15) a, t where a.id = t.id; 上述例子必须满足t表主键是id列，且有覆盖索引secondary key:(thread_id, deleted, gmt_create)。通过先根据过滤条件利用覆盖索引取出主键id进行排序，再进行join操作取出其他字段。数据访问开销=索引IO+索引分页后结果（例子中是15行）对应的表数据IO。因此，该写法每次翻页消耗的资源和时间都基本相同，就像翻第一页一样。\n适用场景：当查询和排序字段（即where子句和order by子句涉及的字段）有对应覆盖索引时，且中间结果集很大的情况时适用。\n建表优化 在表中建立索引，优先考虑where、order by使用到的字段 尽量使用数字型字段（如性别，男：1 女：2），若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会 逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了 查询数据量大的表会造成查询缓慢。主要的原因是扫描行数过多。这个时候可以通过程序，分段分页进行查询，循环遍历，将结果合并处理进行展示。要查询100000到100050的数据: SELECT * FROM (SELECT ROW_NUMBER() OVER(ORDER BY ID ASC) AS rowid,* FROM infoTab)t WHERE t.rowid \u0026gt; 100000 AND t.rowid \u0026lt;= 100050 用varchar/nvarchar 代替 char/nchar 尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。 不要以为 NULL 不需要空间，比如：char(100) 型，在字段建立时，空间就固定了， 不管是否插入值（NULL也包含在内），都是占用 100个字符的空间的，如果是varchar这样的变长字段， null 不占用空间。 ","permalink":"https://lesanouo.github.io/blog/posts/knowledge/database/","summary":"\u003ch1 id=\"索引\"\u003e索引\u003c/h1\u003e\n\u003ch2 id=\"mysql-索引\"\u003eMySQL 索引\u003c/h2\u003e\n\u003cp\u003eMySQL 的索引有两种分类方式：逻辑分类和物理分类\u003c/p\u003e\n\u003ch3 id=\"逻辑分类\"\u003e逻辑分类\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e主键索引：一张表只能有一个主键索引，不允许重复、不允许为 NULL\u003c/li\u003e\n\u003cli\u003e唯一索引：数据列不允许重复，允许为 NULL 值，一张表可有多个唯一索引，索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一\u003c/li\u003e\n\u003cli\u003e普通索引：一张表可以创建多个普通索引，一个普通索引可以包含多个字段，允许数据重复，允许 NULL 值插入\u003c/li\u003e\n\u003cli\u003e全文索引：它查找的是文本中的关键词，主要用于全文检索\u003c/li\u003e\n\u003cli\u003e单例索引：一个索引只包含一个列，一个表可以有多个单例索引\u003c/li\u003e\n\u003cli\u003e组合索引：一个组合索引包含两个或两个以上的列。查询的时候遵循 mysql 组合索引的 “最左前缀”原则，即使用 where 时条件要按照建立索引的时候字段的排列方式放置索引才会生效\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"物理分类\"\u003e物理分类\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e聚簇索引：不是单独的一种索引类型，而是一种数据存储方式。这种存储方式是依靠B+树来实现的，根据表的主键构造一棵B+树且B+树叶子节点存放的都是表的行记录数据时，方可称该主键索引为聚簇索引。聚簇索引也可理解为将数据存储与索引放到了一块，找到索引也就找到了数据。\u003c/li\u003e\n\u003cli\u003e非聚簇索引：数据和索引是分开的，B+树叶子节点存放的不是数据表的行记录\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"explain\"\u003eEXPLAIN\u003c/h3\u003e\n\u003cp\u003e使用格式：\u003ccode\u003eEXPLAIN SQL...\u003c/code\u003e;\u003c/p\u003e","title":"数据库优化"},{"content":"生产者消费者问题（Producer-consumer problem），也称有限缓冲问题（Bounded-buffer problem），是一个多线程同步问题的经典案例。生产者生成一定量的数据放到缓冲区中，然后重复此过程；与此同时，消费者也在缓冲区消耗这些数据。生产者和消费者之间必须保持同步，要保证生产者不会在缓冲区满时放入数据，消费者也不会在缓冲区空时消耗数据。不够完善的解决方法容易出现死锁的情况，此时进程都在等待唤醒。\n下图为生产者和消费者的示意图： 解决思想 保证同一资源被多个线程并发访问时的完整性。常用的同步方法是采用信号或加锁机制，保证资源在任意时刻至多被一个线程访问\nJava实现的几种方式 wait() / notify() 方法 await() / signal() 方法(可重入锁ReentrantLock) BlockingQueue 阻塞队列方法 信号量方法 管道方法 代码实现 wait() / notify() 方法 首先，先介绍一下 Thread.sleep()和 Object.wait()、Object.notify()的区别。\nsleep()是Thread类的方法；而 wait()，notify()，notifyAll()是Object类中定义的方法；尽管这两个方法都会影响线程的执行行为，但是本质上是有区别的 Thread.sleep()不会导致锁行为的改变，如果当前线程是拥有锁的，那么 Thread.sleep()不会让线程释放锁。如果能够帮助你记忆的话，可以简单认为和锁相关的方法都定义在Object类中，因此调用 Thread.sleep()是不会影响锁的相关行为 Thread.sleep和 Object.wait都会暂停当前的线程，对于CPU资源来说，不管是哪种方式暂停的线程，都表示它暂时不再需要CPU的执行时间。OS会将执行时间分配给其它线程。区别是调用wait后，需要别的线程执行notify/notifyAll才能够重新获得CPU执行时间 Thread.sleep()让线程从 【running】 -\u0026gt; 【阻塞态】 时间结束/interrupt -\u0026gt; 【runnable】;Object.wait()让线程从 【running】 -\u0026gt; 【等待队列】notify -\u0026gt; 【锁池】 -\u0026gt; 【runnable】 wait()和notify()方法的实现，缓冲区满和为空时都调用wait()方法等待，当生产者生产了一个数据或者消费者消费了一个数据之后会通过notify()唤醒所有线程。\nimport java.util.*; public class Test { // 缓冲区最大容量 private static final int MAX_SIZE = 100; // 计数 private static int count = 0; // 缓冲区 private static LinkedList\u0026lt;Integer\u0026gt; list = new LinkedList\u0026lt;Integer\u0026gt;(); public static void main(String[] args) { Thread producer = new Thread(new Producer()); Thread consumer = new Thread(new Consumer()); producer.start(); consumer.start(); } // 生产者 public static class Producer implements Runnable { @Override public void run() { while (true) { // 为list上锁 synchronized (list) { // 缓冲区满时，等待 while (list.size() == MAX_SIZE) { try { System.out.println(\u0026#34;list is full, Producer waiting\u0026#34;); list.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } // 生产数据 count++; System.out.println(\u0026#34;Producer produce \u0026#34; + count); list.add(count); // 唤醒消费者 list.notifyAll(); // 等待一段时间再生产 try { Thread.sleep(new Random().nextInt(1000)); } catch (InterruptedException e) { e.printStackTrace(); } } // 当生产100个数就结束 if (count == 100) { break; } } } } // 消费者 public static class Consumer implements Runnable { @Override public void run() { while (true) { // 为list上锁 synchronized (list) { // 缓冲区空时，等待 while (list.isEmpty()) { try { System.out.println(\u0026#34;list is empty, Consumer waiting\u0026#34;); list.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } // 消费数据 int temp = list.poll(); System.out.println(\u0026#34;Consumer consume \u0026#34; + temp); // 唤醒生产者 list.notifyAll(); } // 当消费100个数就结束 if (count == 100 \u0026amp;\u0026amp; list.isEmpty()) { break; } } } } } 执行结果如下： 注意：\nnotifyAll()方法可使所有正在等待队列中等待同一共享资源的“全部”线程从等待状态退出，进入可运行状态。此时，优先级最高的那个线程最先执行，但也有可能是随机执行的，这要取决于JVM虚拟机的实现。即最终也只有一个线程能被运行，上述线程优先级都相同，每次运行的线程都不确定是哪个，后来给线程设置优先级后也跟预期不一样，还是要看JVM的具体实现吧。\nawait() / signal() 方法(可重入锁ReentrantLock) 在JDK5.0之后，Java提供了更加健壮的线程处理机制，包括同步、锁定、线程池等，它们可以实现更细粒度的线程控制。用ReentrantLock和Condition可以实现等待/通知模型，具有更大的灵活性。通过在Lock对象上调用newCondition()方法，将条件变量和一个锁对象进行绑定，进而控制并发程序访问竞争资源的安全。\nCondition接口的await()和signal()就是其中用来做同步的两种方法，它们的功能基本上和Object的wait()/ nofity()相同，完全可以取代它们，但是它们和新引入的锁定机制Lock直接挂钩，具有更大的灵活性。通过在Lock对象上调用newCondition()方法，将条件变量和一个锁对象进行绑定，进而控制并发程序访问竞争资源的安全。\nimport java.util.*; import java.util.concurrent.locks.*; public class Test1 { private static final int MAX_SIZE = 100; private static int count = 0; private static LinkedList\u0026lt;Integer\u0026gt; list = new LinkedList\u0026lt;Integer\u0026gt;(); // 创建锁及其条件 private static final Lock lock = new ReentrantLock(); private static final Condition fullCondition = lock.newCondition(); private static final Condition emptyCondition = lock.newCondition(); public static void main(String[] args) { Thread producer = new Thread(new Producer()); Thread consumer = new Thread(new Consumer()); producer.start(); consumer.start(); } public static class Producer implements Runnable { @Override public void run() { while (true) { // 上锁 lock.lock(); try { // 缓冲区满时，等待 while (list.size() == MAX_SIZE) { try { System.out.println(\u0026#34;list is full, Producer waiting\u0026#34;); fullCondition.await(); } catch (InterruptedException e) { e.printStackTrace(); } } // 生产数据 count++; System.out.println(\u0026#34;Producer produce \u0026#34; + count); list.add(count); // 唤醒消费者 emptyCondition.signalAll(); } finally { lock.unlock(); } try { Thread.sleep(new Random().nextInt(1000)); } catch (InterruptedException e) { e.printStackTrace(); } if (count == 100) { break; } } } } public static class Consumer implements Runnable { @Override public void run() { while (true) { // 上锁 lock.lock(); try { // 缓冲区空时，等待 while (list.isEmpty()) { try { System.out.println(\u0026#34;list is empty, Consumer waiting\u0026#34;); emptyCondition.await(); } catch (InterruptedException e) { e.printStackTrace(); } } // 消费数据 int temp = list.poll(); System.out.println(\u0026#34;Consumer consume \u0026#34; + temp); // 唤醒生产者 fullCondition.signalAll(); } finally { lock.unlock(); } if (count == 100 \u0026amp;\u0026amp; list.isEmpty()) { break; } } } } } 运行结果如下：（与第一种方法类似） BlockingQueue 阻塞队列方法 JDK 1.5 以后新增的 java.util.concurrent包新增了 BlockingQueue 接口。并提供了如下几种阻塞队列实现：\njava.util.concurrent.ArrayBlockingQueue java.util.concurrent.LinkedBlockingQueue java.util.concurrent.SynchronousQueue java.util.concurrent.PriorityBlockingQueue 实现生产者-消费者模型使用 ArrayBlockingQueue或者 LinkedBlockingQueue即可。\n我们这里使用LinkedBlockingQueue，它是一个已经在内部实现了同步的队列，实现方式采用的是我们第2种await()/ signal()方法。它可以在生成对象时指定容量大小。它用于阻塞操作的是put()和take()方法。\nput()方法：类似于我们上面的生产者线程，容量达到最大时，自动阻塞。 take()方法：类似于我们上面的消费者线程，容量为0时，自动阻塞。\nimport java.util.*; import java.util.concurrent.LinkedBlockingQueue; public class Test2 { private static final int MAX_SIZE = 100; private static int count = 0; // 创建阻塞队列 private static LinkedBlockingQueue\u0026lt;Integer\u0026gt; blockingQueue = new LinkedBlockingQueue\u0026lt;Integer\u0026gt;(MAX_SIZE); public static void main(String[] args) { Thread producer = new Thread(new Producer()); Thread consumer = new Thread(new Consumer()); producer.start(); consumer.start(); } public static class Producer implements Runnable { @Override public void run() { while (true) { try { count++; // 生产数据到阻塞队列 blockingQueue.put(count); System.out.println(\u0026#34;Producer produce \u0026#34; + count); } catch (InterruptedException e) { e.printStackTrace(); } try { Thread.sleep(new Random().nextInt(1000)); } catch (InterruptedException e) { e.printStackTrace(); } if (count == 100) { break; } } } } public static class Consumer implements Runnable { @Override public void run() { while (true) { try { // 从阻塞队列消费数据 int value = blockingQueue.take(); System.out.println(\u0026#34;Consumer consume \u0026#34; + value); } catch (InterruptedException e) { e.printStackTrace(); } if (count == 100 \u0026amp;\u0026amp; blockingQueue.isEmpty()) { break; } } } } } 信号量方法 Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源，在操作系统中是一个非常重要的问题，可以用来解决哲学家就餐问题。Java中的Semaphore维护了一个许可集，一开始先设定这个许可集的数量，可以使用acquire()方法获得一个许可，当许可不足时会被阻塞，release()添加一个许可。\nSemaphore可以用来构建一些对象池，资源池之类的，比如数据库连接池，我们也可以创建计数为1的Semaphore，将其作为一种类似互斥锁的机制，这也叫二元信号量，表示两种互斥状态。\n在下列代码中，还加入了另外一个mutex信号量，维护生产者消费者之间的同步关系，保证生产者和消费者之间的交替进行\nimport java.util.*; import java.util.concurrent.Semaphore; public class Test3 { private static final int MAX_SIZE = 100; private static int count = 0; private static LinkedList\u0026lt;Integer\u0026gt; list = new LinkedList\u0026lt;Integer\u0026gt;(); // 创建信号量 final static Semaphore notFull = new Semaphore(MAX_SIZE); final static Semaphore notEmpty = new Semaphore(0); final static Semaphore mutex = new Semaphore(1); public static void main(String[] args) { Thread producer = new Thread(new Producer()); Thread consumer = new Thread(new Consumer()); producer.start(); consumer.start(); } public static class Producer implements Runnable { @Override public void run() { while (true) { try { // 获取许可 notFull.acquire(); mutex.acquire(); // 生产数据 count++; list.add(count); System.out.println(\u0026#34;Producer produce \u0026#34; + count); } catch (InterruptedException e) { e.printStackTrace(); } finally { // 释放许可 mutex.release(); notEmpty.release(); } try { Thread.sleep(new Random().nextInt(1000)); } catch (InterruptedException e) { e.printStackTrace(); } if (count == 100) { break; } } } } public static class Consumer implements Runnable { @Override public void run() { while (true) { try { // 获取许可 notEmpty.acquire(); mutex.acquire(); // 消费数据 int value = list.poll(); System.out.println(\u0026#34;Consumer consume \u0026#34; + value); } catch (InterruptedException e) { e.printStackTrace(); } finally { // 释放许可 mutex.release(); notFull.release(); } if (count == 100 \u0026amp;\u0026amp; list.isEmpty()) { break; } } } } } 管道方法 在java的io包下，PipedOutputStream和PipedInputStream分别是管道输出流和管道输入流。\n它们的作用是让多线程可以通过管道进行线程间的通讯。在使用管道通信时，必须将PipedOutputStream和PipedInputStream配套使用。\n使用方法：先创建一个管道输入流和管道输出流，然后将输入流和输出流进行连接，用生产者线程往管道输出流中写入数据，消费者在管道输入流中读取数据，这样就可以实现了不同线程间的相互通讯。\n但是这种方式在生产者和生产者、消费者和消费者之间不能保证同步，也就是说在一个生产者和一个消费者的情况下是可以生产者和消费者之间交替运行的，多个生成者和多个消费者者之间则不行。\n这种方式只适用于两个线程之间通信，不适合多个线程之间通信。\nimport java.io.IOException; import java.io.PipedInputStream; import java.io.PipedOutputStream; import java.util.*; public class Test4 { // 控制生产和消费个100次 private static int countP = 0; private static int countS = 0; // 创建管道输入流和管道输出流 final static PipedInputStream pis = new PipedInputStream(); final static PipedOutputStream pos = new PipedOutputStream(); // 将输入流和输出流进行连接 static { try { pis.connect(pos); } catch (IOException e) { e.printStackTrace(); } } public static void main(String[] args) { Thread producer = new Thread(new Producer()); Thread consumer = new Thread(new Consumer()); producer.start(); consumer.start(); } public static class Producer implements Runnable { @Override public void run() { try { while (true) { // 写入数据 countP++; pos.write(countP); pos.flush(); System.out.println(\u0026#34;Producer produce \u0026#34; + countP); Thread.sleep(new Random().nextInt(1000)); if (countP == 100) { break; } } } catch (Exception e) { e.printStackTrace(); } finally { try { // 关闭输出流 pos.close(); } catch (IOException e) { e.printStackTrace(); } } } } public static class Consumer implements Runnable { @Override public void run() { try { while (true) { // 读取数据 countS++; int value = pis.read(); System.out.println(\u0026#34;Consumer consume \u0026#34; + value); if (countS == 100) { break; } } } catch (IOException e) { e.printStackTrace(); } finally { try { // 关闭输入流 pis.close(); } catch (IOException e) { e.printStackTrace(); } } } } } ","permalink":"https://lesanouo.github.io/blog/posts/knowledge/producer-consumer-problem/","summary":"\u003cp\u003e生产者消费者问题（Producer-consumer problem），也称有限缓冲问题（Bounded-buffer problem），是一个多线程同步问题的经典案例。生产者生成一定量的数据放到缓冲区中，然后重复此过程；与此同时，消费者也在缓冲区消耗这些数据。生产者和消费者之间必须保持同步，要保证生产者不会在缓冲区满时放入数据，消费者也不会在缓冲区空时消耗数据。不够完善的解决方法容易出现死锁的情况，此时进程都在等待唤醒。\u003c/p\u003e","title":"生产者与消费者问题"},{"content":"在进行华为机试时遇到了报数游戏的编程题（约瑟夫环），但是看了很多网上的解题都非常长，于是经过不断的学习参考，有了下面这个解题方法，也不知道是不是最好的😭\n题目：\n100个人围成一圈，每个人有一个编码，编号从1开始到100.他们从1开始依次报数，报到为M的人自动退出圈圈，然后下一个人接着从1开始报数，直到剩余的人数小于M。请问最后剩余的人在原先的编号为多少？\n例如：输入M=3时，输出为：“58，91”；输入M=4时，输出为： “34，45， 97”\n解答：\nimport java.util.*; public class test { public static void main(String[] args) { Scanner in = new Scanner(System.in); int n = in.nextInt(); List list = new ArrayList\u0026lt;Integer\u0026gt;(100); for (int i = 1; i \u0026lt;= 100; i++) { list.add(i); } int i = 0; while (list.size() \u0026gt;= n) { i = (i + n - 1) % list.size(); list.remove(i); } list.stream().forEach(System.out::println); } } ","permalink":"https://lesanouo.github.io/blog/posts/algorithm/huawei-counting-game/","summary":"\u003cp\u003e在进行华为机试时遇到了报数游戏的编程题（约瑟夫环），但是看了很多网上的解题都非常长，于是经过不断的学习参考，有了下面这个解题方法，也不知道是不是最好的😭\u003c/p\u003e","title":"华为机试题：报数游戏"},{"content":"在 web 软件开发中，API接口管理非常重要，也是前后端对接的关键，这里分享一个非常好用且可以私有化部署的接口管理系统Yapi，对那些内网开发的小伙伴们是一个不错的选择。\nYapi简介 Yapi 由 YMFE 开源，旨在为开发、产品、测试人员提供更优雅的接口管理服务，可以帮助开发者轻松创建、发布、维护 API\n权限管理 YApi 成熟的团队管理扁平化项目权限配置满足各类企业的需求\n可视化接口管理 基于 websocket 的多人协作接口编辑功能和类 postman 测试工具，让多人协作成倍提升开发效率\nMock Server 易用的 Mock Server，再也不用担心 mock 数据的生成了\n自动化测试 完善的接口自动化测试,保证数据的正确性\n数据导入 支持导入 swagger, postman, har 数据格式，方便迁移旧项目\n插件机制 强大的插件机制，满足各类业务需求\nYapi使用Docker安装 由于内网开发环境，导致安装各种环境或者系统非常不方便，所以个人比较推荐通过docker来安装\n拉取镜像 docker pull registry.cn-hangzhou.aliyuncs.com/anoy/yapi\n创建挂载目录 mkdir -p /data/yapi/mongodata\n运行专用mongo（也可以放在已有的mongo） docker run -d --name yapimongo --restart always -v /data/yapi/mongodata:/data/db mongo\n初始化 Yapi 数据库索引及管理员账号 docker run -it --rm --link yapimongo:mongo --entrypoint npm --workdir /api/vendors registry.cn-hangzhou.aliyuncs.com/anoy/yapi run install-server\n--rm：在 Docker 容器退出时，默认容器内部的文件系统仍然被保留，以方便调试并保留用户数据。但是，对于 foreground 容器，由于其只是在开发调试过程中短期运行，其用户数据并无保留的必要，因而可以在容器启动时设置 \u0026ndash;rm 选项，这样在容器退出时就能够自动清理容器内部的文件系统\n--entrypoint：类似于 CMD 指令，但其不会被 docker run 的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序。但是, 如果运行 docker run 时使用了 \u0026ndash;entrypoint 选项，将覆盖 ENTRYPOINT 指令指定的程序\n--workdir：指定工作目录。用 WORKDIR 指定的工作目录，会在构建镜像的每一层中都存在\nrun：用于执行后面跟着的命令行命令\n创建Yapi容器并启动 docker run -d --name yapi --restart=always --link yapimongo:mongo --workdir /api/vendors -p 3001:3000 registry.cn-hangzhou.aliyuncs.com/anoy/yapi server/app.js\n--link：用于容器直接的互通\n使用Yapi 访问 http://localhost:3000 登录账号 admin@admin.com，密码 ymfe.org\nYapi配置 # 进入Yapi容器中 docker exec -it yapi /bin/bash # 修改配置文件 vi ../config.json # 修改内容如下 { \u0026#34;port\u0026#34;: \u0026#34;3000\u0026#34;, \u0026#34;adminAccount\u0026#34;: \u0026#34;admin@admin.com\u0026#34;, \u0026#34;closeRegister\u0026#34;:true, # 配置禁用注册，主要是添加这句配置 \u0026#34;db\u0026#34;: { # 配置MongoDB \u0026#34;servername\u0026#34;: \u0026#34;mongo\u0026#34;, \u0026#34;DATABASE\u0026#34;: \u0026#34;yapi\u0026#34;, \u0026#34;port\u0026#34;: 27017 } } # 退出 exit # 重启容器 docker restart yapi 本文参考：\ndocker安装yapi\n具体使用可参考官方教程\n","permalink":"https://lesanouo.github.io/blog/posts/share/yapi/","summary":"\u003cp\u003e在 web 软件开发中，API接口管理非常重要，也是前后端对接的关键，这里分享一个非常好用且可以私有化部署的接口管理系统Yapi，对那些内网开发的小伙伴们是一个不错的选择。\u003c/p\u003e","title":"分享可私有部署的接口管理系统Yapi"},{"content":"本篇文章记录本人搭建CI\u0026amp;CD实现持续集成和持续部署\n1.使用docker安装gitlab 下载镜像 （使用中文社区版） docker pull twang2218/gitlab-ce-zh\n创建所需目录为后续挂载文件 进入所需目录后，打开PowerShell，通过以下命令进行目录创建\nmkdir -p gitlab/etc 、 mkdir -p gitlab/etc 、 mkdir -p gitlab/etc\n目录结构如下图所示\n启动容器 镜像下载完成后可通过 docker images查看下载结果，再通过镜像启动为容器\ndocker run -d -p 9443:443 -p 9080:80 -p 9022:22 --restart always --name testgitlab -v D:\\testgitlab\\gitlab\\etc:/etc/gitlab -v D:\\testgitlab\\gitlab\\log:/var/log/gitlab -v D:\\testgitlab\\gitlab\\data:/var/opt/gitlab --privileged=true twang2218/gitlab-ce-zh # 执行完成后会返回一串字符串 其中：\n-d：后台执行\n-p：端口映射\n--restart：重启机制\n--name：容器名称\n-v：挂载文件，使得容器内文件在宿主机内有映射\n--privileged：使得容器获取宿主机root权限\n进入容器，修改配置 输入命令 docker exec -it testgitlab bash 即可进入刚刚创建好的容器\n1.修改 gitlab.rb配置的两种方式：1. 进入挂载好的etc目录下找到 gitlab.rb文件进行修改；2. 通过进入容器内进行命令行 vi /etc/gitlab/gitlab.rb 修改\n# 整个gitlab.rb都是注释了的，我们可以按需加入我们的配置\r# 1. gitlab访问地址，可以写域名。如果端口不写的话默认为80端口\reaxternal_url \u0026#39;http://192.168.3.12:9080\u0026#39;\r# 2. ssh主机ip\rgitlab_rails[\u0026#39;gitlab_ssh_host\u0026#39;] = \u0026#39;192.168.3.12\u0026#39;\r# 3. ssh连接端口\rgitlab_rails[\u0026#39;gitlab_shell_ssh_port\u0026#39;] = 9022\r# 4. 防止内存占用过大，限制线程数\runicorn[\u0026#39;worker_processes\u0026#39;] = 2 2.修改 gitlab.yml配置（这一步原本不是必须的，因为 gitlab.rb内配置会覆盖这个，为了防止没有成功覆盖所以我在这里进行配置，当然你也可以选择不修改 gitlab.rb直接修改这里）\n通过命令行 vi /opt/gitlab/embedded/service/gitlab-rails/config/gitlab.yml修改，或者找到挂载文件修改\n修改上图红框配置\n3.让修改后的配置生效，并重启\ngitlab-ctl reconfigure 、 gitlab-ctl restart 、 exit（退出容器命令行）\n或者重启容器 docker restart testgitlab\n访问gitlab 输入http://192.168.3.12:9080打开页面（ip请输入前面设置的），默认账户root，密码需要重新设置至少8位\n2.使用docker安装jenkins 下载镜像 docker pull jenkins/jenkins\n创建所需目录为后续挂载文件 在服务器上先创建一个jenkins工作目录 /var/jenkins_mount，赋予相应权限，稍后我们将jenkins容器目录挂载到这个目录上，这样我们就可以很方便地对容器内的配置文件进行修改。如何后续在容器内修改的话会非常麻烦，由于容器中无vi命令。\nmkdir -p /var/jenkins_mount 、 chmod 777 /var/jenkins_mount\n启动容器 docker run -d -p 10240:8080 -p 10241:50000 -v D:\\testjenkins\\jenkins_mount:/var/jenkins_home -v /etc/localtime:/etc/localtime --name testjenkins jenkins/jenkins # 其中-v /etc/localtime:/etc/localtime让容器使用和服务器同样的时间设置 可以通过 docker ps来查看启动情况\n可以通过 docker logs testjenkins来查看容器日志\n修改配置 进入刚刚挂载的文件，修改 hudson.model.UpdateCenter.xml文件\n将 url 修改为 清华大学官方镜像：https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json ，配置镜像加速\n还需要修改 default.json文件，位置为 cd /var/jenkins_home/updates\n使用sed命令修改 default.json\nlinux下：\nsed -i \u0026#39;s/http:\\/\\/updates.jenkins-ci.org\\/download/https:\\/\\/mirrors.tuna.tsinghua.edu.cn\\/jenkins/g\u0026#39; default.json \u0026amp;\u0026amp; sed -i \u0026#39;s/http:\\/\\/www.google.com/https:\\/\\/www.baidu.com/g\u0026#39; default.json mac下：\nsed -i \u0026#34;\u0026#34; \u0026#39;s/http:\\/\\/updates.jenkins-ci.org\\/download/https:\\/\\/mirrors.tuna.tsinghua.edu.cn\\/jenkins/g\u0026#39; default.json \u0026amp;\u0026amp; sed -i \u0026#34;\u0026#34; \u0026#39;s/http:\\/\\/www.google.com/https:\\/\\/www.baidu.com/g\u0026#39; default.json 重启容器 docker restart testjenkins\n访问jenkins 输入http://localhost:10240打开页面\n选择默认插件安装即可\n3.gitlab + jenkins 为了实现自动持续构建, 不需要人工操作 ( 留人工操作用于处理特殊情况 )，通过gitlab+jenkins实现CI\u0026amp;CD，具体流程如下\n开发提交代码 开发对需要发布的版本打上 Tag 触发 GitLab 的 tag push 事件, 调用 Webhook Webhook 触发 Jenkins 的构建任务 Jenkins 构建完项目可以按版本号上传到仓库、部署、通知相关人员等等 配置gitlab 建一个测试项目 test ，随便 commit 一些内容，比如通过网页添加 README.md 创建账号的 access token ，用于 Jenkins 调用 GitLab 的 API 记下生成的 access token , 后面需要用到！！！且它只会展示一次，请记录好！！！ 配置jenkins 安装环境所需插件 Git Parameter ( 用于参数化构建中动态获取项目分支 ) Generic Webhook Trigger ( 用于解析 Webhook 传过来的参数 ) GitLab ( 用于推送构建结果给 GitLab ) 添加 GitLab 凭据 在系统配置中配置gitlab 创建新的FreeStyle任务 General 勾选 参数化构建过程, 添加 Git Parameter 类型的参数 ref , 这样构建的时候就可以指定分支进行构建\n源码管理 选择 Git , 添加项目地址和授权方式 ( 帐号密码 或者 ssh key ) , 分支填写构建参数 $ref\n构建触发器 选择 Generic Webhook Trigger 方式用于解析 GitLab 推过来的详细参数 ( jsonpath 在线测试 ) 。其他触发方式中: Trigger builds remotely 是 Jenkins 自带的, Build when a change is pushed to GitLab 是 GitLab 插件 提供的, 都属于简单的触发构建, 无法做复杂的处理\nOptional filter 虽然 Generic Webhook Trigger 提供了 Token 参数进行鉴权, 但为了避免不同项目进行混调 ( 比如 A 项目提交代码却触发了 B 项目的构建) , 还要对请求做下过滤。Optional filter 中 Text 填写需要校验的内容 ( 可使用变量 ) , Expression 使用正则表达式对 Text 进行匹配, 匹配成功才允许触发构建\n构建 构建内容按自己实际的项目类型进行调整, 使用 Maven 插件 或 脚本 等等\n构建后操作 构建后操作添加 Publish build status to GitLab 动作, 实现构建结束后通知构建结果给 GitLab\n在GitLab的项目页面中, 添加一个Webhook 添加一个 Webhook ( http://JENKINS_URL/generic-webhook-trigger/invoke?token=\u0026lt;上面 Jenkins 项目配置中的 token\u0026gt; ) , 触发器选择 标签推送事件。因为日常开发中 push 操作比较频繁而且不是每个版本都需要构建, 所以只针对需要构建的版本打上 Tag 就好了\nhttp://172.20.10.7:10240//generic-webhook-trigger/invoke?token=d63ad84eb18cb04d4459ec347a196dce\n创建完使用 test 按钮 先测试下, 可能会出现下面的错误\nRequests to the local network are not allowed 通过下面方法解决\n测试效果 将代码拉下来在本地操作通过IDEA进行操作\n然后使用快捷键 Cmd + Shift + K 调出 Push 窗口 , 把 Tag 推送到 GitLab 中\n回到 GitLab 页面可以看到触发了 Webhook , View details 查看请求详情, Response body 中 triggered 字段值为 true 则表示成功触发了 Jenkins 进行构建\n注意: 每添加一个 Tag 就会触发一次事件, 不管是不是一起 push 的。所以一次 push 多个 Tag 会触发 Jenkins 进行多次构建。不过 Jenkins 已经做了处理, 默认串行执行任务 ( 一个任务结束再执行下一个 ) , 而且在构建前有一个 pending 状态, 此时被多次触发会进行合并, 并取首次触发的参数, 如下图所示:\n关于 Tag 的几点说明 推送 Tag 到远端的时候, 远端已存在 ( 同名 ) 的 Tag 不会被添加到远端 拉取远端的 Tag 时, 本地已存在 ( 同名 ) 的 Tag 不会添加到本地 拉取远端的 Tag 时, 本地不会删除远端已删除的 Tag , 需要同步远端的 Tag 可以先删除本地所有 Tag 再 pull 删除 Tag 也会推送事件, 要做好过滤 ( 上面配置中已使用 commitsId 字段进行过滤 ) 本篇文章产考下列文章：\ndocker安装gitlab\ndocker安装jenkins\ndocker中jenkins插件加速\n整合gitlab+jenkins\n","permalink":"https://lesanouo.github.io/blog/posts/operation/ci-cd-gitlab-jenkins/","summary":"\u003cp\u003e本篇文章记录本人搭建CI\u0026amp;CD实现持续集成和持续部署\u003c/p\u003e\n\u003ch2 id=\"1使用docker安装gitlab\"\u003e1.使用docker安装gitlab\u003c/h2\u003e\n\u003ch3 id=\"下载镜像-使用中文社区版\"\u003e下载镜像 （使用中文社区版）\u003c/h3\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/blog/posts/operation/ci-cd-gitlab-jenkins/images/1.png\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003edocker pull twang2218/gitlab-ce-zh\u003c/code\u003e\u003c/p\u003e\n\u003ch3 id=\"创建所需目录为后续挂载文件\"\u003e创建所需目录为后续挂载文件\u003c/h3\u003e\n\u003cp\u003e进入所需目录后，打开PowerShell，通过以下命令进行目录创建\u003c/p\u003e","title":"记一次搭建GitLab+Jenkins实现CI\u0026CD"},{"content":"默认.NET的Docker镜像是不包含libgdiplus的，所以本文介绍如何通过在原有镜像基础上构建一个满足个人需求的Docker镜像。\nDocker 简介 Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。\nDocker 的应用场景：\nWeb 应用的自动化打包和发布。 自动化测试和持续集成、发布。 在服务型环境中部署和调整数据库或其他的后台应用。 从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。 Docker 的优点：\nDocker 是一个用于开发，交付和运行应用程序的开放平台。Docker 使您能够将应用程序与基础架构分开，从而可以快速交付软件。借助 Docker，您可以与管理应用程序相同的方式来管理基础架构。通过利用 Docker 的方法来快速交付，测试和部署代码，您可以大大减少编写代码和在生产环境中运行代码之间的延迟。\n快速，一致地交付您的应用程序 响应式部署和扩展 在同一硬件上运行更多工作负载 Docker 命令 详细命令可以查看Docker 命令大全\n常用镜像命令 1. 查看服务器中 Docker 镜像列表 docker images 2. 搜索镜像 docker search 镜像名 3. 拉取镜像（不加tag(版本号)就默认拉取Docker仓库中该镜像的最新版本latest; 加:tag则是拉取指定版本） docker pull 镜像名 docker pull 镜像名:v1 4. 运行镜像 docker run -itd --name=\u0026#34;nginx\u0026#34; --restart=always -p 80:80 -v /data:/data nginx:latest 5. 删除镜像 docker rmi -f 镜像名/镜像ID 6. 保存镜像 docker save nginx -o /nginx.tar 7. 加载镜像 docker load -i 镜像文件位置 常用容器命令 1. 查看正在运行容器列表 docker ps 2. 查看所有容器 docker ps -a 3. 停止容器 docker stop 容器名/容器ID 4. 删除容器 docker rm -f 容器名/容器ID 5. 进入容器方式 docker exec -it 容器名/容器ID /bin/bash exit/ctl+p+q #退出 6. 重启容器 docker restart 容器名/容器ID 7. 启动容器 docker start 容器名/容器ID 8. kill 容器 docker kill 容器名/容器ID 9. 容器文件拷贝 docker cp 容器名/ID:容器内路径 容器外路径 #容器内拷出 docker cp 容器外路径 容器名/ID:容器内路径 #容器外拷入 10. 查看容器日志 docker logs -f --tail=100 容器 #tail查看末尾多少行 默认all 11. 修改存在容器的启动配置 docker update --restart=always 容器 12. 更换容器名 docker rename 容器 容器新名字 13. 通过容器提交镜像！！！### docker commit -a=\u0026#34;提交作者\u0026#34; -m=\u0026#34;提交信息\u0026#34; 容器 提交镜像:tag Docker 运维命令 1. 查看Docker工作目录 sudo docker info | grep \u0026#34;Docker Root Dir\u0026#34; 2. 查看Docker磁盘占用总体情况 du -hs /var/lib/docker/ 3. 查看Docker的磁盘使用具体情况 docker system df 4. 删除无用的容器和镜像 docker rm `docker ps -a | grep Exited | awk \u0026#39;{print $1}\u0026#39;` docker rmi -f `docker images | grep \u0026#39;\u0026lt;none\u0026gt;\u0026#39; | awk \u0026#39;{print $3}\u0026#39;` 5. 清除所有无容器使用的镜像 docker system prune -a 6. 查找大文件 find / -type f -size +100M -print0 | xargs -0 du -h | sort -nr 7. 查找指定Docker使用目录下大于指定大小文件 find / -type f -size +100M -print0 | xargs -0 du -h | sort -nr | grep \u0026#39;/var/lib/docker/overlap2/*\u0026#39; 构建一个带libgdiplus的DotNetCore基础镜像 通过Docker拉取一个.netcore3.1基础镜像：docker pull mcr.microsoft.com/dotnet/aspnet:3.1\n进入容器：docker run -it mcr.microsoft.com/dotnet/aspnet:3.1 /bin/bash 安装libgdiplus：\napt-get update -y apt-get install -y libgdiplus apt-get clean ln -s /usr/lib/libgdiplus.so /usr/lib/gdiplus.dll 提交为新镜像：\ndocker commit -a=\u0026quot;Lesan\u0026quot; -m=\u0026quot;added libgdiplus based on .netcore3.1\u0026quot; 28a66ebccd55 dotnetcore-with-libgdiplus:v3.1\n修改项目Dockerfile基础镜像为刚刚构建的自定义镜像 dotnetcore-with-libgdiplus:v3.1\n借鉴参考以下文章：\nhttps://blog.csdn.net/leilei1366615/article/details/106267225\nhttps://www.runoob.com/docker/docker-command-manual.html\nhttps://blog.csdn.net/u014374975/article/details/115436174\n","permalink":"https://lesanouo.github.io/blog/posts/operation/docker-images-libgdiplus-dotnet/","summary":"\u003cp\u003e默认.NET的Docker镜像是不包含libgdiplus的，所以本文介绍如何通过在原有镜像基础上构建一个满足个人需求的Docker镜像。\u003c/p\u003e\n\u003ch2 id=\"docker-简介\"\u003eDocker 简介\u003c/h2\u003e\n\u003cp\u003eDocker 是一个开源的应用容器引擎，基于 \u003cstrong\u003eGo 语言\u003c/strong\u003e 并遵从 Apache2.0 协议开源。Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。\u003c/p\u003e","title":"构建一个带libgdiplus的.NET基础Docker镜像"},{"content":"消息推送是大部分系统都需要做到的功能，在.NET中我分别通过RabbitMQ、MQTT、SignalR实现消息推送功能，本篇文章将通过它们实现简单的推送功能，手把手带大家完成编程。本文环境为 .NET Core 3.1下\nSignalR实现 简介 SignalR是一个开源的库，跨平台；让Web应用与其他应用通讯变得很简单，Web服务端可以实时的将内容推送给对应的客户端，客户端发送的信息也可以实时到其他客户端。\nSignalR提供了一种远程过程调用(RPC)的方式，使得客户端可以调用服务器的方法，同样在服务器端的方法中也能调用客户端的方法。\n示例 Nuget包为： \u0026lt;PackageReference Include=\u0026quot;Microsoft.AspNetCore.SignalR.Core\u0026quot; Version=\u0026quot;1.1.0\u0026quot; /\u0026gt;\n首先我们需要创建一个自己的SignalR Hub using Microsoft.AspNetCore.SignalR; using System.Threading.Tasks; namespace KBEAM.Hubs { public class ChatHub : Hub // 继承自SignalR Hub库 { public async Task SendMessage(string user, string message) { await Clients.All.SendAsync(\u0026#34;ReceiveMessage\u0026#34;, user, message); } public async Task SendMessageToGroup(string group, string message) { await Clients.Group(group).SendAsync(\u0026#34;ReceiveMessageFromGroup\u0026#34;, group, message); } public async Task AddToGroup(string groupName) { await Groups.AddToGroupAsync(Context.ConnectionId, groupName); await Clients.Group(groupName).SendAsync(\u0026#34;ReceiveMessage\u0026#34;, $\u0026#34;{Context.ConnectionId} has joined the group {groupName}.\u0026#34;); } public async Task RemoveFromGroup(string groupName) { await Groups.RemoveFromGroupAsync(Context.ConnectionId, groupName); //await Clients.Group(groupName).SendAsync(\u0026#34;ReceiveMessage\u0026#34;, $\u0026#34;{Context.ConnectionId} has left the group {groupName}.\u0026#34;); } } } 在Startup.cs文件中注册相关服务及管道 // 1.在ConfigureServices函数中添加以下语句，注册相关服务 services.AddSignalR(); // 2.在Configure函数中添加以下语句，配置管道终结点 app.UseEndpoints(endpoints =\u0026gt; { // ... endpoints.MapHub\u0026lt;ChatHub\u0026gt;(\u0026#34;/chatHub\u0026#34;); // ... }); 编写服务端业务，推送消息 // 定义一个上下文 private readonly IHubContext\u0026lt;ChatHub\u0026gt; hubContext; // 通过构造函数注入依赖 public MonitorService(IHubContext\u0026lt;ChatHub\u0026gt; hub) { hubContext = hub; } //在需要的地方调用方法，进行消息推送 await hubContext.Clients.Group(group).SendAsync(\u0026#34;ReceiveMessageFromGroup\u0026#34;,group, \u0026#34;需要发送的消息\u0026#34;); JS客户端程序编写 首先，需要通过npm来安装SignalR封装好的JS文件，npm install @microsoft/signalr\n// 1.首先进行SignalR客户端连接 const signalR = require(\u0026#34;@microsoft/signalr\u0026#34;) let conn = new signalR.HubConnectionBuilder() .withUrl(\u0026#34;http://localhost:8988/chatHub\u0026#34;) .withAutomaticReconnect() .configureLogging(signalR.LogLevel.Error) .build() export default conn import signalR from \u0026#34;@/utils/signalR\u0026#34;; // 2.客户端调用服务端方法（RPC） signalR.invoke(\u0026#34;AddToGroup\u0026#34;, \u0026#34;groupName\u0026#34;).catch(function (err) { // 加入用户组 return console.error(err.toString()); }); signalR.invoke(\u0026#34;RemoveFromGroup\u0026#34;, \u0026#34;大屏\u0026#34;).catch(function (err) { // 移除用户组 return console.error(err.toString()); }); // 3.客户端监听服务器消息 signalR.on(\u0026#34;ReceiveMessageFromGroup\u0026#34;, function (group, message) { console.log(group + \u0026#34; \u0026#34; + message); that.lineChartData = JSON.parse(message); }); RabbitMQ实现 简介 RabbitMQ是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件），由以高性能、健壮以及可伸缩性出名的 Erlang 写成。\n示例 首先您需要在电脑上安装好 Erlang及RabbitMQ服务器，这一步大家就自行搜索解决吧，网上应该有很多的解决方法\nRabbitMQ准备 首先开启Stomp插件\nrabbitmq-plugins enable rabbitmq_management # 开启此插件后有管理界面http://localhost:15672/ rabbitmq-plugins enable rabbitmq_web_stomp rabbitmq-plugins enable rabbitmq_web_stomp_examples 服务端发送消息 所需Nuget包： \u0026lt;PackageReference Include=\u0026quot;RabbitMQ.Client\u0026quot; Version=\u0026quot;6.2.4\u0026quot; /\u0026gt;\n// 建立RabbitMQ连接 private static readonly ConnectionFactory rabbitMqFactory = new ConnectionFactory() { HostName = \u0026#34;localhost\u0026#34;, UserName = \u0026#34;用户名\u0026#34;, Password = \u0026#34;密码\u0026#34;, Port = 5672, VirtualHost = \u0026#34;虚拟主机配置\u0026#34; }; // 发送消息 using (IConnection conn = rabbitMqFactory.CreateConnection()) { using (IModel channel = conn.CreateModel()) { channel.ExchangeDeclare(\u0026#34;monitor\u0026#34;, ExchangeType.Direct, durable: true, autoDelete: false, arguments: null); channel.QueueDeclare(\u0026#34;message\u0026#34;, durable: true, autoDelete: false, exclusive: false, arguments: null); channel.QueueBind(\u0026#34;message\u0026#34;, \u0026#34;monitor\u0026#34;, routingKey: \u0026#34;message\u0026#34;); var props = channel.CreateBasicProperties(); props.Persistent = true; channel.BasicPublish(exchange: \u0026#34;monitor\u0026#34;, routingKey: \u0026#34;message\u0026#34;, basicProperties: props, body: Encoding.UTF8.GetBytes(JsonConvert.SerializeObject(new { expectedData, actualData }))); } } 具体RabbitMQ使用可以看我的RabbitMQ学习笔记\n客户端接受消息 首先需要安装npm库文件，npm install stompjs\nimport Stomp from \u0026#34;stompjs\u0026#34;; // 定义一个RabbitMQ客户端 data() { return { client: Stomp.client(\u0026#34;ws://localhost:15674/ws\u0026#34;), }; }, // 初始化连接操作 created() { this.client.connect( \u0026#34;用户名\u0026#34;, \u0026#34;密码\u0026#34;, this.onConnected, this.onFailed, \u0026#34;虚拟主机名称\u0026#34; ); } methods: { onConnected: function () { //订阅频道 // const topic = localStorage.getItem(\u0026#34;Lesan\u0026#34;); console.log(\u0026#34;连接成功\u0026#34;); this.client.subscribe( \u0026#34;/exchange/monitor/message\u0026#34;, this.responseCallback, this.onFailed ); }, onFailed: function (frame) { console.log(\u0026#34;MQ Failed: \u0026#34; + frame); this.$message.error(\u0026#34;连接失败\u0026#34;); }, // 回传消息 responseCallback: function (frame) { console.log(\u0026#34;MQ msg=\u0026gt;\u0026#34; + frame.body); this.lineChartData = JSON.parse(frame.body); //接收消息处理 }, // 断开相应的连接 close: function () { this.client.disconnect(function () { console.log(\u0026#34;已退出账号\u0026#34;); }); }, }, MQTT实现 简介 MQTT是IBM开发的一个即时通讯协议，该协议支持所有的平台，几乎可以把所有联网的物品和外部连接起来。\n使用发布/订阅消息模式，提供一对多的消息发布，解除应用程序耦合。这一点很类似于XMPP，但是MQTT的信息冗余远小于XMPP。 使用TCP/IP提供网络连接。主流的MQTT是基于TCP连接进行数据推送的，但是同样有基于UDP的版本，叫做MQTT-SN。这两种版本由于基于不同的连接方式，优缺点自然也就各有不同了。 三种消息传输方式QoS： 0代表“至多一次”，消息发布完全依赖底层 TCP/IP 协议。会发生消息丢失或重复。这一级别可用于如下情况，环境传感器数据，丢失一次读记录无所谓，因为不久后还会有第二次发送 1代表“至少一次”，确保消息到达，但消息重复可能会发生 2代表“只有一次”，确保消息到达一次。这一级别可用于如下情况，在计费系统中，消息重复或丢失会导致不正确的结果 示例 服务端开发 所需Nuget包：\u0026lt;PackageReference Include=\u0026quot;MQTTnet.AspNetCore\u0026quot; Version=\u0026quot;3.1.2\u0026quot; /\u0026gt;\n对Program.cs修改：\npublic static IHostBuilder CreateHostBuilder(string[] args) =\u0026gt; Host.CreateDefaultBuilder(args) .ConfigureWebHostDefaults(webBuilder =\u0026gt; { webBuilder.UseKestrel(o =\u0026gt; { o.ListenAnyIP(8988); o.ListenAnyIP(1884, t =\u0026gt; t.UseMqtt()); }); webBuilder.UseStartup\u0026lt;Startup\u0026gt;(); //webBuilder.UseUrls(\u0026#34;http://0.0.0.0:8988\u0026#34;); }); 对Startup.cs修改：\n// 在ConfigureServices函数中添加 services.AddHostedMqttServer(mqttServer =\u0026gt; mqttServer.WithoutDefaultEndpoint().WithConnectionValidator(c =\u0026gt; { if (c.Username != \u0026#34;admin\u0026#34; || c.Password != \u0026#34;123456\u0026#34;) { c.ReasonCode = MqttConnectReasonCode.BadUserNameOrPassword; return; } c.ReasonCode = MqttConnectReasonCode.Success; })) .AddMqttConnectionHandler() .AddConnections(); // 在Configure函数中添加 app.UseEndpoints(endpoints =\u0026gt; { endpoints.MapConnectionHandler\u0026lt;MqttConnectionHandler\u0026gt;( \u0026#34;/mqtt\u0026#34;, httpConnectionDispatcherOptions =\u0026gt; httpConnectionDispatcherOptions.WebSockets.SubProtocolSelector = protocolList =\u0026gt; protocolList.FirstOrDefault() ?? string.Empty); }); app.UseMqttServer(S =\u0026gt; { MqttHelper.Server = S; S.ClientConnectedHandler = new MqttServerClientConnectedHandlerDelegate(OnConnected); S.StartedHandler = new MqttServerStartedHandlerDelegate(OnStarted); }); // 添加事件处理函数 private void OnStarted(EventArgs obj) { RecurringJob.AddOrUpdate\u0026lt;MonitorService\u0026gt;(\u0026#34;MonitorData\u0026#34;, p =\u0026gt; p.UpdateDataAsync(\u0026#34;大屏\u0026#34;), \u0026#34;0/15 * * * * *\u0026#34;); } private void OnConnected(MqttServerClientConnectedEventArgs args) { Console.WriteLine(args.ClientId); } // 消息推送方法 MqttHelper.PublishAsync(\u0026#34;monitor\u0026#34;, JsonConvert.SerializeObject(new { expectedData, actualData })); 添加MqttHelper类：\nusing MQTTnet.Server; using System.Text; namespace Common { public class MqttHelper { public static IMqttServer Server { get; set; } public static void PublishAsync(string topic, byte[] payload) { if (Server != null) { Server.PublishAsync(new MQTTnet.MqttApplicationMessage() { Topic = topic, Payload = payload }, new System.Threading.CancellationToken(false)); } } public static void PublishAsync(string topic, string payload) { if (Server != null) { Server.PublishAsync(new MQTTnet.MqttApplicationMessage() { Topic = topic, Payload = Encoding.UTF8.GetBytes(payload) }, new System.Threading.CancellationToken(false)); ; } } } } 客服端开发 首先需要引入npm包：npm install mqtt\nimport mqtt from \u0026#34;mqtt\u0026#34;; // 连接Mqtt服务器，并订阅消息 mounted() { let that = this; let mqttClient = mqtt.connect(\u0026#34;ws://localhost:8988/mqtt\u0026#34;, { username: \u0026#34;用户名\u0026#34;, password: \u0026#34;密码\u0026#34;, clientId: \u0026#34;客户端ID\u0026#34;, }); mqttClient.on(\u0026#34;connect\u0026#34;, (e) =\u0026gt; { console.log(\u0026#34;connected\u0026#34;, e); mqttClient.subscribe(\u0026#34;monitor\u0026#34;, { qos: 1 }, (err) =\u0026gt; { if (!err) { console.log(\u0026#34;subscribed\u0026#34;); } }); }); mqttClient.on(\u0026#34;message\u0026#34;, (topic, message) =\u0026gt; { console.log(topic, message.toString()); that.lineChartData = JSON.parse(message.toString()); }); }, 其他 Vue前端测试客户端全部代码，通过Vue-cli搭建的项目，修改App.vue即可\n\u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;img alt=\u0026#34;Vue logo\u0026#34; src=\u0026#34;./assets/logo.png\u0026#34; /\u0026gt; \u0026lt;HelloWorld msg=\u0026#34;Welcome to Your Vue.js App\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import HelloWorld from \u0026#34;./components/HelloWorld.vue\u0026#34;; import mqtt from \u0026#34;mqtt\u0026#34;; import Stomp from \u0026#34;stompjs\u0026#34;; export default { name: \u0026#34;App\u0026#34;, components: { HelloWorld, }, data() { return { rabbitClient: Stomp.client(\u0026#34;ws://172.21.30.233:15674/ws\u0026#34;), }; }, created() {}, mounted() { // this.useMqtt(); // this.useRabbitMQ(); this.useSignalR(); }, methods: { useSignalR() { const signalR = require(\u0026#34;@microsoft/signalr\u0026#34;); const conn = new signalR.HubConnectionBuilder() .withUrl(\u0026#34;http://172.21.30.233:8988/chatHub\u0026#34;) .withAutomaticReconnect() .configureLogging(signalR.LogLevel.Error) .build(); conn .start() .then(() =\u0026gt; { console.log(\u0026#34;conneted\u0026#34;); conn.invoke(\u0026#34;AddToGroup\u0026#34;, \u0026#34;大屏\u0026#34;).catch(function (err) { return console.error(err.toString()); }); conn.on(\u0026#34;ReceiveMessageFromGroup\u0026#34;, function (group, message) { console.log(group + \u0026#34; \u0026#34; + message); }); }) .catch((err) =\u0026gt; { return console.error(err.toString()); }); }, useMqtt() { let mqttClient = mqtt.connect(\u0026#34;ws://172.21.30.233:8988/mqtt\u0026#34;, { username: \u0026#34;admin\u0026#34;, password: \u0026#34;123456\u0026#34;, // clientId: \u0026#34;Lesan\u0026#34;, }); mqttClient.on(\u0026#34;connect\u0026#34;, (e) =\u0026gt; { console.log(\u0026#34;connected\u0026#34;, e); mqttClient.subscribe(\u0026#34;monitor\u0026#34;, { qos: 1 }, (err) =\u0026gt; { if (!err) { console.log(\u0026#34;subscribed\u0026#34;); } }); }); mqttClient.on(\u0026#34;message\u0026#34;, (topic, message) =\u0026gt; { console.log(topic, message.toString()); }); }, useRabbitMQ() { // this.rabbitClient.heartbeat.outgoing = 0; // this.rabbitClient.heartbeat.incoming = 0; this.rabbitClient.connect( \u0026#34;KB\u0026#34;, \u0026#34;KB\u0026#34;, this.onConnected, this.onFailed, \u0026#34;kb_monitor\u0026#34; ); }, onConnected: function () { //订阅频道 // const topic = localStorage.getItem(\u0026#34;Lesan\u0026#34;); console.log(\u0026#34;连接成功\u0026#34;); this.rabbitClient.subscribe( \u0026#34;/exchange/monitor/message\u0026#34;, this.responseCallback, this.onFailed ); }, onFailed: function (frame) { console.log(\u0026#34;MQ Failed: \u0026#34; + frame); this.$message.error(\u0026#34;连接失败\u0026#34;); }, // 回传消息 responseCallback: function (frame) { console.log(\u0026#34;MQ msg=\u0026gt;\u0026#34; + frame.body); //接收消息处理 }, // 断开相应的连接 close: function () { this.rabbitClient.disconnect(function () { console.log(\u0026#34;已退出账号\u0026#34;); }); }, }, }; \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; #app { font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px; } \u0026lt;/style\u0026gt; ","permalink":"https://lesanouo.github.io/blog/posts/knowledge/message-push/","summary":"\u003cp\u003e消息推送是大部分系统都需要做到的功能，在.NET中我分别通过RabbitMQ、MQTT、SignalR实现消息推送功能，本篇文章将通过它们实现简单的推送功能，手把手带大家完成编程。本文环境为 \u003ccode\u003e.NET Core 3.1\u003c/code\u003e下\u003c/p\u003e","title":"实现简单消息推送功能"},{"content":"Linux关机,重启 # 关机 shutdown -h now # 重启 shutdown -r now 查看系统,CPU信息 # 查看系统内核信息 uname -a # 查看系统内核版本 cat /proc/version # 查看当前用户环境变量 env cat /proc/cpuinfo # 查看有几个逻辑cpu, 包括cpu型号 cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c # 查看有几颗cpu,每颗分别是几核 cat /proc/cpuinfo | grep physical | uniq -c # 查看当前CPU运行在32bit还是64bit模式下, 如果是运行在32bit下也不代表CPU不支持64bit getconf LONG_BIT # 结果大于0, 说明支持64bit计算. lm指long mode, 支持lm则是64bit cat /proc/cpuinfo | grep flags | grep \u0026#39; lm \u0026#39; | wc -l 建立软连接 ln -s /usr/local/jdk1.8/ jdk rpm相关 # 查看是否通过rpm安装了该软件 rpm -qa | grep 软件名 sshkey # 创建sshkey ssh-keygen -t rsa -C your_email@example.com #id_rsa.pub 的内容拷贝到要控制的服务器的 home/username/.ssh/authorized_keys 中,如果没有则新建(.ssh权限为700, authorized_keys权限为600) 命令重命名 # 在各个用户的.bash_profile中添加重命名配置 alias ll=\u0026#39;ls -alF\u0026#39; 同步服务器时间 sudo ntpdate -u ntp.api.bz 后台运行 # 后台运行,并且有nohup.out输出 nohup xxx \u0026amp; # 后台运行, 不输出任何日志 nohup xxx \u0026gt; /dev/null \u0026amp; # 后台运行, 并将错误信息做标准输出到日志中 nohup xxx \u0026gt;out.log 2\u0026gt;\u0026amp;1 \u0026amp; 强制活动用户退出 # 命令来完成强制活动用户退出.其中TTY表示终端名称 pkill -kill -t [TTY] 查看命令路径 which \u0026lt;命令\u0026gt; 查看进程所有打开最大fd数 ulimit -n 配置dns vim /etc/resolv.conf nslookup,查看域名路由表 nslookup google.com last,最近登录信息列表 # 最近登录的5个账号 last -n 5 设置固定ip ifconfig em1 192.168.5.177 netmask 255.255.255.0 查看进程内加载的环境变量 # 也可以去 cd /proc 目录下, 查看进程内存中加载的东西 ps eww -p XXXXX(进程号) 查看进程树找到服务器进程 ps auwxf 查看进程启动路径 cd /proc/xxx(进程号) ls -all # cwd对应的是启动路径 添加用户,配置sudo权限 # 新增用户 useradd 用户名 passwd 用户名 #增加sudo权限 vim /etc/sudoers # 修改文件里面的 # root ALL=(ALL) ALL # 用户名 ALL=(ALL) ALL 强制关闭进程名包含xxx的所有进程 ps aux|grep xxx | grep -v grep | awk \u0026#39;{print $2}\u0026#39; | xargs kill -9 vim操作 #normal模式下 g表示全局, x表示查找的内容, y表示替换后的内容 :%s/x/y/g #normal模式下 0 # 光标移到行首(数字0) $ # 光标移至行尾 shift + g # 跳到文件最后 gg # 跳到文件头 # 显示行号 :set nu # 去除行号 :set nonu # 检索 /xxx(检索内容) # 从头检索, 按n查找下一个 ?xxx(检索内容) # 从尾部检索 打开只读文件,修改后需要保存时(不用切换用户即可保存的方式) # 在normal模式下 :w !sudo tee % 查看磁盘, 文件目录基本信息 # 查看磁盘挂载情况 mount # 查看磁盘分区信息 df # 查看目录及子目录大小 du -H -h # 查看当前目录下各个文件, 文件夹占了多少空间, 不会递归 du -sh * wc命令 # 查看文件里有多少行 wc -l filename # 看文件里有多少个word wc -w filename # 文件里最长的那一行是多少个字 wc -L filename # 统计字节数 wc -c 压缩命令 tar czvf xxx.tar 压缩目录 zip -r xxx.zip 压缩目录 解压缩命令 tar zxvf xxx.tar # 解压到指定文件夹 tar zxvf xxx.tar -C /xxx/yyy/ unzip xxx.zip 变更文件所属用户, 用户组 chown eagleye.eagleye xxx.log cp, scp, mkdir #复制 cp xxx.log # 复制并强制覆盖同名文件 cp -f xxx.log # 复制文件夹 cp -r xxx(源文件夹) yyy(目标文件夹) # 远程复制 scp -P ssh端口 username@10.10.10.101:/home/username/xxx /home/xxx # 级联创建目录 mkdir -p /xxx/yyy/zzz # 批量创建文件夹, 会在test,main下都创建java, resources文件夹 mkdir -p src/{test,main}/{java,resources} 比较两个文件 diff -u 1.txt 2.txt 日志输出的字节数,可以用作性能测试 # 如果做性能测试, 可以每执行一次, 往日志里面输出 “.” , 这样日志中的字节数就是实际的性能测试运行的次数, 还可以看见实时速率. tail -f xxx.log | pv -bt 查看, 去除特殊字符 # 查看特殊字符 cat -v xxx.sh # 去除特殊字符 sed -i \u0026#39;s/^M//g’ env.sh 去除文件的特殊字符, 比如^M: 需要这样输入: ctrl+v+enter 处理因系统原因引起的文件中特殊字符的问题 # 可以转换为该系统下的文件格式 cat file.sh \u0026gt; file.sh_bak # 先将file.sh中文件内容复制下来然后运行, 然后粘贴内容, 最后ctrl + d 保存退出 cat \u0026gt; file1.sh # 在vim中通过如下设置文件编码和文件格式 :set fileencodings=utf-8 ，然后 w （存盘）一下即可转化为 utf8 格式， :set fileformat=unix # 在mac下使用dos2unix进行文件格式化 find . -name \u0026#34;*.sh\u0026#34; | xargs dos2unix tee, 重定向的同时输出到屏幕 awk ‘{print $0}’ xxx.log | tee test.log grep # 反向匹配, 查找不包含xxx的内容 grep -v xxx # 排除所有空行 grep -v \u0026#39;^/pre\u0026gt;\u0026#39; # 返回结果 2,则说明第二行是空行 grep -n “^$” 111.txt # 查询以abc开头的行 grep -n “^abc” 111.txt # 同时列出该词语出现在文章的第几行 grep \u0026#39;xxx\u0026#39; -n xxx.log # 计算一下该字串出现的次数 grep \u0026#39;xxx\u0026#39; -c xxx.log # 比对的时候，不计较大小写的不同 grep \u0026#39;xxx\u0026#39; -i xxx.log awk # 以\u0026#39;:\u0026#39; 为分隔符,如果第五域有user则输出该行 awk -F \u0026#39;:\u0026#39; \u0026#39;{if ($5 ~ /user/) print $0}\u0026#39; /etc/passwd # 统计单个文件中某个字符（串）(中文无效)出现的次数 awk -v RS=\u0026#39;character\u0026#39; \u0026#39;END {print --NR}\u0026#39; xxx.txt find # 在目录下找后缀是.mysql的文件 find /home/eagleye -name \u0026#39;*.mysql\u0026#39; -print # 会从 /usr 目录开始往下找，找最近3天之内存取过的文件。 find /usr -atime 3 –print # 会从 /usr 目录开始往下找，找最近5天之内修改过的文件。 find /usr -ctime 5 –print # 会从 /doc 目录开始往下找，找jacky 的、文件名开头是 j的文件。 find /doc -user jacky -name \u0026#39;j*\u0026#39; –print # 会从 /doc 目录开始往下找，找寻文件名是 ja 开头或者 ma开头的文件。 find /doc \\( -name \u0026#39;ja*\u0026#39; -o- -name \u0026#39;ma*\u0026#39; \\) –print # 会从 /doc 目录开始往下找，找到凡是文件名结尾为 bak的文件，把它删除掉。-exec 选项是执行的意思，rm 是删除命令，{ } 表示文件名，“\\;”是规定的命令结尾。 find /doc -name \u0026#39;*bak\u0026#39; -exec rm {} \\; 查看什么进程使用了该端口 lsof -i:port 获取本机ip地址 /sbin/ifconfig -a|grep inet|grep -v 127.0.0.1|grep -v inet6|awk \u0026#39;{print $2}\u0026#39;|tr -d \u0026#34;addr:\u0026#34; iptables # 查看iptables状态 service iptables status # 要封停一个ip iptables -I INPUT -s ***.***.***.*** -j DROP # 要解封一个IP，使用下面这条命令： iptables -D INPUT -s ***.***.***.*** -j DROP 备注: 参数-I是表示Insert（添加），-D表示Delete（删除）。后面跟的是规则，INPUT表示入站，***.***.***.***表示要封停的IP，DROP表示放弃连接。 #开启9090端口的访问 /sbin/iptables -I INPUT -p tcp --dport 9090 -j ACCEPT # 防火墙开启、关闭、重启 /etc/init.d/iptables status /etc/init.d/iptables start /etc/init.d/iptables stop /etc/init.d/iptables restart nc命令, tcp调试利器 #给某一个endpoint发送TCP请求,就将data的内容发送到对端 nc 192.168.0.11 8000 \u0026lt; data.txt #nc可以当做服务器，监听某个端口号,把某一次请求的内容存储到received_data里 nc -l 8000 \u0026gt; received_data #上边只监听一次，如果多次可以加上-k参数 nc -lk 8000 tcpdump # dump出本机12301端口的tcp包 tcpdump -i em1 tcp port 12301 -s 1500 -w abc.pcap 跟踪网络路由路径 # traceroute默认使用udp方式, 如果是-I则改成icmp方式 traceroute -I www.163.com # 从ttl第3跳跟踪 traceroute -M 3 www.163.com # 加上端口跟踪 traceroute -p 8080 192.168.10.11 ss # 显示本地打开的所有端口 ss -l # 显示每个进程具体打开的socket ss -pl # 显示所有tcp socket ss -t -a # 显示所有的UDP Socekt ss -u -a # 显示所有已建立的SMTP连接 ss -o state established \u0026#39;( dport = :smtp or sport = :smtp )\u0026#39; # 显示所有已建立的HTTP连接 ss -o state established \u0026#39;( dport = :http or sport = :http )\u0026#39; 找出所有连接X服务器的进程 ss -x src /tmp/.X11-unix/* 列出当前socket统计信息 ss -s 解释：netstat是遍历/proc下面每个PID目录，ss直接读/proc/net下面的统计信息。所以ss执行的时候消耗资源以及消耗的时间都比netstat少很多 netstat # 输出每个ip的连接数，以及总的各个状态的连接数 netstat -n | awk \u0026#39;/^tcp/ {n=split($(NF-1),array,\u0026#34;:\u0026#34;);if(n\u0026lt;=2)++S[array[(1)]];else++S[array[(4)]];++s[$NF];++N} END {for(a in S){printf(\u0026#34;%-20s %s\\n\u0026#34;, a, S[a]);++I}printf(\u0026#34;%-20s %s\\n\u0026#34;,\u0026#34;TOTAL_IP\u0026#34;,I);for(a in s) printf(\u0026#34;%-20s %s\\n\u0026#34;,a, s[a]);printf(\u0026#34;%-20s %s\\n\u0026#34;,\u0026#34;TOTAL_LINK\u0026#34;,N);}\u0026#39; # 统计所有连接状态, # CLOSED：无连接是活动的或正在进行 # LISTEN：服务器在等待进入呼叫 # SYN_RECV：一个连接请求已经到达，等待确认 # SYN_SENT：应用已经开始，打开一个连接 # ESTABLISHED：正常数据传输状态 # FIN_WAIT1：应用说它已经完成 # FIN_WAIT2：另一边已同意释放 # ITMED_WAIT：等待所有分组死掉 # CLOSING：两边同时尝试关闭 # TIME_WAIT：主动关闭连接一端还没有等到另一端反馈期间的状态 # LAST_ACK：等待所有分组死掉 netstat -n | awk \u0026#39;/^tcp/ {++state[$NF]} END {for(key in state) print key,\u0026#34;\\t\u0026#34;,state[key]}\u0026#39; # 查找较多time_wait连接 netstat -n|grep TIME_WAIT|awk \u0026#39;{print $5}\u0026#39;|sort|uniq -c|sort -rn|head -n20 top dmesg,查看系统日志 iostat,磁盘IO情况监控 iostat -xz 1 # r/s, w/s, rkB/s, wkB/s：分别表示每秒读写次数和每秒读写数据量（千字节）。读写量过大，可能会引起性能问题。 # await：IO操作的平均等待时间，单位是毫秒。这是应用程序在和磁盘交互时，需要消耗的时间，包括IO等待和实际操作的耗时。如果这个数值过大，可能是硬件设备遇到了瓶颈或者出现故障。 # avgqu-sz：向设备发出的请求平均数量。如果这个数值大于1，可能是硬件设备已经饱和（部分前端硬件设备支持并行写入）。 # %util：设备利用率。这个数值表示设备的繁忙程度，经验值是如果超过60，可能会影响IO性能（可以参照IO操作平均等待时间）。如果到达100%，说明硬件设备已经饱和。 # 如果显示的是逻辑设备的数据，那么设备利用率不代表后端实际的硬件设备已经饱和。值得注意的是，即使IO性能不理想，也不一定意味这应用程序性能会不好，可以利用诸如预读取、写缓存等策略提升应用性能。 free,内存使用情况 free -m eg: total used free shared buffers cached Mem: 1002 769 232 0 62 421 -/+ buffers/cache: 286 715 Swap: 1153 0 1153 第一部分Mem行: total 内存总数: 1002M used 已经使用的内存数: 769M free 空闲的内存数: 232M shared 当前已经废弃不用,总是0 buffers Buffer 缓存内存数: 62M cached Page 缓存内存数:421M 关系：total(1002M) = used(769M) + free(232M) 第二部分(-/+ buffers/cache): (-buffers/cache) used内存数：286M (指的第一部分Mem行中的used – buffers – cached) (+buffers/cache) free内存数: 715M (指的第一部分Mem行中的free + buffers + cached) 可见-buffers/cache反映的是被程序实实在在吃掉的内存,而+buffers/cache反映的是可以挪用的内存总数. 第三部分是指交换分区 sar,查看网络吞吐状态 # sar命令在这里可以查看网络设备的吞吐率。在排查性能问题时，可以通过网络设备的吞吐量，判断网络设备是否已经饱和 sar -n DEV 1 # sar命令在这里用于查看TCP连接状态，其中包括： # active/s：每秒本地发起的TCP连接数，既通过connect调用创建的TCP连接； # passive/s：每秒远程发起的TCP连接数，即通过accept调用创建的TCP连接； # retrans/s：每秒TCP重传数量； # TCP连接数可以用来判断性能问题是否由于建立了过多的连接，进一步可以判断是主动发起的连接，还是被动接受的连接。TCP重传可能是因为网络环境恶劣，或者服务器压力过大导致丢包 sar -n TCP,ETCP 1 vmstat, 给定时间监控CPU使用率, 内存使用, 虚拟内存交互, IO读写 # 2表示每2秒采集一次状态信息, 1表示只采集一次(忽略既是一直采集) vmstat 2 1 ","permalink":"https://lesanouo.github.io/blog/posts/snippet/linux/","summary":"\u003ch2 id=\"linux关机重启\"\u003eLinux关机,重启\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 关机\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eshutdown -h now\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 重启\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eshutdown -r now\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"查看系统cpu信息\"\u003e查看系统,CPU信息\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 查看系统内核信息\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003euname -a\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 查看系统内核版本\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ecat /proc/version\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 查看当前用户环境变量\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eenv\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ecat /proc/cpuinfo\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 查看有几个逻辑cpu, 包括cpu型号\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ecat /proc/cpuinfo \u003cspan class=\"p\"\u003e|\u003c/span\u003e grep name \u003cspan class=\"p\"\u003e|\u003c/span\u003e cut -f2 -d: \u003cspan class=\"p\"\u003e|\u003c/span\u003e uniq -c\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 查看有几颗cpu,每颗分别是几核\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ecat /proc/cpuinfo \u003cspan class=\"p\"\u003e|\u003c/span\u003e grep physical \u003cspan class=\"p\"\u003e|\u003c/span\u003e uniq -c\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 查看当前CPU运行在32bit还是64bit模式下, 如果是运行在32bit下也不代表CPU不支持64bit\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egetconf LONG_BIT\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 结果大于0, 说明支持64bit计算. lm指long mode, 支持lm则是64bit\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ecat /proc/cpuinfo \u003cspan class=\"p\"\u003e|\u003c/span\u003e grep flags \u003cspan class=\"p\"\u003e|\u003c/span\u003e grep \u003cspan class=\"s1\"\u003e\u0026#39; lm \u0026#39;\u003c/span\u003e \u003cspan class=\"p\"\u003e|\u003c/span\u003e wc -l\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"建立软连接\"\u003e建立软连接\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eln -s /usr/local/jdk1.8/ jdk\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"rpm相关\"\u003erpm相关\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 查看是否通过rpm安装了该软件\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003erpm -qa \u003cspan class=\"p\"\u003e|\u003c/span\u003e grep 软件名\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"sshkey\"\u003esshkey\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 创建sshkey\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003essh-keygen -t rsa -C your_email@example.com\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e#id_rsa.pub 的内容拷贝到要控制的服务器的 home/username/.ssh/authorized_keys 中,如果没有则新建(.ssh权限为700, authorized_keys权限为600)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"命令重命名\"\u003e命令重命名\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 在各个用户的.bash_profile中添加重命名配置\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003ealias\u003c/span\u003e \u003cspan class=\"nv\"\u003ell\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;ls -alF\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"同步服务器时间\"\u003e同步服务器时间\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo ntpdate -u ntp.api.bz\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"后台运行\"\u003e后台运行\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 后台运行,并且有nohup.out输出\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003enohup xxx \u003cspan class=\"p\"\u003e\u0026amp;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 后台运行, 不输出任何日志\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003enohup xxx \u0026gt; /dev/null \u003cspan class=\"p\"\u003e\u0026amp;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 后台运行, 并将错误信息做标准输出到日志中\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003enohup xxx \u0026gt;out.log 2\u0026gt;\u003cspan class=\"p\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"m\"\u003e1\u003c/span\u003e \u003cspan class=\"p\"\u003e\u0026amp;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"强制活动用户退出\"\u003e强制活动用户退出\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 命令来完成强制活动用户退出.其中TTY表示终端名称\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003epkill -kill -t \u003cspan class=\"o\"\u003e[\u003c/span\u003eTTY\u003cspan class=\"o\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"查看命令路径\"\u003e查看命令路径\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ewhich \u0026lt;命令\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"查看进程所有打开最大fd数\"\u003e查看进程所有打开最大fd数\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eulimit\u003c/span\u003e -n\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"配置dns\"\u003e配置dns\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003evim /etc/resolv.conf\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"nslookup查看域名路由表\"\u003enslookup,查看域名路由表\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003enslookup google.com\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"last最近登录信息列表\"\u003elast,最近登录信息列表\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 最近登录的5个账号\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003elast -n \u003cspan class=\"m\"\u003e5\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"设置固定ip\"\u003e设置固定ip\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eifconfig em1  192.168.5.177 netmask 255.255.255.0\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"查看进程内加载的环境变量\"\u003e查看进程内加载的环境变量\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 也可以去 cd /proc 目录下, 查看进程内存中加载的东西\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eps eww -p  XXXXX\u003cspan class=\"o\"\u003e(\u003c/span\u003e进程号\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"查看进程树找到服务器进程\"\u003e查看进程树找到服务器进程\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eps auwxf\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"查看进程启动路径\"\u003e查看进程启动路径\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003ecd\u003c/span\u003e /proc/xxx\u003cspan class=\"o\"\u003e(\u003c/span\u003e进程号\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003els -all\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# cwd对应的是启动路径\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"添加用户配置sudo权限\"\u003e添加用户,配置sudo权限\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 新增用户\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003euseradd 用户名\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003epasswd 用户名\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e#增加sudo权限\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003evim /etc/sudoers\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 修改文件里面的\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# root    ALL=(ALL)       ALL\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 用户名 ALL=(ALL)       ALL\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"强制关闭进程名包含xxx的所有进程\"\u003e强制关闭进程名包含xxx的所有进程\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eps aux\u003cspan class=\"p\"\u003e|\u003c/span\u003egrep xxx \u003cspan class=\"p\"\u003e|\u003c/span\u003e grep -v grep \u003cspan class=\"p\"\u003e|\u003c/span\u003e awk \u003cspan class=\"s1\"\u003e\u0026#39;{print $2}\u0026#39;\u003c/span\u003e \u003cspan class=\"p\"\u003e|\u003c/span\u003e xargs \u003cspan class=\"nb\"\u003ekill\u003c/span\u003e -9\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"vim操作\"\u003evim操作\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e#normal模式下 g表示全局, x表示查找的内容, y表示替换后的内容\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e:%s/x/y/g\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e#normal模式下\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"m\"\u003e0\u003c/span\u003e  \u003cspan class=\"c1\"\u003e# 光标移到行首(数字0)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e$  \u003cspan class=\"c1\"\u003e# 光标移至行尾\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eshift\u003c/span\u003e + g \u003cspan class=\"c1\"\u003e# 跳到文件最后\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egg \u003cspan class=\"c1\"\u003e# 跳到文件头\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 显示行号\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e:set nu\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 去除行号\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e:set nonu\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 检索\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e/xxx\u003cspan class=\"o\"\u003e(\u003c/span\u003e检索内容\u003cspan class=\"o\"\u003e)\u003c/span\u003e  \u003cspan class=\"c1\"\u003e# 从头检索, 按n查找下一个\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e?xxx\u003cspan class=\"o\"\u003e(\u003c/span\u003e检索内容\u003cspan class=\"o\"\u003e)\u003c/span\u003e  \u003cspan class=\"c1\"\u003e# 从尾部检索\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"打开只读文件修改后需要保存时不用切换用户即可保存的方式\"\u003e打开只读文件,修改后需要保存时(不用切换用户即可保存的方式)\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 在normal模式下\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e:w !sudo tee %\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"查看磁盘-文件目录基本信息\"\u003e查看磁盘, 文件目录基本信息\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 查看磁盘挂载情况\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003emount\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 查看磁盘分区信息\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003edf\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 查看目录及子目录大小\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003edu -H -h\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 查看当前目录下各个文件, 文件夹占了多少空间, 不会递归\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003edu -sh *\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"wc命令\"\u003ewc命令\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 查看文件里有多少行\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ewc -l filename\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 看文件里有多少个word\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ewc -w filename\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 文件里最长的那一行是多少个字\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ewc -L filename\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 统计字节数\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ewc -c\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"压缩命令\"\u003e压缩命令\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003etar czvf xxx.tar 压缩目录\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ezip -r xxx.zip 压缩目录\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"解压缩命令\"\u003e解压缩命令\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003etar zxvf xxx.tar\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 解压到指定文件夹\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003etar zxvf xxx.tar -C /xxx/yyy/\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eunzip xxx.zip\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"变更文件所属用户-用户组\"\u003e变更文件所属用户, 用户组\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003echown eagleye.eagleye xxx.log\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"cp-scp-mkdir\"\u003ecp, scp, mkdir\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e#复制\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ecp xxx.log\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 复制并强制覆盖同名文件\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ecp -f xxx.log\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 复制文件夹\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ecp -r xxx\u003cspan class=\"o\"\u003e(\u003c/span\u003e源文件夹\u003cspan class=\"o\"\u003e)\u003c/span\u003e yyy\u003cspan class=\"o\"\u003e(\u003c/span\u003e目标文件夹\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 远程复制\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003escp -P ssh端口 username@10.10.10.101:/home/username/xxx /home/xxx\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 级联创建目录\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003emkdir -p /xxx/yyy/zzz\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 批量创建文件夹, 会在test,main下都创建java, resources文件夹\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003emkdir -p src/\u003cspan class=\"o\"\u003e{\u003c/span\u003etest,main\u003cspan class=\"o\"\u003e}\u003c/span\u003e/\u003cspan class=\"o\"\u003e{\u003c/span\u003ejava,resources\u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"比较两个文件\"\u003e比较两个文件\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ediff -u 1.txt 2.txt\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"日志输出的字节数可以用作性能测试\"\u003e日志输出的字节数,可以用作性能测试\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 如果做性能测试, 可以每执行一次, 往日志里面输出 “.” , 这样日志中的字节数就是实际的性能测试运行的次数, 还可以看见实时速率.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003etail -f xxx.log \u003cspan class=\"p\"\u003e|\u003c/span\u003e pv -bt\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"查看-去除特殊字符\"\u003e查看, 去除特殊字符\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 查看特殊字符\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ecat -v xxx.sh\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 去除特殊字符\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esed -i \u003cspan class=\"err\"\u003e\u0026#39;\u003c/span\u003es/^M//g’ env.sh  去除文件的特殊字符, 比如^M:  需要这样输入: ctrl+v+enter\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"处理因系统原因引起的文件中特殊字符的问题\"\u003e处理因系统原因引起的文件中特殊字符的问题\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 可以转换为该系统下的文件格式\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ecat file.sh \u0026gt; file.sh_bak\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 先将file.sh中文件内容复制下来然后运行, 然后粘贴内容, 最后ctrl + d 保存退出\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ecat \u0026gt; file1.sh\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 在vim中通过如下设置文件编码和文件格式\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e:set \u003cspan class=\"nv\"\u003efileencodings\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003eutf-8 ，然后 w （存盘）一下即可转化为 utf8 格式，\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e:set \u003cspan class=\"nv\"\u003efileformat\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003eunix\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 在mac下使用dos2unix进行文件格式化\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003efind . -name \u003cspan class=\"s2\"\u003e\u0026#34;*.sh\u0026#34;\u003c/span\u003e \u003cspan class=\"p\"\u003e|\u003c/span\u003e xargs dos2unix\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"tee-重定向的同时输出到屏幕\"\u003etee, 重定向的同时输出到屏幕\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eawk ‘\u003cspan class=\"o\"\u003e{\u003c/span\u003eprint \u003cspan class=\"nv\"\u003e$0\u003c/span\u003e\u003cspan class=\"o\"\u003e}\u003c/span\u003e’ xxx.log \u003cspan class=\"p\"\u003e|\u003c/span\u003e tee test.log\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"grep\"\u003egrep\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 反向匹配, 查找不包含xxx的内容\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egrep -v xxx\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 排除所有空行\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egrep -v \u003cspan class=\"s1\"\u003e\u0026#39;^/pre\u0026gt;\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 返回结果 2,则说明第二行是空行\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egrep -n “^$” 111.txt\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 查询以abc开头的行\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egrep -n “^abc” 111.txt\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 同时列出该词语出现在文章的第几行\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egrep \u003cspan class=\"s1\"\u003e\u0026#39;xxx\u0026#39;\u003c/span\u003e -n xxx.log\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 计算一下该字串出现的次数\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egrep \u003cspan class=\"s1\"\u003e\u0026#39;xxx\u0026#39;\u003c/span\u003e -c xxx.log\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 比对的时候，不计较大小写的不同\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egrep \u003cspan class=\"s1\"\u003e\u0026#39;xxx\u0026#39;\u003c/span\u003e -i xxx.log\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"awk\"\u003eawk\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 以\u0026#39;:\u0026#39; 为分隔符,如果第五域有user则输出该行\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eawk -F \u003cspan class=\"s1\"\u003e\u0026#39;:\u0026#39;\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;{if ($5 ~ /user/) print $0}\u0026#39;\u003c/span\u003e /etc/passwd\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 统计单个文件中某个字符（串）(中文无效)出现的次数\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eawk -v \u003cspan class=\"nv\"\u003eRS\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;character\u0026#39;\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;END {print --NR}\u0026#39;\u003c/span\u003e xxx.txt\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"find\"\u003efind\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 在目录下找后缀是.mysql的文件\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003efind /home/eagleye -name \u003cspan class=\"s1\"\u003e\u0026#39;*.mysql\u0026#39;\u003c/span\u003e -print\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 会从 /usr 目录开始往下找，找最近3天之内存取过的文件。\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003efind /usr -atime \u003cspan class=\"m\"\u003e3\u003c/span\u003e –print\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 会从 /usr 目录开始往下找，找最近5天之内修改过的文件。\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003efind /usr -ctime \u003cspan class=\"m\"\u003e5\u003c/span\u003e –print\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 会从 /doc 目录开始往下找，找jacky 的、文件名开头是 j的文件。\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003efind /doc -user jacky -name \u003cspan class=\"s1\"\u003e\u0026#39;j*\u0026#39;\u003c/span\u003e –print\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 会从 /doc 目录开始往下找，找寻文件名是 ja 开头或者 ma开头的文件。\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003efind /doc \u003cspan class=\"se\"\u003e\\(\u003c/span\u003e -name \u003cspan class=\"s1\"\u003e\u0026#39;ja*\u0026#39;\u003c/span\u003e -o- -name \u003cspan class=\"s1\"\u003e\u0026#39;ma*\u0026#39;\u003c/span\u003e \u003cspan class=\"se\"\u003e\\)\u003c/span\u003e –print\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e#  会从 /doc 目录开始往下找，找到凡是文件名结尾为 bak的文件，把它删除掉。-exec 选项是执行的意思，rm 是删除命令，{ } 表示文件名，“\\;”是规定的命令结尾。\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003efind /doc -name \u003cspan class=\"s1\"\u003e\u0026#39;*bak\u0026#39;\u003c/span\u003e -exec rm \u003cspan class=\"o\"\u003e{}\u003c/span\u003e \u003cspan class=\"se\"\u003e\\;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"查看什么进程使用了该端口\"\u003e查看什么进程使用了该端口\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003elsof -i:port\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"获取本机ip地址\"\u003e获取本机ip地址\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e/sbin/ifconfig -a\u003cspan class=\"p\"\u003e|\u003c/span\u003egrep inet\u003cspan class=\"p\"\u003e|\u003c/span\u003egrep -v 127.0.0.1\u003cspan class=\"p\"\u003e|\u003c/span\u003egrep -v inet6\u003cspan class=\"p\"\u003e|\u003c/span\u003eawk \u003cspan class=\"s1\"\u003e\u0026#39;{print $2}\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003etr -d \u003cspan class=\"s2\"\u003e\u0026#34;addr:\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"iptables\"\u003eiptables\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 查看iptables状态\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eservice iptables status\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 要封停一个ip\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eiptables -I INPUT -s ***.***.***.*** -j DROP\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 要解封一个IP，使用下面这条命令：\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eiptables -D INPUT -s ***.***.***.*** -j DROP\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e备注: 参数-I是表示Insert（添加），-D表示Delete（删除）。后面跟的是规则，INPUT表示入站，***.***.***.***表示要封停的IP，DROP表示放弃连接。\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e#开启9090端口的访问\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e/sbin/iptables -I INPUT -p tcp --dport \u003cspan class=\"m\"\u003e9090\u003c/span\u003e -j ACCEPT\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 防火墙开启、关闭、重启\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e/etc/init.d/iptables status\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e/etc/init.d/iptables start\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e/etc/init.d/iptables stop\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e/etc/init.d/iptables restart\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"nc命令-tcp调试利器\"\u003enc命令, tcp调试利器\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e#给某一个endpoint发送TCP请求,就将data的内容发送到对端\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003enc 192.168.0.11 \u003cspan class=\"m\"\u003e8000\u003c/span\u003e \u0026lt; data.txt\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e#nc可以当做服务器，监听某个端口号,把某一次请求的内容存储到received_data里\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003enc -l \u003cspan class=\"m\"\u003e8000\u003c/span\u003e \u0026gt; received_data\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e#上边只监听一次，如果多次可以加上-k参数\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003enc -lk \u003cspan class=\"m\"\u003e8000\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"tcpdump\"\u003etcpdump\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# dump出本机12301端口的tcp包\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003etcpdump -i em1 tcp port \u003cspan class=\"m\"\u003e12301\u003c/span\u003e -s \u003cspan class=\"m\"\u003e1500\u003c/span\u003e -w abc.pcap\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"跟踪网络路由路径\"\u003e跟踪网络路由路径\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# traceroute默认使用udp方式, 如果是-I则改成icmp方式\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003etraceroute -I www.163.com\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 从ttl第3跳跟踪\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003etraceroute -M \u003cspan class=\"m\"\u003e3\u003c/span\u003e www.163.com\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 加上端口跟踪\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003etraceroute -p \u003cspan class=\"m\"\u003e8080\u003c/span\u003e 192.168.10.11\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"ss\"\u003ess\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 显示本地打开的所有端口\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ess -l\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 显示每个进程具体打开的socket\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ess -pl\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 显示所有tcp socket\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ess -t -a\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 显示所有的UDP Socekt\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ess -u -a\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 显示所有已建立的SMTP连接\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ess -o state established \u003cspan class=\"s1\"\u003e\u0026#39;( dport = :smtp or sport = :smtp )\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 显示所有已建立的HTTP连接\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ess -o state established \u003cspan class=\"s1\"\u003e\u0026#39;( dport = :http or sport = :http )\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e找出所有连接X服务器的进程\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ess -x src /tmp/.X11-unix/*\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e列出当前socket统计信息\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ess -s\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e解释：netstat是遍历/proc下面每个PID目录，ss直接读/proc/net下面的统计信息。所以ss执行的时候消耗资源以及消耗的时间都比netstat少很多\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"netstat\"\u003enetstat\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 输出每个ip的连接数，以及总的各个状态的连接数\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003enetstat -n \u003cspan class=\"p\"\u003e|\u003c/span\u003e awk \u003cspan class=\"s1\"\u003e\u0026#39;/^tcp/ {n=split($(NF-1),array,\u0026#34;:\u0026#34;);if(n\u0026lt;=2)++S[array[(1)]];else++S[array[(4)]];++s[$NF];++N} END {for(a in S){printf(\u0026#34;%-20s %s\\n\u0026#34;, a, S[a]);++I}printf(\u0026#34;%-20s %s\\n\u0026#34;,\u0026#34;TOTAL_IP\u0026#34;,I);for(a in s) printf(\u0026#34;%-20s %s\\n\u0026#34;,a, s[a]);printf(\u0026#34;%-20s %s\\n\u0026#34;,\u0026#34;TOTAL_LINK\u0026#34;,N);}\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 统计所有连接状态,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# CLOSED：无连接是活动的或正在进行\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# LISTEN：服务器在等待进入呼叫\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# SYN_RECV：一个连接请求已经到达，等待确认\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# SYN_SENT：应用已经开始，打开一个连接\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# ESTABLISHED：正常数据传输状态\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# FIN_WAIT1：应用说它已经完成\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# FIN_WAIT2：另一边已同意释放\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# ITMED_WAIT：等待所有分组死掉\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# CLOSING：两边同时尝试关闭\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# TIME_WAIT：主动关闭连接一端还没有等到另一端反馈期间的状态\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# LAST_ACK：等待所有分组死掉\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003enetstat -n \u003cspan class=\"p\"\u003e|\u003c/span\u003e awk \u003cspan class=\"s1\"\u003e\u0026#39;/^tcp/ {++state[$NF]} END {for(key in state) print key,\u0026#34;\\t\u0026#34;,state[key]}\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 查找较多time_wait连接\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003enetstat -n\u003cspan class=\"p\"\u003e|\u003c/span\u003egrep TIME_WAIT\u003cspan class=\"p\"\u003e|\u003c/span\u003eawk \u003cspan class=\"s1\"\u003e\u0026#39;{print $5}\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003esort\u003cspan class=\"p\"\u003e|\u003c/span\u003euniq -c\u003cspan class=\"p\"\u003e|\u003c/span\u003esort -rn\u003cspan class=\"p\"\u003e|\u003c/span\u003ehead -n20\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"top\"\u003etop\u003c/h2\u003e\n\u003ch2 id=\"dmesg查看系统日志\"\u003edmesg,查看系统日志\u003c/h2\u003e\n\u003ch2 id=\"iostat磁盘io情况监控\"\u003eiostat,磁盘IO情况监控\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eiostat -xz \u003cspan class=\"m\"\u003e1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# r/s, w/s, rkB/s, wkB/s：分别表示每秒读写次数和每秒读写数据量（千字节）。读写量过大，可能会引起性能问题。\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# await：IO操作的平均等待时间，单位是毫秒。这是应用程序在和磁盘交互时，需要消耗的时间，包括IO等待和实际操作的耗时。如果这个数值过大，可能是硬件设备遇到了瓶颈或者出现故障。\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# avgqu-sz：向设备发出的请求平均数量。如果这个数值大于1，可能是硬件设备已经饱和（部分前端硬件设备支持并行写入）。\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# %util：设备利用率。这个数值表示设备的繁忙程度，经验值是如果超过60，可能会影响IO性能（可以参照IO操作平均等待时间）。如果到达100%，说明硬件设备已经饱和。\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 如果显示的是逻辑设备的数据，那么设备利用率不代表后端实际的硬件设备已经饱和。值得注意的是，即使IO性能不理想，也不一定意味这应用程序性能会不好，可以利用诸如预读取、写缓存等策略提升应用性能。\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"free内存使用情况\"\u003efree,内存使用情况\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003efree -m\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eeg:\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e     total       used       free     shared    buffers     cached\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eMem:          \u003cspan class=\"m\"\u003e1002\u003c/span\u003e        \u003cspan class=\"m\"\u003e769\u003c/span\u003e        \u003cspan class=\"m\"\u003e232\u003c/span\u003e          \u003cspan class=\"m\"\u003e0\u003c/span\u003e         \u003cspan class=\"m\"\u003e62\u003c/span\u003e        \u003cspan class=\"m\"\u003e421\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e-/+ buffers/cache:          \u003cspan class=\"m\"\u003e286\u003c/span\u003e        \u003cspan class=\"m\"\u003e715\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eSwap:          \u003cspan class=\"m\"\u003e1153\u003c/span\u003e          \u003cspan class=\"m\"\u003e0\u003c/span\u003e       \u003cspan class=\"m\"\u003e1153\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e第一部分Mem行:\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003etotal 内存总数: 1002M\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eused 已经使用的内存数: 769M\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003efree 空闲的内存数: 232M\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eshared 当前已经废弃不用,总是0\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ebuffers Buffer 缓存内存数: 62M\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ecached Page 缓存内存数:421M\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e关系：total\u003cspan class=\"o\"\u003e(\u003c/span\u003e1002M\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e used\u003cspan class=\"o\"\u003e(\u003c/span\u003e769M\u003cspan class=\"o\"\u003e)\u003c/span\u003e + free\u003cspan class=\"o\"\u003e(\u003c/span\u003e232M\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e第二部分\u003cspan class=\"o\"\u003e(\u003c/span\u003e-/+ buffers/cache\u003cspan class=\"o\"\u003e)\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e-buffers/cache\u003cspan class=\"o\"\u003e)\u003c/span\u003e used内存数：286M \u003cspan class=\"o\"\u003e(\u003c/span\u003e指的第一部分Mem行中的used – buffers – cached\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e+buffers/cache\u003cspan class=\"o\"\u003e)\u003c/span\u003e free内存数: 715M \u003cspan class=\"o\"\u003e(\u003c/span\u003e指的第一部分Mem行中的free + buffers + cached\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e可见-buffers/cache反映的是被程序实实在在吃掉的内存,而+buffers/cache反映的是可以挪用的内存总数.\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e第三部分是指交换分区\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"sar查看网络吞吐状态\"\u003esar,查看网络吞吐状态\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# sar命令在这里可以查看网络设备的吞吐率。在排查性能问题时，可以通过网络设备的吞吐量，判断网络设备是否已经饱和\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esar -n DEV \u003cspan class=\"m\"\u003e1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# sar命令在这里用于查看TCP连接状态，其中包括：\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# active/s：每秒本地发起的TCP连接数，既通过connect调用创建的TCP连接；\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# passive/s：每秒远程发起的TCP连接数，即通过accept调用创建的TCP连接；\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# retrans/s：每秒TCP重传数量；\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# TCP连接数可以用来判断性能问题是否由于建立了过多的连接，进一步可以判断是主动发起的连接，还是被动接受的连接。TCP重传可能是因为网络环境恶劣，或者服务器压力过大导致丢包\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esar -n TCP,ETCP \u003cspan class=\"m\"\u003e1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"vmstat-给定时间监控cpu使用率-内存使用-虚拟内存交互-io读写\"\u003evmstat, 给定时间监控CPU使用率, 内存使用, 虚拟内存交互, IO读写\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 2表示每2秒采集一次状态信息, 1表示只采集一次(忽略既是一直采集)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003evmstat \u003cspan class=\"m\"\u003e2\u003c/span\u003e \u003cspan class=\"m\"\u003e1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"Linux 代码片段"},{"content":"\u0026lt;repositories\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;public\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;aliyun nexus\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;http://maven.aliyun.com/nexus/content/groups/public/\u0026lt;/url\u0026gt; \u0026lt;releases\u0026gt; \u0026lt;enabled\u0026gt;true\u0026lt;/enabled\u0026gt; \u0026lt;/releases\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;/repositories\u0026gt; \u0026lt;pluginRepositories\u0026gt; \u0026lt;pluginRepository\u0026gt; \u0026lt;id\u0026gt;public\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;aliyun nexus\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;http://maven.aliyun.com/nexus/content/groups/public/\u0026lt;/url\u0026gt; \u0026lt;releases\u0026gt; \u0026lt;enabled\u0026gt;true\u0026lt;/enabled\u0026gt; \u0026lt;/releases\u0026gt; \u0026lt;snapshots\u0026gt; \u0026lt;enabled\u0026gt;false\u0026lt;/enabled\u0026gt; \u0026lt;/snapshots\u0026gt; \u0026lt;/pluginRepository\u0026gt; \u0026lt;/pluginRepositories\u0026gt; ","permalink":"https://lesanouo.github.io/blog/posts/snippet/maven-aliyun-nexus/","summary":"\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-xml\" data-lang=\"xml\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nt\"\u003e\u0026lt;repositories\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nt\"\u003e\u0026lt;repository\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"nt\"\u003e\u0026lt;id\u0026gt;\u003c/span\u003epublic\u003cspan class=\"nt\"\u003e\u0026lt;/id\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"nt\"\u003e\u0026lt;name\u0026gt;\u003c/span\u003ealiyun nexus\u003cspan class=\"nt\"\u003e\u0026lt;/name\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"nt\"\u003e\u0026lt;url\u0026gt;\u003c/span\u003ehttp://maven.aliyun.com/nexus/content/groups/public/\u003cspan class=\"nt\"\u003e\u0026lt;/url\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"nt\"\u003e\u0026lt;releases\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\u003cspan class=\"nt\"\u003e\u0026lt;enabled\u0026gt;\u003c/span\u003etrue\u003cspan class=\"nt\"\u003e\u0026lt;/enabled\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"nt\"\u003e\u0026lt;/releases\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nt\"\u003e\u0026lt;/repository\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nt\"\u003e\u0026lt;/repositories\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nt\"\u003e\u0026lt;pluginRepositories\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nt\"\u003e\u0026lt;pluginRepository\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"nt\"\u003e\u0026lt;id\u0026gt;\u003c/span\u003epublic\u003cspan class=\"nt\"\u003e\u0026lt;/id\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"nt\"\u003e\u0026lt;name\u0026gt;\u003c/span\u003ealiyun nexus\u003cspan class=\"nt\"\u003e\u0026lt;/name\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"nt\"\u003e\u0026lt;url\u0026gt;\u003c/span\u003ehttp://maven.aliyun.com/nexus/content/groups/public/\u003cspan class=\"nt\"\u003e\u0026lt;/url\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"nt\"\u003e\u0026lt;releases\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\u003cspan class=\"nt\"\u003e\u0026lt;enabled\u0026gt;\u003c/span\u003etrue\u003cspan class=\"nt\"\u003e\u0026lt;/enabled\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"nt\"\u003e\u0026lt;/releases\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"nt\"\u003e\u0026lt;snapshots\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\u003cspan class=\"nt\"\u003e\u0026lt;enabled\u0026gt;\u003c/span\u003efalse\u003cspan class=\"nt\"\u003e\u0026lt;/enabled\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"nt\"\u003e\u0026lt;/snapshots\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nt\"\u003e\u0026lt;/pluginRepository\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nt\"\u003e\u0026lt;/pluginRepositories\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"Maven 阿里云镜像"},{"content":"本篇文章是学习leetcode中链表相关算法总结的链表技巧。\n虚拟头节点 力扣第 21 题「合并两个有序链表」 ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) { ListNode *head = new ListNode(-1), *p = head; while (l1 \u0026amp;\u0026amp; l2) { if (l1-\u0026gt;val \u0026lt; l2-\u0026gt;val) { p-\u0026gt;next = l1; l1 = l1-\u0026gt;next; } else { p-\u0026gt;next = l2; l2 = l2-\u0026gt;next; } p = p-\u0026gt;next; } p-\u0026gt;next = l1 ? l1 : l2; return head-\u0026gt;next; } 这个算法的逻辑类似于「拉拉链」，l1, l2 类似于拉链两侧的锯齿，指针 p 就好像拉链的拉索，将两个有序链表合并\nListNode *head = new ListNode(-1), *p = head;中使用到了虚拟头节点，如果不使用虚拟节点，代码会复杂很多，而有了 head 节点这个占位符，可以避免处理空指针的情况，降低代码的复杂性\n优先队列 力扣第 23 题「合并K个升序链表」 struct cmp { bool operator()(ListNode *p1, ListNode *p2) { return p1-\u0026gt;val \u0026gt; p2-\u0026gt;val; } }; ListNode *mergeKLists(vector\u0026lt;ListNode *\u0026gt; \u0026amp;lists) { if (lists.size() == 0) return nullptr; ListNode *head = new ListNode(-1), *tail = head; priority_queue\u0026lt;ListNode *, vector\u0026lt;ListNode *\u0026gt;, cmp\u0026gt; pq; for (auto i : lists) { if (i) pq.push(i); } while (!pq.empty()) { ListNode *node = pq.top(); pq.pop(); tail-\u0026gt;next = node; tail = tail-\u0026gt;next; if (node-\u0026gt;next) pq.push(node-\u0026gt;next); } return head-\u0026gt;next; } 这里我们就要用到 优先级队列 这种数据结构，把链表节点放入一个最小堆，就可以每次获得 k 个节点中的最小节点\n它的时间复杂度是多少呢？\n优先队列 pq 中的元素个数最多是 k，所以一次 poll 或者 add 方法的时间复杂度是 O(logk)；所有的链表节点都会被加入和弹出 pq，所以算法整体的时间复杂度是 O(Nlogk)，其中 k 是链表的条数，N 是这些链表的节点总数。\n单链表的倒数第k个节点 力扣第 19 题「删除链表的倒数第 N 个结点」 ListNode *removeNthFromEnd(ListNode *head, int n) { ListNode *dummy = new ListNode(-1); dummy-\u0026gt;next = head; auto temp = FindFromEnd(dummy, n + 1); temp-\u0026gt;next = temp-\u0026gt;next-\u0026gt;next; return dummy-\u0026gt;next; } ListNode *FindFromEnd(ListNode *head, int n) { ListNode *first = head, *second = head; while (n--) { first = first-\u0026gt;next; } while (first) { first = first-\u0026gt;next; second = second-\u0026gt;next; } return second; } 首先，我们先让一个指针 p1 指向链表的头节点 head，然后走 k 步 现在的 p1，只要再走 n - k 步，就能走到链表末尾的空指针了对吧？趁这个时候，再用一个指针 p2 指向链表头节点 head 接下来就很显然了，让 p1 和 p2 同时向前走，p1 走到链表末尾的空指针时走了 n - k 步，p2 也走了 n - k 步，也就是链表的倒数第 k 个节点 这样，只遍历了一次链表，就获得了倒数第 k 个节点 p2 不过注意我们又使用了虚拟头结点的技巧，也是为了防止出现空指针的情况，比如说链表总共有 5 个节点，题目就让你删除倒数第 5 个节点，也就是第一个节点，那按照算法逻辑，应该首先找到倒数第 6 个节点。但第一个节点前面已经没有节点了，这就会出错。\n但有了我们虚拟节点 dummy 的存在，就避免了这个问题，能够对这种情况进行正确的删除。\n双指针 力扣第 876 题「链表的中间结点」 如果想一次遍历就得到中间节点，也需要耍点小聪明，使用「快慢指针」的技巧：\n我们让两个指针 slow 和 fast 分别指向链表头结点 head。\n每当慢指针 slow 前进一步，快指针 fast 就前进两步，这样，当 fast 走到链表末尾时，slow 就指向了链表中点。\nListNode *middleNode(ListNode *head) { ListNode *slow = head, *fast = head; while (fast \u0026amp;\u0026amp; fast-\u0026gt;next) { slow = slow-\u0026gt;next; fast = fast-\u0026gt;next-\u0026gt;next; } return slow; } 力扣第 141 题「环形链表」 判断链表是否包含环属于经典问题了，解决方案也是用快慢指针：\n每当慢指针 slow 前进一步，快指针 fast 就前进两步。\n如果 fast 最终遇到空指针，说明链表中没有环；如果 fast 最终和 slow 相遇，那肯定是 fast 超过了 slow 一圈，说明链表中含有环。\nbool hasCycle(ListNode *head) { ListNode *slow = head, *fast = head; while (fast \u0026amp;\u0026amp; fast-\u0026gt;next) { slow = slow-\u0026gt;next; fast = fast-\u0026gt;next-\u0026gt;next; if (slow == fast) return true; } return false; } 当然，这个问题还有进阶版：如果链表中含有环，如何计算这个环的起点？\n这里简单提一下解法：\nListNode detectCycle(ListNode head) { ListNode fast, slow; fast = slow = head; while (fast != null \u0026amp;\u0026amp; fast.next != null) { fast = fast.next.next; slow = slow.next; if (fast == slow) break; } // 上面的代码类似 hasCycle 函数 if (fast == null || fast.next == null) { // fast 遇到空指针说明没有环 return null; } // 重新指向头结点 slow = head; // 快慢指针同步前进，相交点就是环起点 while (slow != fast) { fast = fast.next; slow = slow.next; } return slow; } 力扣第 160 题「相交链表」 ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { ListNode *A = headA, *B = headB; while (A != B) { if (A) A = A-\u0026gt;next; else A = headB; if (B) B = B-\u0026gt;next; else B = headA; } return A; } 如果用两个指针 p1 和 p2 分别在两条链表上前进，并不能同时走到公共节点，也就无法得到相交节点 c1。\n解决这个问题的关键是，通过某些方式，让 p1 和 p2 能够同时到达相交节点 c1。\n所以，我们可以让 p1 遍历完链表 A 之后开始遍历链表 B，让 p2 遍历完链表 B 之后开始遍历链表 A，这样相当于「逻辑上」两条链表接在了一起。\n如果这样进行拼接，就可以让 p1 和 p2 同时进入公共部分，也就是同时到达相交节点 c1：\n那你可能会问，如果说两个链表没有相交点，是否能够正确的返回 null 呢？\n这个逻辑可以覆盖这种情况的，相当于 c1 节点是 null 空指针嘛，可以正确返回 null。\n这样，这道题就解决了，空间复杂度为 O(1)，时间复杂度为 O(N)。\n","permalink":"https://lesanouo.github.io/blog/posts/algorithm/link-list/","summary":"\u003cp\u003e本篇文章是学习leetcode中链表相关算法总结的链表技巧。\u003c/p\u003e\n\u003ch2 id=\"虚拟头节点\"\u003e虚拟头节点\u003c/h2\u003e\n\u003ch3 id=\"力扣第-21-题合并两个有序链表\"\u003e力扣第 21 题「合并两个有序链表」\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eListNode\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"nf\"\u003emergeTwoLists\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eListNode\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003el1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eListNode\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003el2\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eListNode\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003ehead\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"n\"\u003eListNode\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003ep\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ehead\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ewhile\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003el1\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan class=\"n\"\u003el2\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003el1\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eval\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003el2\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eval\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003enext\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003el1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003el1\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003el1\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003enext\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003eelse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003enext\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003el2\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003el2\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003el2\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003enext\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003ep\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003enext\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003enext\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003el1\u003c/span\u003e \u003cspan class=\"o\"\u003e?\u003c/span\u003e \u003cspan class=\"nl\"\u003el1\u003c/span\u003e \u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"n\"\u003el2\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003ehead\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003enext\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e这个算法的逻辑类似于「拉拉链」，\u003ccode\u003el1, l2\u003c/code\u003e 类似于拉链两侧的锯齿，指针 \u003ccode\u003ep\u003c/code\u003e 就好像拉链的拉索，将两个有序链表合并\u003c/p\u003e","title":"算法学习-链表"},{"content":"本文主要介绍如何通过GitHub+Vercel免费搭建一个自己的静态网页。\nGitHub Pages GitHub Pages是GitHub提供给大家的快速部署静态网页的功能，但是由于国内访问比较慢，这里提供一个相对较快的解决办法，就是用GitHub+Vercel。\n第一步：注册登录Vercel 我想大家应该都有GitHub账号吧，这里就不多说了。\n点击Vercel官网,并使用GitHub登录。\n注意⚠️：GitHub账号不要使用QQ邮箱作为主邮箱。如果已经用QQ邮箱注册了GitHub，可以到Setting -\u0026gt; Emails里修改自己的主邮箱。\n第二步：导入仓库 它会让你选择一种登录Vercel的方法，支持使用GitHub，GitLab和Bitbucket登录，这里我们选GitHub，后面就是无脑Next的步骤。\n顺利的话稍等片刻就会弹出部署成功的页面，还有浮夸的撒花。\n部署完成之后可以点击visit进入网页看看效果。\n第三步：配置域名 1.点击view Domains进行绑定自己的域名或者点击 Settings👉Domains👉输入自己的域名\n2.输入自己的域名，然后点Add，它会弹出来一些需要做的配置，接下来需要去我们的域名提供商那里根据Vercel给出的要求进行配置。需要修改的有：Name Servers以及域名解析\n最后等待等这两个改动都生效之后就可以用我们自己的域名访问刚刚建立的网站啦~\n以后想要修改网站的话，只需要将改动push到GitHub上，vercel会自动把改动同步过来，完全不用管，超省心。\n在一级域名配置好之后，也可以直接在vercel中使用二级域名，无需进行额外设置。\n","permalink":"https://lesanouo.github.io/blog/posts/share/static-site-github-vercel/","summary":"\u003cp\u003e本文主要介绍如何通过GitHub+Vercel免费搭建一个自己的静态网页。\u003c/p\u003e\n\u003ch3 id=\"github-pages\"\u003eGitHub Pages\u003c/h3\u003e\n\u003cp\u003eGitHub Pages是GitHub提供给大家的快速部署静态网页的功能，但是由于国内访问比较慢，这里提供一个相对较快的解决办法，就是用GitHub+Vercel。\u003c/p\u003e","title":"搭建个人网站:GitHub+Vercel"},{"content":"😀😁😂🤣😃😄😅😆\n","permalink":"https://lesanouo.github.io/blog/about/","summary":"about","title":"👨‍💻 关于我"}]