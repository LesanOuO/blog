[{"content":"本文主要介绍如何通过GitHub+Vercel免费搭建一个自己的静态网页。\nGitHub Pages GitHub Pages是GitHub提供给大家的快速部署静态网页的功能，但是由于国内访问比较慢，这里提供一个相对较快的解决办法，就是用GitHub+Vercel。\n第一步：注册登录Vercel 我想大家应该都有GitHub账号吧，这里就不多说了。\n点击Vercel官网,并使用GitHub登录。\n注意⚠️：GitHub账号不要使用QQ邮箱作为主邮箱。如果已经用QQ邮箱注册了GitHub，可以到Setting -\u0026gt; Emails里修改自己的主邮箱。\n第二步：导入仓库 它会让你选择一种登录Vercel的方法，支持使用GitHub，GitLab和Bitbucket登录，这里我们选GitHub，后面就是无脑Next的步骤。\n顺利的话稍等片刻就会弹出部署成功的页面，还有浮夸的撒花。\n部署完成之后可以点击visit进入网页看看效果。\n第三步：配置域名 1.点击view Domains进行绑定自己的域名或者点击 Settings👉Domains👉输入自己的域名\n2.输入自己的域名，然后点Add，它会弹出来一些需要做的配置，接下来需要去我们的域名提供商那里根据Vercel给出的要求进行配置。需要修改的有：Name Servers以及域名解析\n最后等待等这两个改动都生效之后就可以用我们自己的域名访问刚刚建立的网站啦~\n以后想要修改网站的话，只需要将改动push到GitHub上，vercel会自动把改动同步过来，完全不用管，超省心。\n在一级域名配置好之后，也可以直接在vercel中使用二级域名，无需进行额外设置。\n","permalink":"https://lesan.fun/posts/share/static-site-github-vercel/","summary":"\u003cp\u003e本文主要介绍如何通过GitHub+Vercel免费搭建一个自己的静态网页。\u003c/p\u003e\n\u003ch3 id=\"github-pages\"\u003eGitHub Pages\u003c/h3\u003e\n\u003cp\u003eGitHub Pages是GitHub提供给大家的快速部署静态网页的功能，但是由于国内访问比较慢，这里提供一个相对较快的解决办法，就是用GitHub+Vercel。\u003c/p\u003e","title":"搭建个人网站:GitHub+Vercel"},{"content":"单线程与多线程可以看作是：\n单线程为在一个单向行驶的道路上，每辆汽车都遵守交通规则 多线程为多条车道，这样在同一时间内，通行的车辆数远远大于单车道 然而扩充了车道后问题就没那么简单了，车道一旦多起来加塞的场景就会越来越多，出现碰撞后也会影响整条马路的通行效率，这样多车道就不一定比单车道更快了\n为了解决汽车频繁变道加塞的问题，可以通过在车道间增加护栏来规范管理\n在程序中处理多线程带来的问题归纳起来就三类：\n线程安全问题 活跃性问题 性能问题 线程安全问题 原子性 有一个非常经典的例子，比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元，两个操作都成功才意味着一次转账最终成功\n试想一下，如果这两个操作不具备原子性，从A的账户扣减了1000元之后，操作突然终止了，账户B没有增加1000元，那问题就大了\n银行转账这个例子有两个步骤，出现了意外后导致转账失败，说明没有原子性\n原子性：即一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行\n原子操作：即不会被线程调度机制打断的操作，没有上下文切换\n在并发编程中很多操作都不是原子操作，出个小题目：\ni = 0; // 操作1 i++; // 操作2 i = j; // 操作3 i = i + 1; // 操作4 上面这四个操作中有哪些是原子操作，哪些不是？不熟悉的人可能认为这些都是原子操作，其实只有操作1是原子操作\n操作1：对基本数据类型变量的赋值是原子操作 操作2：包含三个操作，读取i的值，将i加1，将值赋给i 操作3：读取j的值，将j的值赋给i 操作4：包含三个操作，读取i的值，将i加1，将值赋给i 在单线程环境下上述四个操作都不会出现问题，但是在多线程环境下，如果不通过加锁操作，往往可能得到意料之外的值\n在Java语言中通过可以使用synchronize或者lock来保证原子性\n可见性 可见性：指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值\nclass Test { int i = 50; int j = 0; public void update() { // 线程1执行 i = 100; } public int get() { // 线程2执行 j = i; return j; } } 线程1执行update方法将 i 赋值为100，一般情况下线程1会在自己的工作内存中完成赋值操作，却没有及时将新值刷新到主内存中\n这个时候线程2执行get方法，首先会从主内存中读取i的值，然后加载到自己的工作内存中，这个时候读取到i的值是50，再将50赋值给j，最后返回j的值就是50了。原本期望返回100，结果返回50，这就是可见性问题，线程1对变量i进行了修改，线程2没有立即看到i的新值\n如上图每个线程都有属于自己的工作内存，工作内存和主内存间需要通过store和load等进行交互\n为了解决多线程可见性问题，Java语言提供了 volatile 这个关键字。当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。而普通共享变量不能保证可见性，因为变量被修改后什么时候刷回到主存是不确定的，另外一个线程读的可能就是旧值\n当然Java的锁机制如synchronize和lock也是可以保证可见性的，加锁可以保证在同一时刻只有一个线程在执行同步代码块，释放锁之前会将变量刷回至主存，这样也就保证了可见性\n活跃性问题 上面讲到为了解决 可见性问题，我们可以采取加锁方式解决，但是如果加锁使用不当也容易引入其他问题，比如死锁\n活跃性是指某件正确的事情最终会发生，当某个操作无法继续下去的时候，就会发生活跃性问题\n活跃性问题一般有这样几类：死锁，活锁，饥饿 问题\n死锁 死锁是指多个线程因为环形的等待锁的关系而永远的阻塞下去 活锁 死锁是两个线程都在等待对方释放锁导致阻塞。而活锁的意思是线程没有阻塞，还活着呢。\n当多个线程都在运行并且修改各自的状态，而其他线程彼此依赖这个状态，导致任何一个线程都无法继续执行，只能重复着自身的动作和修改自身的状态，这种场景就是发生了活锁\n如果大家还有疑惑，那我再举一个生活中的例子，大家平时在走路的时候，迎面走来一个人，两个人互相让路，但是又同时走到了一个方向，如果一直这样重复着避让，这俩人就是发生了活锁\n饥饿 如果一个线程无其他异常却迟迟不能继续运行，那基本是处于饥饿状态了\n常见有几种场景:\n高优先级的线程一直在运行消耗CPU，所有的低优先级线程一直处于等待 一些线程被永久堵塞在一个等待进入同步块的状态，而其他线程总是能在它之前持续地对该同步块进行访问 有一个非常经典的饥饿问题就是哲学家用餐问题，如下图所示，有五个哲学家在用餐，每个人必须要同时拿两把叉子才可以开始就餐，如果哲学家1和哲学家3同时开始就餐，那哲学家2、4、5就得饿肚子等待了 性能问题 前面讲到了线程安全和死锁、活锁这些问题会影响多线程执行过程，如果这些都没有发生，多线程并发一定比单线程串行执行快吗，答案是不一定，因为多线程有 创建线程和 线程上下文切换的开销\n创建线程是直接向系统申请资源的，对操作系统来说创建一个线程的代价是十分昂贵的，需要给它分配内存、列入调度等\n线程创建完之后，还会遇到 线程上下文切换 CPU是很宝贵的资源，速度也非常快，为了保证雨露均沾，通常会给不同的线程分配 时间片，当CPU从执行一个线程切换到执行另一个线程时，CPU需要保存当前线程的本地数据、程序指针等状态，并加载下一个要执行的线程的本地数据、程序指针等，这个开关被称为上下文切换\n一般减少上下文切换的方法有：无锁并发编程、CAS 算法、使用协程等\n总结 多线程用好了可以让程序的效率成倍提升，用不好可能比单线程还要慢 ","permalink":"https://lesan.fun/posts/knowledge/multi-thread/","summary":"\u003cp\u003e单线程与多线程可以看作是：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e单线程为在一个单向行驶的道路上，每辆汽车都遵守交通规则\u003c/li\u003e\n\u003cli\u003e多线程为多条车道，这样在同一时间内，通行的车辆数远远大于单车道\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e然而扩充了车道后问题就没那么简单了，车道一旦多起来\u003cstrong\u003e加塞\u003c/strong\u003e的场景就会越来越多，出现碰撞后也会影响整条马路的通行效率，这样多车道就不一定比单车道更快了\u003c/p\u003e","title":"多线程下的琐事"},{"content":"如电脑设置了网络代理，会导致一些软件工具不能正常工作。查找了网上许多解决方案，总结如下。\nGit 设置全局Config代理 git config --global http.proxy http://server:port git config --global https.proxy http://server:port git config --global http.https://github.com.proxy http://server:port git config --global https.https://github.com.proxy http://server:port 去除代理设置 git config --global --unset http.proxy git config --global --unset https.proxy git config --global --unset http.https://github.com.proxy git config --global --unset https.https://github.com.proxy 当我使用这种方式时没有效果\n使用clone时配置代理 git clone -c http.proxy=\u0026#34;server:port\u0026#34; https://github.com/LesanOuO/lesan-homepage.git NPM 全局设置代理 npm config set proxy http://server:port\n配置https代理（设置了proxy就不需要设置https-proxy） npm config set https-proxy http://server:port\n如果需要代理用户名和密码 npm config set proxy http://username:password@server:port npm confit set https-proxy http://username:password@server:port 取消代理 npm config delete proxy npm config delete https-proxy npm config set proxy null npm config set https-proxy null Maven 需要在 settings.xml中配置 proxies节点\n... \u0026lt;proxies\u0026gt; \u0026lt;proxy\u0026gt; \u0026lt;id\u0026gt;optional\u0026lt;/id\u0026gt; \u0026lt;active\u0026gt;true\u0026lt;/active\u0026gt; \u0026lt;protocol\u0026gt;http\u0026lt;/protocol\u0026gt; \u0026lt;host\u0026gt;127.0.0.1\u0026lt;/host\u0026gt; \u0026lt;port\u0026gt;8888\u0026lt;/port\u0026gt; \u0026lt;/proxy\u0026gt; \u0026lt;/proxies\u0026gt; ... Yum 在文件 /etc/yum.conf 中添加以下设置\nproxy=http://192.168.1.1:8080\rproxy_username=username\rproxy_password=password 也可以通过设置环境变量配置\nexport http_proxy=\u0026#34;http://username:password@192.168.1.1:8080\u0026#34;\rexport https_proxy=\u0026#34;http://username:password@192.168.1.1:8080\u0026#34; 清除环境变量取消代理配置 unset http_proxy\n","permalink":"https://lesan.fun/posts/share/proxy-things/","summary":"\u003cp\u003e如电脑设置了网络代理，会导致一些软件工具不能正常工作。查找了网上许多解决方案，总结如下。\u003c/p\u003e\n\u003ch2 id=\"git\"\u003eGit\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e设置全局Config代理\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit config --global http.proxy http://server:port\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit config --global https.proxy http://server:port\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit config --global http.https://github.com.proxy http://server:port\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit config --global https.https://github.com.proxy http://server:port\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e去除代理设置\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit config --global --unset http.proxy\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit config --global --unset https.proxy\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit config --global --unset http.https://github.com.proxy\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit config --global --unset https.https://github.com.proxy\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cblockquote\u003e\n\u003cp\u003e当我使用这种方式时没有效果\u003c/p\u003e","title":"设置网络代理后需要注意"},{"content":"在编写数据库文档时，我们常常需要写表结构文档，这时候就需要一些方法来节约我们写文档的时间。\n我通过网络上的资料，总结了 MySQL 及 SQL Server 的通过SQL语句导出数据库表结构的方法。\nMySQL SELECT COLUMN_NAME 列名, COLUMN_TYPE 数据类型, DATA_TYPE 字段类型, CHARACTER_MAXIMUM_LENGTH 长度, IS_NULLABLE 是否为空, COLUMN_DEFAULT 默认值, COLUMN_COMMENT 备注 FROM INFORMATION_SCHEMA.COLUMNS WHERE table_schema = \u0026#39;数据库名称\u0026#39; -- 数据库名称 AND table_name = \u0026#39;表名\u0026#39; -- 表名 -- 如果不写的话，默认会查询出所有表中的数据，这样可能就分不清到底哪些字段是哪张表中的了，所以还是建议写上要导出的名名称 SQL Server SELECT 表名 = Case When A.colorder=1 Then D.name Else \u0026#39;\u0026#39; End, 表说明 = Case When A.colorder=1 Then isnull(F.value,\u0026#39;\u0026#39;) Else \u0026#39;\u0026#39; End, 字段序号 = A.colorder, 字段名 = A.name, 字段说明 = isnull(G.[value],\u0026#39;\u0026#39;), 标识 = Case When COLUMNPROPERTY( A.id,A.name,\u0026#39;IsIdentity\u0026#39;)=1 Then \u0026#39;√\u0026#39;Else \u0026#39;\u0026#39; End, 主键 = Case When exists(SELECT 1 FROM sysobjects Where xtype=\u0026#39;PK\u0026#39; and parent_obj=A.id and name in ( SELECT name FROM sysindexes WHERE indid in( SELECT indid FROM sysindexkeys WHERE id = A.id AND colid=A.colid))) then \u0026#39;√\u0026#39; else \u0026#39;\u0026#39; end, 类型 = B.name, 占用字节数 = A.Length, 长度 = COLUMNPROPERTY(A.id,A.name,\u0026#39;PRECISION\u0026#39;), 小数位数 = isnull(COLUMNPROPERTY(A.id,A.name,\u0026#39;Scale\u0026#39;),0), 允许空 = Case When A.isnullable=1 Then \u0026#39;√\u0026#39;Else \u0026#39;\u0026#39; End, 默认值 = isnull(E.Text,\u0026#39;\u0026#39;) FROM syscolumns A Left Join systypes B On A.xusertype=B.xusertype Inner Join sysobjects D On A.id=D.id and D.xtype=\u0026#39;U\u0026#39; and D.name\u0026lt;\u0026gt;\u0026#39;dtproperties\u0026#39; Left Join syscomments E on A.cdefault=E.id Left Join sys.extended_properties G on A.id=G.major_id and A.colid=G.minor_id Left Join sys.extended_properties F On D.id=F.major_id and F.minor_id=0 where d.name=\u0026#39;表名\u0026#39; --如果只查询指定表,加上此条件 Order By A.id,A.colorder ","permalink":"https://lesan.fun/posts/share/sql-export-excel/","summary":"\u003cp\u003e在编写数据库文档时，我们常常需要写表结构文档，这时候就需要一些方法来节约我们写文档的时间。\u003c/p\u003e\n\u003cp\u003e我通过网络上的资料，总结了 \u003ccode\u003eMySQL\u003c/code\u003e 及 \u003ccode\u003eSQL Server\u003c/code\u003e 的通过SQL语句导出数据库表结构的方法。\u003c/p\u003e","title":"通过SQL导出数据库表结构"},{"content":"在代码中遇到了网络请求编程时，往往需要异步编程才能给用户带来良好的体验，不会导致程序完全阻塞。 其中的关键在于：\n异步方法：再执行完成前就立刻返回调用方法，在调用方法执行过程中完成任务 async/await 结构主要分为三个部分： 调用方法：该方法调用异步方法，然后在异步方法回调后继续执行后续程序 异步方法：该方法异步执行程序，在被调用后立即返回到调用方法 await 表达式：用于异步等待，指出需要异步执行的任务，且需要等待其完成。一个方法可以包含多个await 什么是异步 启动程序时，系统会在内存中创建一个新的进程。进程是构成运行程序资源的集合。在进程内部，有称为线程的内核对象，它代表的是真正的执行程序。系统会在 Main 方法的第一行语句就开始线程的执行。\n线程：\n默认情况，一个进程只包含一个线程，从程序的开始到执行结束 线程可以派生自其它线程，所以一个进程可以包含不同状态的多个线程，来执行程序的不同部分 一个进程中的多个线程，将共享该进程的资源 系统为处理器执行所规划的单元是线程，而非进程 下面我们来看一个简单的例子\nclass Program { // 创建计时器 private static readonly Stopwatch Watch = new Stopwatch(); private static void Main(string[] args) { // 启动计时器 Watch.Start(); const string url1 = \u0026#34;http://www.cnblogs.com/\u0026#34;; const string url2 = \u0026#34;http://www.cnblogs.com/liqingwen/\u0026#34;; // 两次调用 CountCharactersAsync 方法（异步下载某网站内容，并统计字符的个数） Task\u0026lt;int\u0026gt; t1 = CountCharactersAsync(1, url1); Task\u0026lt;int\u0026gt; t2 = CountCharactersAsync(2, url2); // 三次调用 ExtraOperation 方法（主要是通过拼接字符串达到耗时操作） for (var i = 0; i \u0026lt; 3; i++) { ExtraOperation(i + 1); } // 控制台输出 Console.WriteLine($\u0026#34;{url1} 的字符个数：{t1.Result}\u0026#34;); Console.WriteLine($\u0026#34;{url2} 的字符个数：{t2.Result}\u0026#34;); Console.Read(); } // 统计字符个数 private static async Task\u0026lt;int\u0026gt; CountCharactersAsync(int id, string address) { var wc = new WebClient(); Console.WriteLine($\u0026#34;开始调用 id = {id}：{Watch.ElapsedMilliseconds} ms\u0026#34;); var result = await wc.DownloadStringTaskAsync(address); Console.WriteLine($\u0026#34;调用完成 id = {id}：{Watch.ElapsedMilliseconds} ms\u0026#34;); return result.Length; } // 额外操作 private static void ExtraOperation(int id) { // 这里是通过拼接字符串进行一些相对耗时的操作，如果对字符串拼接有性能要求的话应该使用 StringBuilder var s = \u0026#34;\u0026#34;; for (var i = 0; i \u0026lt; 6000; i++) { s += i; } Console.WriteLine($\u0026#34;id = {id} 的 ExtraOperation 方法完成：{Watch.ElapsedMilliseconds} ms\u0026#34;); } } 同步情况下的调用顺序为： 异步情况下的调用顺序为： 从上面两种情况可以看出异步编程优势，现在我们来分析一下程序的步骤：\n从 Main 方法执行到 CountCharactersAsync(1, url1) 方法时，该方法会立即返回，然后才会调用它内部的方法开始下载内容。该方法返回的是一个 Task\u0026lt;int\u0026gt; 类型的占位符对象，表示计划进行的工作。这个占位符最终会返回 int 类型的值 这样就可以不必等 CountCharactersAsync(1, url1) 方法执行完成就可以继续进行下一步操作。到执行 CountCharactersAsync(2, url2) 方法时，跟 步骤① 一样返回 Task\u0026lt;int\u0026gt; 对象 然后，Main 方法继续执行三次 ExtraOperation 方法，同时两次 CountCharactersAsync 方法依然在持续工作 t1.Result 和 t2.Result 是指从 CountCharactersAsync 方法调用的 Task\u0026lt;int\u0026gt; 对象取结果，如果还没有结果的话，将阻塞，直有结果返回为止 async/await 结构 async/await 结构主要分为三个部分：\n调用方法：该方法调用异步方法，然后在异步方法回调后继续执行后续程序 异步方法：该方法异步执行程序，在被调用后立即返回到调用方法 await 表达式：用于异步等待，指出需要异步执行的任务，且需要等待其完成。一个方法可以包含多个await 示例结构分析如下： await 都做了些什么 为了了解程序 await 时，C#都做了些什么工作，我们就必须了解以下内容\n方法的状态 首先，方法内所有的本地变量的值都会被记住，包括\n方法的参数 在方法的作用域内定义的任何变量 任何其它变量，比如循环中使用到的计数变量 如果你的方法不是static的，则还要包括this变量。只有记住了this，当方法恢复执行(resume)时，才可以使用当前类的成员变量。 上述的这些都会被存储在.NET垃圾回收堆里的一个对象中。因此，当你使用await时，.NET就会创建这样一个对象，虽然它会占用一些资源，但在大多数情况下并不会导致性能问题。\nC#还要记住在方法内部await执行到了哪里——可以通过使用一个数字来表示当前方法中执行到了哪一个await关键字。\n具体如何使用await表达式？这其实没有限制，例如，await可以被用做一个大表达式的一部分，一个表达式也可能包含多个await.\nint myNum = await AlexsMethodAsync(await myTask, await StuffAsync());\n这样就对.NET运行时提出了额外的需求——当await一个表达式时，需要记住表达式剩余部分的状态。在上面的例子中，当程序执行await StuffAsync()时，await myTask的结果就需要被记录下来。.NET IL会将这类子表达式存储在栈上，因此当使用了await关键字时就需要把这个栈存储下来。\n在这之上，当程序执行到第一个await时，当前方法会返回——除非方法是async void，否则这时就会返回一个Task，因此调用者可以通过某种方式等待任务完成。C# 还必须把操作该返回Task的方法存储下来，这样当我们的方法完成后，前面返回的Task才会变为完成的状态，这样程序才会向上返回一层，回到方法的异步链中去继续执行。我们会在第14章探讨这些额外的机制。\n上下文（Context） C#在使用await时会记录各种各样的上下文，目的是当要继续执行方法时能够恢复这个上下文，这样就尽可能地将await的处理过程变得透明。这些上下文中最重要的就是同步上下文（sychronization context），通过它的帮助可以在指定类型的线程上恢复方法的执行。\n异步方法的结构 关键字：方法头使用 async 修饰。 要求：包含 N（N\u0026gt;0） 个 await 表达式（不存在 await 表达式的话 IDE 会发出警告），表示需要异步执行的任务。 返回类型：只能返回 3 种类型（void、Task 和 Task\u0026lt;T\u0026gt;）。Task 和 Task\u0026lt;T\u0026gt; 标识返回的对象会在将来完成工作，表示调用方法和异步方法可以继续执行。 参数：数量不限，但不能使用 out 和 ref 关键字。 命名约定：方法后缀名应以 Async 结尾。 其它：匿名方法和 Lambda 表达式也可以作为异步对象；async 是一个上下文关键字；关键字 async 必须在返回类型前。 本文参考自：\nhttps://www.cnblogs.com/tuyile006/p/12605523.html\nhttps://www.cnblogs.com/tuyile006/p/12605523.html\n","permalink":"https://lesan.fun/posts/knowledge/csharp-async-await/","summary":"\u003cp\u003e在代码中遇到了网络请求编程时，往往需要异步编程才能给用户带来良好的体验，不会导致程序完全阻塞。\n其中的关键在于：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e异步方法：再执行完成前就立刻返回调用方法，在调用方法执行过程中完成任务\u003c/li\u003e\n\u003cli\u003easync/await 结构主要分为三个部分：\n\u003col\u003e\n\u003cli\u003e调用方法：该方法调用异步方法，然后在异步方法回调后继续执行后续程序\u003c/li\u003e\n\u003cli\u003e异步方法：该方法异步执行程序，在被调用后立即返回到调用方法\u003c/li\u003e\n\u003cli\u003eawait 表达式：用于异步等待，指出需要异步执行的任务，且需要等待其完成。一个方法可以包含多个await\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"什么是异步\"\u003e什么是异步\u003c/h2\u003e\n\u003cp\u003e启动程序时，系统会在内存中创建一个新的进程。进程是构成运行程序资源的集合。在进程内部，有称为线程的内核对象，它代表的是真正的执行程序。系统会在 Main 方法的第一行语句就开始线程的执行。\u003c/p\u003e","title":"C#中async和await异步编程"},{"content":"索引 MySQL 索引 MySQL 的索引有两种分类方式：逻辑分类和物理分类\n逻辑分类 主键索引：一张表只能有一个主键索引，不允许重复、不允许为 NULL 唯一索引：数据列不允许重复，允许为 NULL 值，一张表可有多个唯一索引，索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一 普通索引：一张表可以创建多个普通索引，一个普通索引可以包含多个字段，允许数据重复，允许 NULL 值插入 全文索引：它查找的是文本中的关键词，主要用于全文检索 单例索引：一个索引只包含一个列，一个表可以有多个单例索引 组合索引：一个组合索引包含两个或两个以上的列。查询的时候遵循 mysql 组合索引的 “最左前缀”原则，即使用 where 时条件要按照建立索引的时候字段的排列方式放置索引才会生效 物理分类 聚簇索引：不是单独的一种索引类型，而是一种数据存储方式。这种存储方式是依靠B+树来实现的，根据表的主键构造一棵B+树且B+树叶子节点存放的都是表的行记录数据时，方可称该主键索引为聚簇索引。聚簇索引也可理解为将数据存储与索引放到了一块，找到索引也就找到了数据。 非聚簇索引：数据和索引是分开的，B+树叶子节点存放的不是数据表的行记录 EXPLAIN 使用格式：EXPLAIN SQL...;\n返回结果包含：\nid:选择标识符 select_type:表示查询的类型。 table:输出结果集的表 partitions:匹配的分区 type:表示表的连接类型 possible_keys:表示查询时，可能使用的索引 key:表示实际使用的索引 key_len:索引字段的长度 ref:列与索引的比较 rows:扫描出的行数(估算的行数) filtered:按表条件过滤的行百分比 Extra:执行情况的描述和说明 SQL Server 索引 唯一索引（UNIQUE）：唯一索引不允许两行具有相同的索引值 主键索引：为表定义一个主键将自动创建主键索引，主键索引是唯一索引的特殊类型。主键索引要求主键中的每个值是唯一的，并且不能为空 聚集索引(Clustered)：表中各行的物理顺序与键值的逻辑（索引）顺序相同，每个表最多只能有一个，设置某列为主键，该列就默认为聚集索引 非聚集索引(NonClustered)：非聚集索引指定表的逻辑顺序。数据存储在一个位置，索引存储在另一个位置，索引中包含指向数据存储位置的指针。可以有多个，小于249个 SQL 优化 总结SQL优化中，就三点:\n最大化利用索引； 尽可能避免全表扫描； 减少无效数据的查询； 避免不走索引的场景 1. 尽量避免在字段开头模糊查询，会导致数据库引擎放弃索引进行全表扫码 例如： SELECT * FROM user WHERE name LIKE '%李%'\n优化方式：尽量在字段后面使用模糊查询，例如： SELECT * FROM user WHERE name LIKE '李%'\n如果需要在前面使用模糊查询，可以使用以下方式：\n使用MySQL内置函数 INSTR(str, substr)，返回匹配子串的位置,类似Java中的 str.indexOf(substr) 使用FullText全文索引，用match against检索 数据量较大的情况，使用ElasticSearch、solr，亿级数据量检索速度秒级 当数据量较少时（几千条），直接用 LIKE '%李%' 2. 尽量避免使用in和not in，会导致全表扫描 SELECT * FROM table WHERE id IN (2,3)\n优化方式：如果是连续数值，可以使用between代替，例如: SELECT * FROM table WHERE id BETWEEN 2 AND 3\n如果是子查询，可以使用 EXISTS或 NOT EXISTS代替，例如: SELECT * FROM table WHERE EXISTS (SELECT id FROM table2 WHERE table.id = table2.id)\n3. 尽量避免使用OR，会导致全表扫描 SELECT * FROM table WHERE id = 1 OR id = 2\n优化方式：可以使用Union，例如: SELECT * FROM table WHERE id = 1 UNION SELECT * FROM table WHERE id = 2\n4. 尽量避免null值的判断 SELECT * FROM table WHERE id IS NULL\n优化方式：可以给字段添加默认值，对默认值进行判断，例如： SELECT * FROM table WHERE id = 默认值\n5. 尽量避免在where条件中等号左侧进行表达式、函数操作 可以将表达式、函数操作移动到等号右侧，例如：\n-- 全表扫码 SELECT * FROM table WHERE score/10 = 9 -- 走索引 SELECT * FROM table WHERE score = 10 * 9 6. 当数据量大时，避免使用where 1=1的条件 通常为了方便拼接查询条件，会使用它来作为条件\n优化方式：用代码拼接sql时进行判断，没where条件就去掉where，有where条件就加and\n7. 查询条件不能用\u0026lt;\u0026gt;或者!= 使用索引列作为条件进行查询时，需要避免使用\u0026lt;\u0026gt;或者!=等判断条件。如确实业务需要，使用到不等于符号，需要在重新评估索引建立，避免在此字段上建立索引，改由查询条件中其他索引字段代替\n8. where条件仅包含复合索引非前置列 如下：复合（联合）索引包含key_part1，key_part2，key_part3三列，但SQL语句没有包含索引前置列\u0026quot;key_part1\u0026quot;，按照MySQL联合索引的最左匹配原则，不会走联合索引 select col1 from table where key_part2=1 and key_part3=2\n9. 隐式类型转换造成不使用索引 如下SQL语句由于索引对列类型为varchar，但给定的值为数值，涉及隐式类型转换，造成不能正确走索引 select col1 from table where col_varchar=123; 10. order by 条件要与where中条件一致，否则order by不会利用索引进行排序 -- 不走age索引 SELECT * FROM t order by age; -- 走age索引 SELECT * FROM t where age \u0026gt; 0 order by age; 当order by 中的字段出现在where条件中时，才会利用索引而不再二次排序，更准确的说，order by 中的字段在执行计划中利用了索引时，不用排序操作\n这个结论不仅对order by有效，对其他需要排序的操作也有效。比如group by 、union 、distinct等\n11. 正确使用hint优化语句 MySQL中可以使用hint指定优化器在执行时选择或忽略特定的索引。一般而言，处于版本变更带来的表结构索引变化，更建议避免使用hint，而是通过Analyze table多收集统计信息。但在特定场合下，指定hint可以排除其他索引干扰而指定更优的执行计划。\nUSE INDEX 在你查询语句中表名的后面，添加 USE INDEX 来提供希望 MySQL 去参考的索引列表，就可以让 MySQL 不再考虑其他可用的索引。例子: SELECT col1 FROM table USE INDEX (mod_time, name)\u0026hellip; IGNORE INDEX 如果只是单纯的想让 MySQL 忽略一个或者多个索引，可以使用 IGNORE INDEX 作为 Hint。例子: SELECT col1 FROM table IGNORE INDEX (priority) \u0026hellip; FORCE INDEX 为强制 MySQL 使用一个特定的索引，可在查询中使用FORCE INDEX 作为Hint。例子: SELECT col1 FROM table FORCE INDEX (mod_time) \u0026hellip; 在查询的时候，数据库系统会自动分析查询语句，并选择一个最合适的索引。但是很多时候，数据库系统的查询优化器并不一定总是能使用最优索引。如果我们知道如何选择索引，可以使用FORCE INDEX强制查询使用指定的索引。\n例如：SELECT * FROM students FORCE INDEX (idx_class_id) WHERE class_id = 1 ORDER BY id DESC;\nSELECT语句其他优化 1. 避免出现select * 首先，select * 操作在任何类型数据库中都不是一个好的SQL编写习惯。\n使用select * 取出全部列，会让优化器无法完成索引覆盖扫描这类优化，会影响优化器对执行计划的选择，也会增加网络带宽消耗，更会带来额外的I/O,内存和CPU消耗。\n建议提出业务实际需要的列数，将指定列名以取代select *。\n2. 避免出现不确定结果的函数 特定针对主从复制这类业务场景。由于原理上从库复制的是主库执行的语句，使用如now()、rand()、sysdate()、current_user()等不确定结果的函数很容易导致主库与从库相应的数据不一致。另外不确定值的函数,产生的SQL语句无法利用query cache。\n3.多表关联查询时，小表在前，大表在后。 在MySQL中，执行 from 后的表关联查询是从左往右执行的（Oracle相反），第一张表会涉及到全表扫描，所以将小表放在前面，先扫小表，扫描快效率较高，在扫描后面的大表，或许只扫描大表的前100行就符合返回条件并return了。\n例如：表1有50条数据，表2有30亿条数据；如果全表扫描表2，你品，那就先去吃个饭再说吧是吧。\n4. 使用表的别名 当在SQL语句中连接多个表时，请使用表的别名并把别名前缀于每个列名上。这样就可以减少解析的时间并减少哪些友列名歧义引起的语法错误。\n5. 用where字句替换HAVING字句 避免使用HAVING字句，因为HAVING只会在检索出所有记录之后才对结果集进行过滤，而where则是在聚合前刷选记录，如果能通过where字句限制记录的数目，那就能减少这方面的开销。HAVING中的条件一般用于聚合函数的过滤，除此之外，应该将条件写在where字句中。\nwhere和having的区别：where后面不能使用组函数\n6.调整Where字句中的连接顺序 MySQL采用从左往右，自上而下的顺序解析where子句。根据这个原理，应将过滤数据多的条件往前放，最快速度缩小结果集。\n增删改 DML 语句优化 1. 大批量插入数据 如果同时执行大量的插入，建议使用多个值的INSERT语句(方法二)。这比使用分开INSERT语句快（方法一），一般情况下批量插入效率有几倍的差别。\n方法一：\ninsert into T values(1,2); insert into T values(1,3); insert into T values(1,4); 方法二：\nInsert into T values(1,2),(1,3),(1,4); 选择后一种方法的原因有三。\n减少SQL语句解析的操作，MySQL没有类似Oracle的share pool，采用方法二，只需要解析一次就能进行数据的插入操作； 在特定场景可以减少对DB连接次数 SQL语句较短，可以减少网络传输的IO。 2. 适当使用commit 适当使用commit可以释放事务占用的资源而减少消耗，commit后能释放的资源如下：\n事务占用的undo数据块； 事务在redo log中记录的数据块； 释放事务施加的，减少锁争用影响性能。特别是在需要使用delete删除大量数据的时候，必须分解删除量并定期commit。 3. 避免重复查询更新的数据 针对业务中经常出现的更新行同时又希望获得改行信息的需求，MySQL并不支持PostgreSQL那样的UPDATE RETURNING语法，在MySQL中可以通过变量实现。\n例如，更新一行记录的时间戳，同时希望查询当前记录中存放的时间戳是什么，简单方法实现：\nUpdate t1 set time=now() where col1=1; Select time from t1 where id =1; 使用变量，可以重写为以下方式：\nUpdate t1 set time=now () where col1=1 and @now: = now (); Select @now; 前后二者都需要两次网络来回，但使用变量避免了再次访问数据表，特别是当t1表数据量较大时，后者比前者快很多。\n4.查询优先还是更新（insert、update、delete）优先 MySQL 还允许改变语句调度的优先级，它可以使来自多个客户端的查询更好地协作，这样单个客户端就不会由于锁定而等待很长时间。改变优先级还可以确保特定类型的查询被处理得更快。我们首先应该确定应用的类型，判断应用是以查询为主还是以更新为主的，是确保查询效率还是确保更新的效率，决定是查询优先还是更新优先。下面我们提到的改变调度策略的方法主要是针对只存在表锁的存储引擎，比如 MyISAM 、MEMROY、MERGE，对于Innodb 存储引擎，语句的执行是由获得行锁的顺序决定的。MySQL 的默认的调度策略可用总结如下：\n1）写入操作优先于读取操作。\n2）对某张数据表的写入操作某一时刻只能发生一次，写入请求按照它们到达的次序来处理。\n3）对某张数据表的多个读取操作可以同时地进行。MySQL 提供了几个语句调节符，允许你修改它的调度策略：\nLOW_PRIORITY关键字应用于DELETE、INSERT、LOAD DATA、REPLACE和UPDATE； HIGH_PRIORITY关键字应用于SELECT和INSERT语句； DELAYED关键字应用于INSERT和REPLACE语句。 如果写入操作是一个 LOW_PRIORITY（低优先级）请求，那么系统就不会认为它的优先级高于读取操作。在这种情况下，如果写入者在等待的时候，第二个读取者到达了，那么就允许第二个读取者插到写入者之前。只有在没有其它的读取者的时候，才允许写入者开始操作。这种调度修改可能存在 LOW_PRIORITY写入操作永远被阻塞的情况。\nSELECT 查询的HIGH_PRIORITY（高优先级）关键字也类似。它允许SELECT 插入正在等待的写入操作之前，即使在正常情况下写入操作的优先级更高。另外一种影响是，高优先级的 SELECT 在正常的 SELECT 语句之前执行，因为这些语句会被写入操作阻塞。如果希望所有支持LOW_PRIORITY 选项的语句都默认地按照低优先级来处理，那么 请使用\u0026ndash;low-priority-updates 选项来启动服务器。通过使用 INSERTHIGH_PRIORITY 来把 INSERT 语句提高到正常的写入优先级，可以消除该选项对单个INSERT语句的影响。\n查询条件优化 1. 对于复杂的查询，可以使用中间临时表暂存数据 2. 优化group by语句 默认情况下，MySQL 会对GROUP BY分组的所有值进行排序，如 “GROUP BY col1，col2，\u0026hellip;.;” 查询的方法如同在查询中指定 “ORDER BY col1，col2，\u0026hellip;;” 如果显式包括一个包含相同的列的 ORDER BY子句，MySQL 可以毫不减速地对它进行优化，尽管仍然进行排序。\n因此，如果查询包括 GROUP BY 但你并不想对分组的值进行排序，你可以指定 ORDER BY NULL禁止排序。例如：\nSELECT col1, col2, COUNT(*) FROM table GROUP BY col1, col2 ORDER BY NULL\n3. 优化join语句 MySQL中可以通过子查询来使用 SELECT 语句来创建一个单列的查询结果，然后把这个结果作为过滤条件用在另一个查询中。使用子查询可以一次性的完成很多逻辑上需要多个步骤才能完成的 SQL 操作，同时也可以避免事务或者表锁死，并且写起来也很容易。但是，有些情况下，子查询可以被更有效率的连接(JOIN)..替代。\n例子：假设要将所有没有订单记录的用户取出来，可以用下面这个查询完成： SELECT col1 FROM customerinfo WHERE CustomerID NOT in (SELECT CustomerID FROM salesinfo )\n如果使用连接(JOIN).. 来完成这个查询工作，速度将会有所提升。尤其是当 salesinfo表中对 CustomerID 建有索引的话，性能将会更好，查询如下：\nSELECT col1 FROM customerinfo LEFT JOIN salesinfoON customerinfo.CustomerID=salesinfo.CustomerID WHERE salesinfo.CustomerID IS NULL 4. 优化union查询 MySQL通过创建并填充临时表的方式来执行union查询。除非确实要消除重复的行，否则建议使用union all。原因在于如果没有all这个关键词，MySQL会给临时表加上distinct选项，这会导致对整个临时表的数据做唯一性校验，这样做的消耗相当高。\n高效：\nSELECT COL1, COL2, COL3 FROM TABLE WHERE COL1 = 10 UNION ALL SELECT COL1, COL2, COL3 FROM TABLE WHERE COL3= \u0026#39;TEST\u0026#39;; 低效：\nSELECT COL1, COL2, COL3 FROM TABLE WHERE COL1 = 10 UNION SELECT COL1, COL2, COL3 FROM TABLE WHERE COL3= \u0026#39;TEST\u0026#39;; 5. 拆分复杂SQL为多个小SQL，避免大事务 简单的SQL容易使用到MySQL的QUERY CACHE； 减少锁表时间特别是使用MyISAM存储引擎的表； 可以使用多核CPU。 6. 使用truncate代替delete 当删除全表中记录时，使用delete语句的操作会被记录到undo块中，删除记录也记录binlog，当确认需要删除全表时，会产生很大量的binlog并占用大量的undo数据块，此时既没有很好的效率也占用了大量的资源。\n使用truncate替代，不会记录可恢复的信息，数据不能被恢复。也因此使用truncate操作有其极少的资源占用与极快的时间。另外，使用truncate可以回收表的水位，使自增字段值归零。\n7. 使用合理的分页方式以提高分页效率 使用合理的分页方式以提高分页效率 针对展现等分页需求，合适的分页方式能够提高分页的效率。\n案例1：\nselect * from t where thread_id = 10000 and deleted = 0 order by gmt_create asc limit 0, 15; 上述例子通过一次性根据过滤条件取出所有字段进行排序返回。数据访问开销=索引IO+索引全部记录结果对应的表数据IO。因此，该种写法越翻到后面执行效率越差，时间越长，尤其表数据量很大的时候。\n适用场景：当中间结果集很小（10000行以下）或者查询条件复杂（指涉及多个不同查询字段或者多表连接）时适用。\n案例2：\nselect t.* from (select id from t where thread_id = 10000 and deleted = 0 order by gmt_create asc limit 0, 15) a, t where a.id = t.id; 上述例子必须满足t表主键是id列，且有覆盖索引secondary key:(thread_id, deleted, gmt_create)。通过先根据过滤条件利用覆盖索引取出主键id进行排序，再进行join操作取出其他字段。数据访问开销=索引IO+索引分页后结果（例子中是15行）对应的表数据IO。因此，该写法每次翻页消耗的资源和时间都基本相同，就像翻第一页一样。\n适用场景：当查询和排序字段（即where子句和order by子句涉及的字段）有对应覆盖索引时，且中间结果集很大的情况时适用。\n建表优化 在表中建立索引，优先考虑where、order by使用到的字段 尽量使用数字型字段（如性别，男：1 女：2），若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会 逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了 查询数据量大的表会造成查询缓慢。主要的原因是扫描行数过多。这个时候可以通过程序，分段分页进行查询，循环遍历，将结果合并处理进行展示。要查询100000到100050的数据: SELECT * FROM (SELECT ROW_NUMBER() OVER(ORDER BY ID ASC) AS rowid,* FROM infoTab)t WHERE t.rowid \u0026gt; 100000 AND t.rowid \u0026lt;= 100050 用varchar/nvarchar 代替 char/nchar 尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。 不要以为 NULL 不需要空间，比如：char(100) 型，在字段建立时，空间就固定了， 不管是否插入值（NULL也包含在内），都是占用 100个字符的空间的，如果是varchar这样的变长字段， null 不占用空间。 ","permalink":"https://lesan.fun/posts/knowledge/database/","summary":"\u003ch1 id=\"索引\"\u003e索引\u003c/h1\u003e\n\u003ch2 id=\"mysql-索引\"\u003eMySQL 索引\u003c/h2\u003e\n\u003cp\u003eMySQL 的索引有两种分类方式：逻辑分类和物理分类\u003c/p\u003e\n\u003ch3 id=\"逻辑分类\"\u003e逻辑分类\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e主键索引：一张表只能有一个主键索引，不允许重复、不允许为 NULL\u003c/li\u003e\n\u003cli\u003e唯一索引：数据列不允许重复，允许为 NULL 值，一张表可有多个唯一索引，索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一\u003c/li\u003e\n\u003cli\u003e普通索引：一张表可以创建多个普通索引，一个普通索引可以包含多个字段，允许数据重复，允许 NULL 值插入\u003c/li\u003e\n\u003cli\u003e全文索引：它查找的是文本中的关键词，主要用于全文检索\u003c/li\u003e\n\u003cli\u003e单例索引：一个索引只包含一个列，一个表可以有多个单例索引\u003c/li\u003e\n\u003cli\u003e组合索引：一个组合索引包含两个或两个以上的列。查询的时候遵循 mysql 组合索引的 “最左前缀”原则，即使用 where 时条件要按照建立索引的时候字段的排列方式放置索引才会生效\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"物理分类\"\u003e物理分类\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e聚簇索引：不是单独的一种索引类型，而是一种数据存储方式。这种存储方式是依靠B+树来实现的，根据表的主键构造一棵B+树且B+树叶子节点存放的都是表的行记录数据时，方可称该主键索引为聚簇索引。聚簇索引也可理解为将数据存储与索引放到了一块，找到索引也就找到了数据。\u003c/li\u003e\n\u003cli\u003e非聚簇索引：数据和索引是分开的，B+树叶子节点存放的不是数据表的行记录\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"explain\"\u003eEXPLAIN\u003c/h3\u003e\n\u003cp\u003e使用格式：\u003ccode\u003eEXPLAIN SQL...\u003c/code\u003e;\u003c/p\u003e","title":"数据库优化"},{"content":"生产者消费者问题（Producer-consumer problem），也称有限缓冲问题（Bounded-buffer problem），是一个多线程同步问题的经典案例。生产者生成一定量的数据放到缓冲区中，然后重复此过程；与此同时，消费者也在缓冲区消耗这些数据。生产者和消费者之间必须保持同步，要保证生产者不会在缓冲区满时放入数据，消费者也不会在缓冲区空时消耗数据。不够完善的解决方法容易出现死锁的情况，此时进程都在等待唤醒。\n下图为生产者和消费者的示意图： 解决思想 保证同一资源被多个线程并发访问时的完整性。常用的同步方法是采用信号或加锁机制，保证资源在任意时刻至多被一个线程访问\nJava实现的几种方式 wait() / notify() 方法 await() / signal() 方法(可重入锁ReentrantLock) BlockingQueue 阻塞队列方法 信号量方法 管道方法 代码实现 wait() / notify() 方法 首先，先介绍一下 Thread.sleep()和 Object.wait()、Object.notify()的区别。\nsleep()是Thread类的方法；而 wait()，notify()，notifyAll()是Object类中定义的方法；尽管这两个方法都会影响线程的执行行为，但是本质上是有区别的 Thread.sleep()不会导致锁行为的改变，如果当前线程是拥有锁的，那么 Thread.sleep()不会让线程释放锁。如果能够帮助你记忆的话，可以简单认为和锁相关的方法都定义在Object类中，因此调用 Thread.sleep()是不会影响锁的相关行为 Thread.sleep和 Object.wait都会暂停当前的线程，对于CPU资源来说，不管是哪种方式暂停的线程，都表示它暂时不再需要CPU的执行时间。OS会将执行时间分配给其它线程。区别是调用wait后，需要别的线程执行notify/notifyAll才能够重新获得CPU执行时间 Thread.sleep()让线程从 【running】 -\u0026gt; 【阻塞态】 时间结束/interrupt -\u0026gt; 【runnable】;Object.wait()让线程从 【running】 -\u0026gt; 【等待队列】notify -\u0026gt; 【锁池】 -\u0026gt; 【runnable】 wait()和notify()方法的实现，缓冲区满和为空时都调用wait()方法等待，当生产者生产了一个数据或者消费者消费了一个数据之后会通过notify()唤醒所有线程。\nimport java.util.*; public class Test { // 缓冲区最大容量 private static final int MAX_SIZE = 100; // 计数 private static int count = 0; // 缓冲区 private static LinkedList\u0026lt;Integer\u0026gt; list = new LinkedList\u0026lt;Integer\u0026gt;(); public static void main(String[] args) { Thread producer = new Thread(new Producer()); Thread consumer = new Thread(new Consumer()); producer.start(); consumer.start(); } // 生产者 public static class Producer implements Runnable { @Override public void run() { while (true) { // 为list上锁 synchronized (list) { // 缓冲区满时，等待 while (list.size() == MAX_SIZE) { try { System.out.println(\u0026#34;list is full, Producer waiting\u0026#34;); list.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } // 生产数据 count++; System.out.println(\u0026#34;Producer produce \u0026#34; + count); list.add(count); // 唤醒消费者 list.notifyAll(); // 等待一段时间再生产 try { Thread.sleep(new Random().nextInt(1000)); } catch (InterruptedException e) { e.printStackTrace(); } } // 当生产100个数就结束 if (count == 100) { break; } } } } // 消费者 public static class Consumer implements Runnable { @Override public void run() { while (true) { // 为list上锁 synchronized (list) { // 缓冲区空时，等待 while (list.isEmpty()) { try { System.out.println(\u0026#34;list is empty, Consumer waiting\u0026#34;); list.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } // 消费数据 int temp = list.poll(); System.out.println(\u0026#34;Consumer consume \u0026#34; + temp); // 唤醒生产者 list.notifyAll(); } // 当消费100个数就结束 if (count == 100 \u0026amp;\u0026amp; list.isEmpty()) { break; } } } } } 执行结果如下： 注意：\nnotifyAll()方法可使所有正在等待队列中等待同一共享资源的“全部”线程从等待状态退出，进入可运行状态。此时，优先级最高的那个线程最先执行，但也有可能是随机执行的，这要取决于JVM虚拟机的实现。即最终也只有一个线程能被运行，上述线程优先级都相同，每次运行的线程都不确定是哪个，后来给线程设置优先级后也跟预期不一样，还是要看JVM的具体实现吧。\nawait() / signal() 方法(可重入锁ReentrantLock) 在JDK5.0之后，Java提供了更加健壮的线程处理机制，包括同步、锁定、线程池等，它们可以实现更细粒度的线程控制。用ReentrantLock和Condition可以实现等待/通知模型，具有更大的灵活性。通过在Lock对象上调用newCondition()方法，将条件变量和一个锁对象进行绑定，进而控制并发程序访问竞争资源的安全。\nCondition接口的await()和signal()就是其中用来做同步的两种方法，它们的功能基本上和Object的wait()/ nofity()相同，完全可以取代它们，但是它们和新引入的锁定机制Lock直接挂钩，具有更大的灵活性。通过在Lock对象上调用newCondition()方法，将条件变量和一个锁对象进行绑定，进而控制并发程序访问竞争资源的安全。\nimport java.util.*; import java.util.concurrent.locks.*; public class Test1 { private static final int MAX_SIZE = 100; private static int count = 0; private static LinkedList\u0026lt;Integer\u0026gt; list = new LinkedList\u0026lt;Integer\u0026gt;(); // 创建锁及其条件 private static final Lock lock = new ReentrantLock(); private static final Condition fullCondition = lock.newCondition(); private static final Condition emptyCondition = lock.newCondition(); public static void main(String[] args) { Thread producer = new Thread(new Producer()); Thread consumer = new Thread(new Consumer()); producer.start(); consumer.start(); } public static class Producer implements Runnable { @Override public void run() { while (true) { // 上锁 lock.lock(); try { // 缓冲区满时，等待 while (list.size() == MAX_SIZE) { try { System.out.println(\u0026#34;list is full, Producer waiting\u0026#34;); fullCondition.await(); } catch (InterruptedException e) { e.printStackTrace(); } } // 生产数据 count++; System.out.println(\u0026#34;Producer produce \u0026#34; + count); list.add(count); // 唤醒消费者 emptyCondition.signalAll(); } finally { lock.unlock(); } try { Thread.sleep(new Random().nextInt(1000)); } catch (InterruptedException e) { e.printStackTrace(); } if (count == 100) { break; } } } } public static class Consumer implements Runnable { @Override public void run() { while (true) { // 上锁 lock.lock(); try { // 缓冲区空时，等待 while (list.isEmpty()) { try { System.out.println(\u0026#34;list is empty, Consumer waiting\u0026#34;); emptyCondition.await(); } catch (InterruptedException e) { e.printStackTrace(); } } // 消费数据 int temp = list.poll(); System.out.println(\u0026#34;Consumer consume \u0026#34; + temp); // 唤醒生产者 fullCondition.signalAll(); } finally { lock.unlock(); } if (count == 100 \u0026amp;\u0026amp; list.isEmpty()) { break; } } } } } 运行结果如下：（与第一种方法类似） BlockingQueue 阻塞队列方法 JDK 1.5 以后新增的 java.util.concurrent包新增了 BlockingQueue 接口。并提供了如下几种阻塞队列实现：\njava.util.concurrent.ArrayBlockingQueue java.util.concurrent.LinkedBlockingQueue java.util.concurrent.SynchronousQueue java.util.concurrent.PriorityBlockingQueue 实现生产者-消费者模型使用 ArrayBlockingQueue或者 LinkedBlockingQueue即可。\n我们这里使用LinkedBlockingQueue，它是一个已经在内部实现了同步的队列，实现方式采用的是我们第2种await()/ signal()方法。它可以在生成对象时指定容量大小。它用于阻塞操作的是put()和take()方法。\nput()方法：类似于我们上面的生产者线程，容量达到最大时，自动阻塞。 take()方法：类似于我们上面的消费者线程，容量为0时，自动阻塞。\nimport java.util.*; import java.util.concurrent.LinkedBlockingQueue; public class Test2 { private static final int MAX_SIZE = 100; private static int count = 0; // 创建阻塞队列 private static LinkedBlockingQueue\u0026lt;Integer\u0026gt; blockingQueue = new LinkedBlockingQueue\u0026lt;Integer\u0026gt;(MAX_SIZE); public static void main(String[] args) { Thread producer = new Thread(new Producer()); Thread consumer = new Thread(new Consumer()); producer.start(); consumer.start(); } public static class Producer implements Runnable { @Override public void run() { while (true) { try { count++; // 生产数据到阻塞队列 blockingQueue.put(count); System.out.println(\u0026#34;Producer produce \u0026#34; + count); } catch (InterruptedException e) { e.printStackTrace(); } try { Thread.sleep(new Random().nextInt(1000)); } catch (InterruptedException e) { e.printStackTrace(); } if (count == 100) { break; } } } } public static class Consumer implements Runnable { @Override public void run() { while (true) { try { // 从阻塞队列消费数据 int value = blockingQueue.take(); System.out.println(\u0026#34;Consumer consume \u0026#34; + value); } catch (InterruptedException e) { e.printStackTrace(); } if (count == 100 \u0026amp;\u0026amp; blockingQueue.isEmpty()) { break; } } } } } 信号量方法 Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源，在操作系统中是一个非常重要的问题，可以用来解决哲学家就餐问题。Java中的Semaphore维护了一个许可集，一开始先设定这个许可集的数量，可以使用acquire()方法获得一个许可，当许可不足时会被阻塞，release()添加一个许可。\nSemaphore可以用来构建一些对象池，资源池之类的，比如数据库连接池，我们也可以创建计数为1的Semaphore，将其作为一种类似互斥锁的机制，这也叫二元信号量，表示两种互斥状态。\n在下列代码中，还加入了另外一个mutex信号量，维护生产者消费者之间的同步关系，保证生产者和消费者之间的交替进行\nimport java.util.*; import java.util.concurrent.Semaphore; public class Test3 { private static final int MAX_SIZE = 100; private static int count = 0; private static LinkedList\u0026lt;Integer\u0026gt; list = new LinkedList\u0026lt;Integer\u0026gt;(); // 创建信号量 final static Semaphore notFull = new Semaphore(MAX_SIZE); final static Semaphore notEmpty = new Semaphore(0); final static Semaphore mutex = new Semaphore(1); public static void main(String[] args) { Thread producer = new Thread(new Producer()); Thread consumer = new Thread(new Consumer()); producer.start(); consumer.start(); } public static class Producer implements Runnable { @Override public void run() { while (true) { try { // 获取许可 notFull.acquire(); mutex.acquire(); // 生产数据 count++; list.add(count); System.out.println(\u0026#34;Producer produce \u0026#34; + count); } catch (InterruptedException e) { e.printStackTrace(); } finally { // 释放许可 mutex.release(); notEmpty.release(); } try { Thread.sleep(new Random().nextInt(1000)); } catch (InterruptedException e) { e.printStackTrace(); } if (count == 100) { break; } } } } public static class Consumer implements Runnable { @Override public void run() { while (true) { try { // 获取许可 notEmpty.acquire(); mutex.acquire(); // 消费数据 int value = list.poll(); System.out.println(\u0026#34;Consumer consume \u0026#34; + value); } catch (InterruptedException e) { e.printStackTrace(); } finally { // 释放许可 mutex.release(); notFull.release(); } if (count == 100 \u0026amp;\u0026amp; list.isEmpty()) { break; } } } } } 管道方法 在java的io包下，PipedOutputStream和PipedInputStream分别是管道输出流和管道输入流。\n它们的作用是让多线程可以通过管道进行线程间的通讯。在使用管道通信时，必须将PipedOutputStream和PipedInputStream配套使用。\n使用方法：先创建一个管道输入流和管道输出流，然后将输入流和输出流进行连接，用生产者线程往管道输出流中写入数据，消费者在管道输入流中读取数据，这样就可以实现了不同线程间的相互通讯。\n但是这种方式在生产者和生产者、消费者和消费者之间不能保证同步，也就是说在一个生产者和一个消费者的情况下是可以生产者和消费者之间交替运行的，多个生成者和多个消费者者之间则不行。\n这种方式只适用于两个线程之间通信，不适合多个线程之间通信。\nimport java.io.IOException; import java.io.PipedInputStream; import java.io.PipedOutputStream; import java.util.*; public class Test4 { // 控制生产和消费个100次 private static int countP = 0; private static int countS = 0; // 创建管道输入流和管道输出流 final static PipedInputStream pis = new PipedInputStream(); final static PipedOutputStream pos = new PipedOutputStream(); // 将输入流和输出流进行连接 static { try { pis.connect(pos); } catch (IOException e) { e.printStackTrace(); } } public static void main(String[] args) { Thread producer = new Thread(new Producer()); Thread consumer = new Thread(new Consumer()); producer.start(); consumer.start(); } public static class Producer implements Runnable { @Override public void run() { try { while (true) { // 写入数据 countP++; pos.write(countP); pos.flush(); System.out.println(\u0026#34;Producer produce \u0026#34; + countP); Thread.sleep(new Random().nextInt(1000)); if (countP == 100) { break; } } } catch (Exception e) { e.printStackTrace(); } finally { try { // 关闭输出流 pos.close(); } catch (IOException e) { e.printStackTrace(); } } } } public static class Consumer implements Runnable { @Override public void run() { try { while (true) { // 读取数据 countS++; int value = pis.read(); System.out.println(\u0026#34;Consumer consume \u0026#34; + value); if (countS == 100) { break; } } } catch (IOException e) { e.printStackTrace(); } finally { try { // 关闭输入流 pis.close(); } catch (IOException e) { e.printStackTrace(); } } } } } ","permalink":"https://lesan.fun/posts/knowledge/producer-consumer-problem/","summary":"\u003cp\u003e生产者消费者问题（Producer-consumer problem），也称有限缓冲问题（Bounded-buffer problem），是一个多线程同步问题的经典案例。生产者生成一定量的数据放到缓冲区中，然后重复此过程；与此同时，消费者也在缓冲区消耗这些数据。生产者和消费者之间必须保持同步，要保证生产者不会在缓冲区满时放入数据，消费者也不会在缓冲区空时消耗数据。不够完善的解决方法容易出现死锁的情况，此时进程都在等待唤醒。\u003c/p\u003e","title":"生产者与消费者问题"},{"content":"在进行华为机试时遇到了报数游戏的编程题（约瑟夫环），但是看了很多网上的解题都非常长，于是经过不断的学习参考，有了下面这个解题方法，也不知道是不是最好的😭\n题目：\n100个人围成一圈，每个人有一个编码，编号从1开始到100.他们从1开始依次报数，报到为M的人自动退出圈圈，然后下一个人接着从1开始报数，直到剩余的人数小于M。请问最后剩余的人在原先的编号为多少？\n例如：输入M=3时，输出为：“58，91”；输入M=4时，输出为： “34，45， 97”\n解答：\nimport java.util.*; public class test { public static void main(String[] args) { Scanner in = new Scanner(System.in); int n = in.nextInt(); List list = new ArrayList\u0026lt;Integer\u0026gt;(100); for (int i = 1; i \u0026lt;= 100; i++) { list.add(i); } int i = 0; while (list.size() \u0026gt;= n) { i = (i + n - 1) % list.size(); list.remove(i); } list.stream().forEach(System.out::println); } } ","permalink":"https://lesan.fun/posts/algorithm/huawei-counting-game/","summary":"\u003cp\u003e在进行华为机试时遇到了报数游戏的编程题（约瑟夫环），但是看了很多网上的解题都非常长，于是经过不断的学习参考，有了下面这个解题方法，也不知道是不是最好的😭\u003c/p\u003e","title":"华为机试题：报数游戏"},{"content":"在 web 软件开发中，API接口管理非常重要，也是前后端对接的关键，这里分享一个非常好用且可以私有化部署的接口管理系统Yapi，对那些内网开发的小伙伴们是一个不错的选择。\nYapi简介 Yapi 由 YMFE 开源，旨在为开发、产品、测试人员提供更优雅的接口管理服务，可以帮助开发者轻松创建、发布、维护 API\n权限管理 YApi 成熟的团队管理扁平化项目权限配置满足各类企业的需求\n可视化接口管理 基于 websocket 的多人协作接口编辑功能和类 postman 测试工具，让多人协作成倍提升开发效率\nMock Server 易用的 Mock Server，再也不用担心 mock 数据的生成了\n自动化测试 完善的接口自动化测试,保证数据的正确性\n数据导入 支持导入 swagger, postman, har 数据格式，方便迁移旧项目\n插件机制 强大的插件机制，满足各类业务需求\nYapi使用Docker安装 由于内网开发环境，导致安装各种环境或者系统非常不方便，所以个人比较推荐通过docker来安装\n拉取镜像 docker pull registry.cn-hangzhou.aliyuncs.com/anoy/yapi\n创建挂载目录 mkdir -p /data/yapi/mongodata\n运行专用mongo（也可以放在已有的mongo） docker run -d --name yapimongo --restart always -v /data/yapi/mongodata:/data/db mongo\n初始化 Yapi 数据库索引及管理员账号 docker run -it --rm --link yapimongo:mongo --entrypoint npm --workdir /api/vendors registry.cn-hangzhou.aliyuncs.com/anoy/yapi run install-server\n--rm：在 Docker 容器退出时，默认容器内部的文件系统仍然被保留，以方便调试并保留用户数据。但是，对于 foreground 容器，由于其只是在开发调试过程中短期运行，其用户数据并无保留的必要，因而可以在容器启动时设置 \u0026ndash;rm 选项，这样在容器退出时就能够自动清理容器内部的文件系统\n--entrypoint：类似于 CMD 指令，但其不会被 docker run 的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序。但是, 如果运行 docker run 时使用了 \u0026ndash;entrypoint 选项，将覆盖 ENTRYPOINT 指令指定的程序\n--workdir：指定工作目录。用 WORKDIR 指定的工作目录，会在构建镜像的每一层中都存在\nrun：用于执行后面跟着的命令行命令\n创建Yapi容器并启动 docker run -d --name yapi --restart=always --link yapimongo:mongo --workdir /api/vendors -p 3001:3000 registry.cn-hangzhou.aliyuncs.com/anoy/yapi server/app.js\n--link：用于容器直接的互通\n使用Yapi 访问 http://localhost:3000 登录账号 admin@admin.com，密码 ymfe.org\nYapi配置 # 进入Yapi容器中 docker exec -it yapi /bin/bash # 修改配置文件 vi ../config.json # 修改内容如下 { \u0026#34;port\u0026#34;: \u0026#34;3000\u0026#34;, \u0026#34;adminAccount\u0026#34;: \u0026#34;admin@admin.com\u0026#34;, \u0026#34;closeRegister\u0026#34;:true, # 配置禁用注册，主要是添加这句配置 \u0026#34;db\u0026#34;: { # 配置MongoDB \u0026#34;servername\u0026#34;: \u0026#34;mongo\u0026#34;, \u0026#34;DATABASE\u0026#34;: \u0026#34;yapi\u0026#34;, \u0026#34;port\u0026#34;: 27017 } } # 退出 exit # 重启容器 docker restart yapi 本文参考：\ndocker安装yapi\n具体使用可参考官方教程\n","permalink":"https://lesan.fun/posts/share/yapi/","summary":"\u003cp\u003e在 web 软件开发中，API接口管理非常重要，也是前后端对接的关键，这里分享一个非常好用且可以私有化部署的接口管理系统Yapi，对那些内网开发的小伙伴们是一个不错的选择。\u003c/p\u003e","title":"分享可私有部署的接口管理系统Yapi"},{"content":"本篇文章记录本人搭建CI\u0026amp;CD实现持续集成和持续部署\n1.使用docker安装gitlab 下载镜像 （使用中文社区版） docker pull twang2218/gitlab-ce-zh\n创建所需目录为后续挂载文件 进入所需目录后，打开PowerShell，通过以下命令进行目录创建\nmkdir -p gitlab/etc 、 mkdir -p gitlab/etc 、 mkdir -p gitlab/etc\n目录结构如下图所示\n启动容器 镜像下载完成后可通过 docker images查看下载结果，再通过镜像启动为容器\ndocker run -d -p 9443:443 -p 9080:80 -p 9022:22 --restart always --name testgitlab -v D:\\testgitlab\\gitlab\\etc:/etc/gitlab -v D:\\testgitlab\\gitlab\\log:/var/log/gitlab -v D:\\testgitlab\\gitlab\\data:/var/opt/gitlab --privileged=true twang2218/gitlab-ce-zh # 执行完成后会返回一串字符串 其中：\n-d：后台执行\n-p：端口映射\n--restart：重启机制\n--name：容器名称\n-v：挂载文件，使得容器内文件在宿主机内有映射\n--privileged：使得容器获取宿主机root权限\n进入容器，修改配置 输入命令 docker exec -it testgitlab bash 即可进入刚刚创建好的容器\n1.修改 gitlab.rb配置的两种方式：1. 进入挂载好的etc目录下找到 gitlab.rb文件进行修改；2. 通过进入容器内进行命令行 vi /etc/gitlab/gitlab.rb 修改\n# 整个gitlab.rb都是注释了的，我们可以按需加入我们的配置\r# 1. gitlab访问地址，可以写域名。如果端口不写的话默认为80端口\reaxternal_url \u0026#39;http://192.168.3.12:9080\u0026#39;\r# 2. ssh主机ip\rgitlab_rails[\u0026#39;gitlab_ssh_host\u0026#39;] = \u0026#39;192.168.3.12\u0026#39;\r# 3. ssh连接端口\rgitlab_rails[\u0026#39;gitlab_shell_ssh_port\u0026#39;] = 9022\r# 4. 防止内存占用过大，限制线程数\runicorn[\u0026#39;worker_processes\u0026#39;] = 2 2.修改 gitlab.yml配置（这一步原本不是必须的，因为 gitlab.rb内配置会覆盖这个，为了防止没有成功覆盖所以我在这里进行配置，当然你也可以选择不修改 gitlab.rb直接修改这里）\n通过命令行 vi /opt/gitlab/embedded/service/gitlab-rails/config/gitlab.yml修改，或者找到挂载文件修改\n修改上图红框配置\n3.让修改后的配置生效，并重启\ngitlab-ctl reconfigure 、 gitlab-ctl restart 、 exit（退出容器命令行）\n或者重启容器 docker restart testgitlab\n访问gitlab 输入http://192.168.3.12:9080打开页面（ip请输入前面设置的），默认账户root，密码需要重新设置至少8位\n2.使用docker安装jenkins 下载镜像 docker pull jenkins/jenkins\n创建所需目录为后续挂载文件 在服务器上先创建一个jenkins工作目录 /var/jenkins_mount，赋予相应权限，稍后我们将jenkins容器目录挂载到这个目录上，这样我们就可以很方便地对容器内的配置文件进行修改。如何后续在容器内修改的话会非常麻烦，由于容器中无vi命令。\nmkdir -p /var/jenkins_mount 、 chmod 777 /var/jenkins_mount\n启动容器 docker run -d -p 10240:8080 -p 10241:50000 -v D:\\testjenkins\\jenkins_mount:/var/jenkins_home -v /etc/localtime:/etc/localtime --name testjenkins jenkins/jenkins # 其中-v /etc/localtime:/etc/localtime让容器使用和服务器同样的时间设置 可以通过 docker ps来查看启动情况\n可以通过 docker logs testjenkins来查看容器日志\n修改配置 进入刚刚挂载的文件，修改 hudson.model.UpdateCenter.xml文件\n将 url 修改为 清华大学官方镜像：https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json ，配置镜像加速\n还需要修改 default.json文件，位置为 cd /var/jenkins_home/updates\n使用sed命令修改 default.json\nlinux下：\nsed -i \u0026#39;s/http:\\/\\/updates.jenkins-ci.org\\/download/https:\\/\\/mirrors.tuna.tsinghua.edu.cn\\/jenkins/g\u0026#39; default.json \u0026amp;\u0026amp; sed -i \u0026#39;s/http:\\/\\/www.google.com/https:\\/\\/www.baidu.com/g\u0026#39; default.json mac下：\nsed -i \u0026#34;\u0026#34; \u0026#39;s/http:\\/\\/updates.jenkins-ci.org\\/download/https:\\/\\/mirrors.tuna.tsinghua.edu.cn\\/jenkins/g\u0026#39; default.json \u0026amp;\u0026amp; sed -i \u0026#34;\u0026#34; \u0026#39;s/http:\\/\\/www.google.com/https:\\/\\/www.baidu.com/g\u0026#39; default.json 重启容器 docker restart testjenkins\n访问jenkins 输入http://localhost:10240打开页面\n选择默认插件安装即可\n3.gitlab + jenkins 为了实现自动持续构建, 不需要人工操作 ( 留人工操作用于处理特殊情况 )，通过gitlab+jenkins实现CI\u0026amp;CD，具体流程如下\n开发提交代码 开发对需要发布的版本打上 Tag 触发 GitLab 的 tag push 事件, 调用 Webhook Webhook 触发 Jenkins 的构建任务 Jenkins 构建完项目可以按版本号上传到仓库、部署、通知相关人员等等 配置gitlab 建一个测试项目 test ，随便 commit 一些内容，比如通过网页添加 README.md 创建账号的 access token ，用于 Jenkins 调用 GitLab 的 API 记下生成的 access token , 后面需要用到！！！且它只会展示一次，请记录好！！！ 配置jenkins 安装环境所需插件 Git Parameter ( 用于参数化构建中动态获取项目分支 ) Generic Webhook Trigger ( 用于解析 Webhook 传过来的参数 ) GitLab ( 用于推送构建结果给 GitLab ) 添加 GitLab 凭据 在系统配置中配置gitlab 创建新的FreeStyle任务 General 勾选 参数化构建过程, 添加 Git Parameter 类型的参数 ref , 这样构建的时候就可以指定分支进行构建\n源码管理 选择 Git , 添加项目地址和授权方式 ( 帐号密码 或者 ssh key ) , 分支填写构建参数 $ref\n构建触发器 选择 Generic Webhook Trigger 方式用于解析 GitLab 推过来的详细参数 ( jsonpath 在线测试 ) 。其他触发方式中: Trigger builds remotely 是 Jenkins 自带的, Build when a change is pushed to GitLab 是 GitLab 插件 提供的, 都属于简单的触发构建, 无法做复杂的处理\nOptional filter 虽然 Generic Webhook Trigger 提供了 Token 参数进行鉴权, 但为了避免不同项目进行混调 ( 比如 A 项目提交代码却触发了 B 项目的构建) , 还要对请求做下过滤。Optional filter 中 Text 填写需要校验的内容 ( 可使用变量 ) , Expression 使用正则表达式对 Text 进行匹配, 匹配成功才允许触发构建\n构建 构建内容按自己实际的项目类型进行调整, 使用 Maven 插件 或 脚本 等等\n构建后操作 构建后操作添加 Publish build status to GitLab 动作, 实现构建结束后通知构建结果给 GitLab\n在GitLab的项目页面中, 添加一个Webhook 添加一个 Webhook ( http://JENKINS_URL/generic-webhook-trigger/invoke?token=\u0026lt;上面 Jenkins 项目配置中的 token\u0026gt; ) , 触发器选择 标签推送事件。因为日常开发中 push 操作比较频繁而且不是每个版本都需要构建, 所以只针对需要构建的版本打上 Tag 就好了\nhttp://172.20.10.7:10240//generic-webhook-trigger/invoke?token=d63ad84eb18cb04d4459ec347a196dce\n创建完使用 test 按钮 先测试下, 可能会出现下面的错误\nRequests to the local network are not allowed 通过下面方法解决\n测试效果 将代码拉下来在本地操作通过IDEA进行操作\n然后使用快捷键 Cmd + Shift + K 调出 Push 窗口 , 把 Tag 推送到 GitLab 中\n回到 GitLab 页面可以看到触发了 Webhook , View details 查看请求详情, Response body 中 triggered 字段值为 true 则表示成功触发了 Jenkins 进行构建\n注意: 每添加一个 Tag 就会触发一次事件, 不管是不是一起 push 的。所以一次 push 多个 Tag 会触发 Jenkins 进行多次构建。不过 Jenkins 已经做了处理, 默认串行执行任务 ( 一个任务结束再执行下一个 ) , 而且在构建前有一个 pending 状态, 此时被多次触发会进行合并, 并取首次触发的参数, 如下图所示:\n关于 Tag 的几点说明 推送 Tag 到远端的时候, 远端已存在 ( 同名 ) 的 Tag 不会被添加到远端 拉取远端的 Tag 时, 本地已存在 ( 同名 ) 的 Tag 不会添加到本地 拉取远端的 Tag 时, 本地不会删除远端已删除的 Tag , 需要同步远端的 Tag 可以先删除本地所有 Tag 再 pull 删除 Tag 也会推送事件, 要做好过滤 ( 上面配置中已使用 commitsId 字段进行过滤 ) 本篇文章产考下列文章：\ndocker安装gitlab\ndocker安装jenkins\ndocker中jenkins插件加速\n整合gitlab+jenkins\n","permalink":"https://lesan.fun/posts/operation/ci-cd-gitlab-jenkins/","summary":"\u003cp\u003e本篇文章记录本人搭建CI\u0026amp;CD实现持续集成和持续部署\u003c/p\u003e\n\u003ch2 id=\"1使用docker安装gitlab\"\u003e1.使用docker安装gitlab\u003c/h2\u003e\n\u003ch3 id=\"下载镜像-使用中文社区版\"\u003e下载镜像 （使用中文社区版）\u003c/h3\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/posts/operation/ci-cd-gitlab-jenkins/images/1.png\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003edocker pull twang2218/gitlab-ce-zh\u003c/code\u003e\u003c/p\u003e\n\u003ch3 id=\"创建所需目录为后续挂载文件\"\u003e创建所需目录为后续挂载文件\u003c/h3\u003e\n\u003cp\u003e进入所需目录后，打开PowerShell，通过以下命令进行目录创建\u003c/p\u003e","title":"记一次搭建GitLab+Jenkins实现CI\u0026CD"},{"content":"默认.NET的Docker镜像是不包含libgdiplus的，所以本文介绍如何通过在原有镜像基础上构建一个满足个人需求的Docker镜像。\nDocker 简介 Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。\nDocker 的应用场景：\nWeb 应用的自动化打包和发布。 自动化测试和持续集成、发布。 在服务型环境中部署和调整数据库或其他的后台应用。 从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。 Docker 的优点：\nDocker 是一个用于开发，交付和运行应用程序的开放平台。Docker 使您能够将应用程序与基础架构分开，从而可以快速交付软件。借助 Docker，您可以与管理应用程序相同的方式来管理基础架构。通过利用 Docker 的方法来快速交付，测试和部署代码，您可以大大减少编写代码和在生产环境中运行代码之间的延迟。\n快速，一致地交付您的应用程序 响应式部署和扩展 在同一硬件上运行更多工作负载 Docker 命令 详细命令可以查看Docker 命令大全\n常用镜像命令 1. 查看服务器中 Docker 镜像列表 docker images 2. 搜索镜像 docker search 镜像名 3. 拉取镜像（不加tag(版本号)就默认拉取Docker仓库中该镜像的最新版本latest; 加:tag则是拉取指定版本） docker pull 镜像名 docker pull 镜像名:v1 4. 运行镜像 docker run -itd --name=\u0026#34;nginx\u0026#34; --restart=always -p 80:80 -v /data:/data nginx:latest 5. 删除镜像 docker rmi -f 镜像名/镜像ID 6. 保存镜像 docker save nginx -o /nginx.tar 7. 加载镜像 docker load -i 镜像文件位置 常用容器命令 1. 查看正在运行容器列表 docker ps 2. 查看所有容器 docker ps -a 3. 停止容器 docker stop 容器名/容器ID 4. 删除容器 docker rm -f 容器名/容器ID 5. 进入容器方式 docker exec -it 容器名/容器ID /bin/bash exit/ctl+p+q #退出 6. 重启容器 docker restart 容器名/容器ID 7. 启动容器 docker start 容器名/容器ID 8. kill 容器 docker kill 容器名/容器ID 9. 容器文件拷贝 docker cp 容器名/ID:容器内路径 容器外路径 #容器内拷出 docker cp 容器外路径 容器名/ID:容器内路径 #容器外拷入 10. 查看容器日志 docker logs -f --tail=100 容器 #tail查看末尾多少行 默认all 11. 修改存在容器的启动配置 docker update --restart=always 容器 12. 更换容器名 docker rename 容器 容器新名字 13. 通过容器提交镜像！！！### docker commit -a=\u0026#34;提交作者\u0026#34; -m=\u0026#34;提交信息\u0026#34; 容器 提交镜像:tag Docker 运维命令 1. 查看Docker工作目录 sudo docker info | grep \u0026#34;Docker Root Dir\u0026#34; 2. 查看Docker磁盘占用总体情况 du -hs /var/lib/docker/ 3. 查看Docker的磁盘使用具体情况 docker system df 4. 删除无用的容器和镜像 docker rm `docker ps -a | grep Exited | awk \u0026#39;{print $1}\u0026#39;` docker rmi -f `docker images | grep \u0026#39;\u0026lt;none\u0026gt;\u0026#39; | awk \u0026#39;{print $3}\u0026#39;` 5. 清除所有无容器使用的镜像 docker system prune -a 6. 查找大文件 find / -type f -size +100M -print0 | xargs -0 du -h | sort -nr 7. 查找指定Docker使用目录下大于指定大小文件 find / -type f -size +100M -print0 | xargs -0 du -h | sort -nr | grep \u0026#39;/var/lib/docker/overlap2/*\u0026#39; 构建一个带libgdiplus的DotNetCore基础镜像 通过Docker拉取一个.netcore3.1基础镜像：docker pull mcr.microsoft.com/dotnet/aspnet:3.1\n进入容器：docker run -it mcr.microsoft.com/dotnet/aspnet:3.1 /bin/bash 安装libgdiplus：\napt-get update -y apt-get install -y libgdiplus apt-get clean ln -s /usr/lib/libgdiplus.so /usr/lib/gdiplus.dll 提交为新镜像：\ndocker commit -a=\u0026quot;Lesan\u0026quot; -m=\u0026quot;added libgdiplus based on .netcore3.1\u0026quot; 28a66ebccd55 dotnetcore-with-libgdiplus:v3.1\n修改项目Dockerfile基础镜像为刚刚构建的自定义镜像 dotnetcore-with-libgdiplus:v3.1\n借鉴参考以下文章：\nhttps://blog.csdn.net/leilei1366615/article/details/106267225\nhttps://www.runoob.com/docker/docker-command-manual.html\nhttps://blog.csdn.net/u014374975/article/details/115436174\n","permalink":"https://lesan.fun/posts/operation/docker-images-libgdiplus-dotnet/","summary":"\u003cp\u003e默认.NET的Docker镜像是不包含libgdiplus的，所以本文介绍如何通过在原有镜像基础上构建一个满足个人需求的Docker镜像。\u003c/p\u003e\n\u003ch2 id=\"docker-简介\"\u003eDocker 简介\u003c/h2\u003e\n\u003cp\u003eDocker 是一个开源的应用容器引擎，基于 \u003cstrong\u003eGo 语言\u003c/strong\u003e 并遵从 Apache2.0 协议开源。Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。\u003c/p\u003e","title":"构建一个带libgdiplus的.NET基础Docker镜像"},{"content":"消息推送是大部分系统都需要做到的功能，在.NET中我分别通过RabbitMQ、MQTT、SignalR实现消息推送功能，本篇文章将通过它们实现简单的推送功能，手把手带大家完成编程。本文环境为 .NET Core 3.1下\nSignalR实现 简介 SignalR是一个开源的库，跨平台；让Web应用与其他应用通讯变得很简单，Web服务端可以实时的将内容推送给对应的客户端，客户端发送的信息也可以实时到其他客户端。\nSignalR提供了一种远程过程调用(RPC)的方式，使得客户端可以调用服务器的方法，同样在服务器端的方法中也能调用客户端的方法。\n示例 Nuget包为： \u0026lt;PackageReference Include=\u0026quot;Microsoft.AspNetCore.SignalR.Core\u0026quot; Version=\u0026quot;1.1.0\u0026quot; /\u0026gt;\n首先我们需要创建一个自己的SignalR Hub using Microsoft.AspNetCore.SignalR; using System.Threading.Tasks; namespace KBEAM.Hubs { public class ChatHub : Hub // 继承自SignalR Hub库 { public async Task SendMessage(string user, string message) { await Clients.All.SendAsync(\u0026#34;ReceiveMessage\u0026#34;, user, message); } public async Task SendMessageToGroup(string group, string message) { await Clients.Group(group).SendAsync(\u0026#34;ReceiveMessageFromGroup\u0026#34;, group, message); } public async Task AddToGroup(string groupName) { await Groups.AddToGroupAsync(Context.ConnectionId, groupName); await Clients.Group(groupName).SendAsync(\u0026#34;ReceiveMessage\u0026#34;, $\u0026#34;{Context.ConnectionId} has joined the group {groupName}.\u0026#34;); } public async Task RemoveFromGroup(string groupName) { await Groups.RemoveFromGroupAsync(Context.ConnectionId, groupName); //await Clients.Group(groupName).SendAsync(\u0026#34;ReceiveMessage\u0026#34;, $\u0026#34;{Context.ConnectionId} has left the group {groupName}.\u0026#34;); } } } 在Startup.cs文件中注册相关服务及管道 // 1.在ConfigureServices函数中添加以下语句，注册相关服务 services.AddSignalR(); // 2.在Configure函数中添加以下语句，配置管道终结点 app.UseEndpoints(endpoints =\u0026gt; { // ... endpoints.MapHub\u0026lt;ChatHub\u0026gt;(\u0026#34;/chatHub\u0026#34;); // ... }); 编写服务端业务，推送消息 // 定义一个上下文 private readonly IHubContext\u0026lt;ChatHub\u0026gt; hubContext; // 通过构造函数注入依赖 public MonitorService(IHubContext\u0026lt;ChatHub\u0026gt; hub) { hubContext = hub; } //在需要的地方调用方法，进行消息推送 await hubContext.Clients.Group(group).SendAsync(\u0026#34;ReceiveMessageFromGroup\u0026#34;,group, \u0026#34;需要发送的消息\u0026#34;); JS客户端程序编写 首先，需要通过npm来安装SignalR封装好的JS文件，npm install @microsoft/signalr\n// 1.首先进行SignalR客户端连接 const signalR = require(\u0026#34;@microsoft/signalr\u0026#34;) let conn = new signalR.HubConnectionBuilder() .withUrl(\u0026#34;http://localhost:8988/chatHub\u0026#34;) .withAutomaticReconnect() .configureLogging(signalR.LogLevel.Error) .build() export default conn import signalR from \u0026#34;@/utils/signalR\u0026#34;; // 2.客户端调用服务端方法（RPC） signalR.invoke(\u0026#34;AddToGroup\u0026#34;, \u0026#34;groupName\u0026#34;).catch(function (err) { // 加入用户组 return console.error(err.toString()); }); signalR.invoke(\u0026#34;RemoveFromGroup\u0026#34;, \u0026#34;大屏\u0026#34;).catch(function (err) { // 移除用户组 return console.error(err.toString()); }); // 3.客户端监听服务器消息 signalR.on(\u0026#34;ReceiveMessageFromGroup\u0026#34;, function (group, message) { console.log(group + \u0026#34; \u0026#34; + message); that.lineChartData = JSON.parse(message); }); RabbitMQ实现 简介 RabbitMQ是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件），由以高性能、健壮以及可伸缩性出名的 Erlang 写成。\n示例 首先您需要在电脑上安装好 Erlang及RabbitMQ服务器，这一步大家就自行搜索解决吧，网上应该有很多的解决方法\nRabbitMQ准备 首先开启Stomp插件\nrabbitmq-plugins enable rabbitmq_management # 开启此插件后有管理界面http://localhost:15672/ rabbitmq-plugins enable rabbitmq_web_stomp rabbitmq-plugins enable rabbitmq_web_stomp_examples 服务端发送消息 所需Nuget包： \u0026lt;PackageReference Include=\u0026quot;RabbitMQ.Client\u0026quot; Version=\u0026quot;6.2.4\u0026quot; /\u0026gt;\n// 建立RabbitMQ连接 private static readonly ConnectionFactory rabbitMqFactory = new ConnectionFactory() { HostName = \u0026#34;localhost\u0026#34;, UserName = \u0026#34;用户名\u0026#34;, Password = \u0026#34;密码\u0026#34;, Port = 5672, VirtualHost = \u0026#34;虚拟主机配置\u0026#34; }; // 发送消息 using (IConnection conn = rabbitMqFactory.CreateConnection()) { using (IModel channel = conn.CreateModel()) { channel.ExchangeDeclare(\u0026#34;monitor\u0026#34;, ExchangeType.Direct, durable: true, autoDelete: false, arguments: null); channel.QueueDeclare(\u0026#34;message\u0026#34;, durable: true, autoDelete: false, exclusive: false, arguments: null); channel.QueueBind(\u0026#34;message\u0026#34;, \u0026#34;monitor\u0026#34;, routingKey: \u0026#34;message\u0026#34;); var props = channel.CreateBasicProperties(); props.Persistent = true; channel.BasicPublish(exchange: \u0026#34;monitor\u0026#34;, routingKey: \u0026#34;message\u0026#34;, basicProperties: props, body: Encoding.UTF8.GetBytes(JsonConvert.SerializeObject(new { expectedData, actualData }))); } } 具体RabbitMQ使用可以看我的RabbitMQ学习笔记\n客户端接受消息 首先需要安装npm库文件，npm install stompjs\nimport Stomp from \u0026#34;stompjs\u0026#34;; // 定义一个RabbitMQ客户端 data() { return { client: Stomp.client(\u0026#34;ws://localhost:15674/ws\u0026#34;), }; }, // 初始化连接操作 created() { this.client.connect( \u0026#34;用户名\u0026#34;, \u0026#34;密码\u0026#34;, this.onConnected, this.onFailed, \u0026#34;虚拟主机名称\u0026#34; ); } methods: { onConnected: function () { //订阅频道 // const topic = localStorage.getItem(\u0026#34;Lesan\u0026#34;); console.log(\u0026#34;连接成功\u0026#34;); this.client.subscribe( \u0026#34;/exchange/monitor/message\u0026#34;, this.responseCallback, this.onFailed ); }, onFailed: function (frame) { console.log(\u0026#34;MQ Failed: \u0026#34; + frame); this.$message.error(\u0026#34;连接失败\u0026#34;); }, // 回传消息 responseCallback: function (frame) { console.log(\u0026#34;MQ msg=\u0026gt;\u0026#34; + frame.body); this.lineChartData = JSON.parse(frame.body); //接收消息处理 }, // 断开相应的连接 close: function () { this.client.disconnect(function () { console.log(\u0026#34;已退出账号\u0026#34;); }); }, }, MQTT实现 简介 MQTT是IBM开发的一个即时通讯协议，该协议支持所有的平台，几乎可以把所有联网的物品和外部连接起来。\n使用发布/订阅消息模式，提供一对多的消息发布，解除应用程序耦合。这一点很类似于XMPP，但是MQTT的信息冗余远小于XMPP。 使用TCP/IP提供网络连接。主流的MQTT是基于TCP连接进行数据推送的，但是同样有基于UDP的版本，叫做MQTT-SN。这两种版本由于基于不同的连接方式，优缺点自然也就各有不同了。 三种消息传输方式QoS： 0代表“至多一次”，消息发布完全依赖底层 TCP/IP 协议。会发生消息丢失或重复。这一级别可用于如下情况，环境传感器数据，丢失一次读记录无所谓，因为不久后还会有第二次发送 1代表“至少一次”，确保消息到达，但消息重复可能会发生 2代表“只有一次”，确保消息到达一次。这一级别可用于如下情况，在计费系统中，消息重复或丢失会导致不正确的结果 示例 服务端开发 所需Nuget包：\u0026lt;PackageReference Include=\u0026quot;MQTTnet.AspNetCore\u0026quot; Version=\u0026quot;3.1.2\u0026quot; /\u0026gt;\n对Program.cs修改：\npublic static IHostBuilder CreateHostBuilder(string[] args) =\u0026gt; Host.CreateDefaultBuilder(args) .ConfigureWebHostDefaults(webBuilder =\u0026gt; { webBuilder.UseKestrel(o =\u0026gt; { o.ListenAnyIP(8988); o.ListenAnyIP(1884, t =\u0026gt; t.UseMqtt()); }); webBuilder.UseStartup\u0026lt;Startup\u0026gt;(); //webBuilder.UseUrls(\u0026#34;http://0.0.0.0:8988\u0026#34;); }); 对Startup.cs修改：\n// 在ConfigureServices函数中添加 services.AddHostedMqttServer(mqttServer =\u0026gt; mqttServer.WithoutDefaultEndpoint().WithConnectionValidator(c =\u0026gt; { if (c.Username != \u0026#34;admin\u0026#34; || c.Password != \u0026#34;123456\u0026#34;) { c.ReasonCode = MqttConnectReasonCode.BadUserNameOrPassword; return; } c.ReasonCode = MqttConnectReasonCode.Success; })) .AddMqttConnectionHandler() .AddConnections(); // 在Configure函数中添加 app.UseEndpoints(endpoints =\u0026gt; { endpoints.MapConnectionHandler\u0026lt;MqttConnectionHandler\u0026gt;( \u0026#34;/mqtt\u0026#34;, httpConnectionDispatcherOptions =\u0026gt; httpConnectionDispatcherOptions.WebSockets.SubProtocolSelector = protocolList =\u0026gt; protocolList.FirstOrDefault() ?? string.Empty); }); app.UseMqttServer(S =\u0026gt; { MqttHelper.Server = S; S.ClientConnectedHandler = new MqttServerClientConnectedHandlerDelegate(OnConnected); S.StartedHandler = new MqttServerStartedHandlerDelegate(OnStarted); }); // 添加事件处理函数 private void OnStarted(EventArgs obj) { RecurringJob.AddOrUpdate\u0026lt;MonitorService\u0026gt;(\u0026#34;MonitorData\u0026#34;, p =\u0026gt; p.UpdateDataAsync(\u0026#34;大屏\u0026#34;), \u0026#34;0/15 * * * * *\u0026#34;); } private void OnConnected(MqttServerClientConnectedEventArgs args) { Console.WriteLine(args.ClientId); } // 消息推送方法 MqttHelper.PublishAsync(\u0026#34;monitor\u0026#34;, JsonConvert.SerializeObject(new { expectedData, actualData })); 添加MqttHelper类：\nusing MQTTnet.Server; using System.Text; namespace Common { public class MqttHelper { public static IMqttServer Server { get; set; } public static void PublishAsync(string topic, byte[] payload) { if (Server != null) { Server.PublishAsync(new MQTTnet.MqttApplicationMessage() { Topic = topic, Payload = payload }, new System.Threading.CancellationToken(false)); } } public static void PublishAsync(string topic, string payload) { if (Server != null) { Server.PublishAsync(new MQTTnet.MqttApplicationMessage() { Topic = topic, Payload = Encoding.UTF8.GetBytes(payload) }, new System.Threading.CancellationToken(false)); ; } } } } 客服端开发 首先需要引入npm包：npm install mqtt\nimport mqtt from \u0026#34;mqtt\u0026#34;; // 连接Mqtt服务器，并订阅消息 mounted() { let that = this; let mqttClient = mqtt.connect(\u0026#34;ws://localhost:8988/mqtt\u0026#34;, { username: \u0026#34;用户名\u0026#34;, password: \u0026#34;密码\u0026#34;, clientId: \u0026#34;客户端ID\u0026#34;, }); mqttClient.on(\u0026#34;connect\u0026#34;, (e) =\u0026gt; { console.log(\u0026#34;connected\u0026#34;, e); mqttClient.subscribe(\u0026#34;monitor\u0026#34;, { qos: 1 }, (err) =\u0026gt; { if (!err) { console.log(\u0026#34;subscribed\u0026#34;); } }); }); mqttClient.on(\u0026#34;message\u0026#34;, (topic, message) =\u0026gt; { console.log(topic, message.toString()); that.lineChartData = JSON.parse(message.toString()); }); }, 其他 Vue前端测试客户端全部代码，通过Vue-cli搭建的项目，修改App.vue即可\n\u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;img alt=\u0026#34;Vue logo\u0026#34; src=\u0026#34;./assets/logo.png\u0026#34; /\u0026gt; \u0026lt;HelloWorld msg=\u0026#34;Welcome to Your Vue.js App\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import HelloWorld from \u0026#34;./components/HelloWorld.vue\u0026#34;; import mqtt from \u0026#34;mqtt\u0026#34;; import Stomp from \u0026#34;stompjs\u0026#34;; export default { name: \u0026#34;App\u0026#34;, components: { HelloWorld, }, data() { return { rabbitClient: Stomp.client(\u0026#34;ws://172.21.30.233:15674/ws\u0026#34;), }; }, created() {}, mounted() { // this.useMqtt(); // this.useRabbitMQ(); this.useSignalR(); }, methods: { useSignalR() { const signalR = require(\u0026#34;@microsoft/signalr\u0026#34;); const conn = new signalR.HubConnectionBuilder() .withUrl(\u0026#34;http://172.21.30.233:8988/chatHub\u0026#34;) .withAutomaticReconnect() .configureLogging(signalR.LogLevel.Error) .build(); conn .start() .then(() =\u0026gt; { console.log(\u0026#34;conneted\u0026#34;); conn.invoke(\u0026#34;AddToGroup\u0026#34;, \u0026#34;大屏\u0026#34;).catch(function (err) { return console.error(err.toString()); }); conn.on(\u0026#34;ReceiveMessageFromGroup\u0026#34;, function (group, message) { console.log(group + \u0026#34; \u0026#34; + message); }); }) .catch((err) =\u0026gt; { return console.error(err.toString()); }); }, useMqtt() { let mqttClient = mqtt.connect(\u0026#34;ws://172.21.30.233:8988/mqtt\u0026#34;, { username: \u0026#34;admin\u0026#34;, password: \u0026#34;123456\u0026#34;, // clientId: \u0026#34;Lesan\u0026#34;, }); mqttClient.on(\u0026#34;connect\u0026#34;, (e) =\u0026gt; { console.log(\u0026#34;connected\u0026#34;, e); mqttClient.subscribe(\u0026#34;monitor\u0026#34;, { qos: 1 }, (err) =\u0026gt; { if (!err) { console.log(\u0026#34;subscribed\u0026#34;); } }); }); mqttClient.on(\u0026#34;message\u0026#34;, (topic, message) =\u0026gt; { console.log(topic, message.toString()); }); }, useRabbitMQ() { // this.rabbitClient.heartbeat.outgoing = 0; // this.rabbitClient.heartbeat.incoming = 0; this.rabbitClient.connect( \u0026#34;KB\u0026#34;, \u0026#34;KB\u0026#34;, this.onConnected, this.onFailed, \u0026#34;kb_monitor\u0026#34; ); }, onConnected: function () { //订阅频道 // const topic = localStorage.getItem(\u0026#34;Lesan\u0026#34;); console.log(\u0026#34;连接成功\u0026#34;); this.rabbitClient.subscribe( \u0026#34;/exchange/monitor/message\u0026#34;, this.responseCallback, this.onFailed ); }, onFailed: function (frame) { console.log(\u0026#34;MQ Failed: \u0026#34; + frame); this.$message.error(\u0026#34;连接失败\u0026#34;); }, // 回传消息 responseCallback: function (frame) { console.log(\u0026#34;MQ msg=\u0026gt;\u0026#34; + frame.body); //接收消息处理 }, // 断开相应的连接 close: function () { this.rabbitClient.disconnect(function () { console.log(\u0026#34;已退出账号\u0026#34;); }); }, }, }; \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; #app { font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px; } \u0026lt;/style\u0026gt; ","permalink":"https://lesan.fun/posts/knowledge/message-push/","summary":"\u003cp\u003e消息推送是大部分系统都需要做到的功能，在.NET中我分别通过RabbitMQ、MQTT、SignalR实现消息推送功能，本篇文章将通过它们实现简单的推送功能，手把手带大家完成编程。本文环境为 \u003ccode\u003e.NET Core 3.1\u003c/code\u003e下\u003c/p\u003e","title":"实现简单消息推送功能"},{"content":"本篇文章是学习leetcode中链表相关算法总结的链表技巧。\n虚拟头节点 力扣第 21 题「合并两个有序链表」 ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) { ListNode *head = new ListNode(-1), *p = head; while (l1 \u0026amp;\u0026amp; l2) { if (l1-\u0026gt;val \u0026lt; l2-\u0026gt;val) { p-\u0026gt;next = l1; l1 = l1-\u0026gt;next; } else { p-\u0026gt;next = l2; l2 = l2-\u0026gt;next; } p = p-\u0026gt;next; } p-\u0026gt;next = l1 ? l1 : l2; return head-\u0026gt;next; } 这个算法的逻辑类似于「拉拉链」，l1, l2 类似于拉链两侧的锯齿，指针 p 就好像拉链的拉索，将两个有序链表合并\nListNode *head = new ListNode(-1), *p = head;中使用到了虚拟头节点，如果不使用虚拟节点，代码会复杂很多，而有了 head 节点这个占位符，可以避免处理空指针的情况，降低代码的复杂性\n优先队列 力扣第 23 题「合并K个升序链表」 struct cmp { bool operator()(ListNode *p1, ListNode *p2) { return p1-\u0026gt;val \u0026gt; p2-\u0026gt;val; } }; ListNode *mergeKLists(vector\u0026lt;ListNode *\u0026gt; \u0026amp;lists) { if (lists.size() == 0) return nullptr; ListNode *head = new ListNode(-1), *tail = head; priority_queue\u0026lt;ListNode *, vector\u0026lt;ListNode *\u0026gt;, cmp\u0026gt; pq; for (auto i : lists) { if (i) pq.push(i); } while (!pq.empty()) { ListNode *node = pq.top(); pq.pop(); tail-\u0026gt;next = node; tail = tail-\u0026gt;next; if (node-\u0026gt;next) pq.push(node-\u0026gt;next); } return head-\u0026gt;next; } 这里我们就要用到 优先级队列 这种数据结构，把链表节点放入一个最小堆，就可以每次获得 k 个节点中的最小节点\n它的时间复杂度是多少呢？\n优先队列 pq 中的元素个数最多是 k，所以一次 poll 或者 add 方法的时间复杂度是 O(logk)；所有的链表节点都会被加入和弹出 pq，所以算法整体的时间复杂度是 O(Nlogk)，其中 k 是链表的条数，N 是这些链表的节点总数。\n单链表的倒数第k个节点 力扣第 19 题「删除链表的倒数第 N 个结点」 ListNode *removeNthFromEnd(ListNode *head, int n) { ListNode *dummy = new ListNode(-1); dummy-\u0026gt;next = head; auto temp = FindFromEnd(dummy, n + 1); temp-\u0026gt;next = temp-\u0026gt;next-\u0026gt;next; return dummy-\u0026gt;next; } ListNode *FindFromEnd(ListNode *head, int n) { ListNode *first = head, *second = head; while (n--) { first = first-\u0026gt;next; } while (first) { first = first-\u0026gt;next; second = second-\u0026gt;next; } return second; } 首先，我们先让一个指针 p1 指向链表的头节点 head，然后走 k 步 现在的 p1，只要再走 n - k 步，就能走到链表末尾的空指针了对吧？趁这个时候，再用一个指针 p2 指向链表头节点 head 接下来就很显然了，让 p1 和 p2 同时向前走，p1 走到链表末尾的空指针时走了 n - k 步，p2 也走了 n - k 步，也就是链表的倒数第 k 个节点 这样，只遍历了一次链表，就获得了倒数第 k 个节点 p2 不过注意我们又使用了虚拟头结点的技巧，也是为了防止出现空指针的情况，比如说链表总共有 5 个节点，题目就让你删除倒数第 5 个节点，也就是第一个节点，那按照算法逻辑，应该首先找到倒数第 6 个节点。但第一个节点前面已经没有节点了，这就会出错。\n但有了我们虚拟节点 dummy 的存在，就避免了这个问题，能够对这种情况进行正确的删除。\n双指针 力扣第 876 题「链表的中间结点」 如果想一次遍历就得到中间节点，也需要耍点小聪明，使用「快慢指针」的技巧：\n我们让两个指针 slow 和 fast 分别指向链表头结点 head。\n每当慢指针 slow 前进一步，快指针 fast 就前进两步，这样，当 fast 走到链表末尾时，slow 就指向了链表中点。\nListNode *middleNode(ListNode *head) { ListNode *slow = head, *fast = head; while (fast \u0026amp;\u0026amp; fast-\u0026gt;next) { slow = slow-\u0026gt;next; fast = fast-\u0026gt;next-\u0026gt;next; } return slow; } 力扣第 141 题「环形链表」 判断链表是否包含环属于经典问题了，解决方案也是用快慢指针：\n每当慢指针 slow 前进一步，快指针 fast 就前进两步。\n如果 fast 最终遇到空指针，说明链表中没有环；如果 fast 最终和 slow 相遇，那肯定是 fast 超过了 slow 一圈，说明链表中含有环。\nbool hasCycle(ListNode *head) { ListNode *slow = head, *fast = head; while (fast \u0026amp;\u0026amp; fast-\u0026gt;next) { slow = slow-\u0026gt;next; fast = fast-\u0026gt;next-\u0026gt;next; if (slow == fast) return true; } return false; } 当然，这个问题还有进阶版：如果链表中含有环，如何计算这个环的起点？\n这里简单提一下解法：\nListNode detectCycle(ListNode head) { ListNode fast, slow; fast = slow = head; while (fast != null \u0026amp;\u0026amp; fast.next != null) { fast = fast.next.next; slow = slow.next; if (fast == slow) break; } // 上面的代码类似 hasCycle 函数 if (fast == null || fast.next == null) { // fast 遇到空指针说明没有环 return null; } // 重新指向头结点 slow = head; // 快慢指针同步前进，相交点就是环起点 while (slow != fast) { fast = fast.next; slow = slow.next; } return slow; } 力扣第 160 题「相交链表」 ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { ListNode *A = headA, *B = headB; while (A != B) { if (A) A = A-\u0026gt;next; else A = headB; if (B) B = B-\u0026gt;next; else B = headA; } return A; } 如果用两个指针 p1 和 p2 分别在两条链表上前进，并不能同时走到公共节点，也就无法得到相交节点 c1。\n解决这个问题的关键是，通过某些方式，让 p1 和 p2 能够同时到达相交节点 c1。\n所以，我们可以让 p1 遍历完链表 A 之后开始遍历链表 B，让 p2 遍历完链表 B 之后开始遍历链表 A，这样相当于「逻辑上」两条链表接在了一起。\n如果这样进行拼接，就可以让 p1 和 p2 同时进入公共部分，也就是同时到达相交节点 c1：\n那你可能会问，如果说两个链表没有相交点，是否能够正确的返回 null 呢？\n这个逻辑可以覆盖这种情况的，相当于 c1 节点是 null 空指针嘛，可以正确返回 null。\n这样，这道题就解决了，空间复杂度为 O(1)，时间复杂度为 O(N)。\n","permalink":"https://lesan.fun/posts/algorithm/link-list/","summary":"\u003cp\u003e本篇文章是学习leetcode中链表相关算法总结的链表技巧。\u003c/p\u003e\n\u003ch2 id=\"虚拟头节点\"\u003e虚拟头节点\u003c/h2\u003e\n\u003ch3 id=\"力扣第-21-题合并两个有序链表\"\u003e力扣第 21 题「合并两个有序链表」\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eListNode\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"nf\"\u003emergeTwoLists\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eListNode\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003el1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eListNode\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003el2\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eListNode\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003ehead\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"n\"\u003eListNode\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003ep\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ehead\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ewhile\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003el1\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan class=\"n\"\u003el2\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003el1\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eval\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003el2\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eval\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003enext\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003el1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003el1\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003el1\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003enext\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003eelse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003enext\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003el2\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003el2\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003el2\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003enext\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003ep\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003enext\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003enext\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003el1\u003c/span\u003e \u003cspan class=\"o\"\u003e?\u003c/span\u003e \u003cspan class=\"nl\"\u003el1\u003c/span\u003e \u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"n\"\u003el2\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003ehead\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003enext\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e这个算法的逻辑类似于「拉拉链」，\u003ccode\u003el1, l2\u003c/code\u003e 类似于拉链两侧的锯齿，指针 \u003ccode\u003ep\u003c/code\u003e 就好像拉链的拉索，将两个有序链表合并\u003c/p\u003e","title":"算法学习-链表"},{"content":"😀😁😂🤣😃😄😅😆\n","permalink":"https://lesan.fun/about/","summary":"about","title":"👨‍💻 关于我"}]