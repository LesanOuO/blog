[{"content":"本文涵盖一些软件安装教程的文章，用于备忘~\nzookeeper https://blog.csdn.net/baomw/article/details/103835540\nkafka https://blog.csdn.net/weixin_42109071/article/details/107564094\nredis https://blog.csdn.net/m0_52985087/article/details/134466218\nhttps://cloud.tencent.com/developer/article/2184759\nmysql https://blog.csdn.net/m0_52985087/article/details/134444801\ndocker https://blog.csdn.net/chexlong/article/details/127932711\nelasticsearch https://blog.csdn.net/Acloasia/article/details/130683934\nprometheus https://blog.csdn.net/qq_31725371/article/details/114697770\n","permalink":"https://lesanouo.github.io/blog/posts/snippet/program_install/","summary":"\u003cp\u003e本文涵盖一些软件安装教程的文章，用于备忘~\u003c/p\u003e\n\u003ch2 id=\"zookeeper\"\u003ezookeeper\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ca href=\"https://blog.csdn.net/baomw/article/details/103835540\"\u003ehttps://blog.csdn.net/baomw/article/details/103835540\u003c/a\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"kafka\"\u003ekafka\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ca href=\"https://blog.csdn.net/weixin_42109071/article/details/107564094\"\u003ehttps://blog.csdn.net/weixin_42109071/article/details/107564094\u003c/a\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"redis\"\u003eredis\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ca href=\"https://blog.csdn.net/m0_52985087/article/details/134466218\"\u003ehttps://blog.csdn.net/m0_52985087/article/details/134466218\u003c/a\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ca href=\"https://cloud.tencent.com/developer/article/2184759\"\u003ehttps://cloud.tencent.com/developer/article/2184759\u003c/a\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"mysql\"\u003emysql\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ca href=\"https://blog.csdn.net/m0_52985087/article/details/134444801\"\u003ehttps://blog.csdn.net/m0_52985087/article/details/134444801\u003c/a\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"docker\"\u003edocker\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ca href=\"https://blog.csdn.net/chexlong/article/details/127932711\"\u003ehttps://blog.csdn.net/chexlong/article/details/127932711\u003c/a\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"elasticsearch\"\u003eelasticsearch\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ca href=\"https://blog.csdn.net/Acloasia/article/details/130683934\"\u003ehttps://blog.csdn.net/Acloasia/article/details/130683934\u003c/a\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"prometheus\"\u003eprometheus\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ca href=\"https://blog.csdn.net/qq_31725371/article/details/114697770\"\u003ehttps://blog.csdn.net/qq_31725371/article/details/114697770\u003c/a\u003e\u003c/p\u003e\u003c/blockquote\u003e","title":"软件安装教程"},{"content":"本文通过使用Nginx反向代理ONLYOFFICE来解决在Vue代码中写死网络路径，让修改ONLYOFFICE路径变得更加方便，不用再烦恼每次更新都需要修改代码。\nVue代码 \u0026lt;template\u0026gt; \u0026lt;DocumentEditor id=\u0026#34;docEditor\u0026#34; documentServerUrl=\u0026#34;http://documentserver/\u0026#34; :config=\u0026#34;config\u0026#34; /\u0026gt; \u0026lt;/template\u0026gt; 解决将documentServerUrl变成基于当前页面的反向代理，这样只需要修改Nginx配置就可以快速切换ONLYOFFICE服务端\n\u0026lt;template\u0026gt; \u0026lt;DocumentEditor id=\u0026#34;docEditor\u0026#34; :documentServerUrl=\u0026#34;window.location.origin + \u0026#39;/onlyoffice\u0026#39;\u0026#34; :config=\u0026#34;config\u0026#34; /\u0026gt; \u0026lt;/template\u0026gt; Nginx反向代理 https://github.com/ONLYOFFICE/document-server-proxy/blob/master/nginx/proxy-to-virtual-path.conf\nlocation /onlyoffice/ {\rproxy_pass http://127.0.0.1:8881/;\rproxy_http_version 1.1;\rproxy_set_header Upgrade $http_upgrade;\rproxy_set_header Connection \u0026#34;upgrade\u0026#34;;\rproxy_set_header X-Forwarded-Host $http_host/onlyoffice;\rproxy_set_header X-Forwarded-Proto $scheme;\rproxy_set_header X-Forwarded-Port $server_port;\rproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\r} 划重点\n/onlyoffice/ http://127.0.0.1:8881/ 最后的/一定需要 $http_host/onlyoffice 中需要添加 /onlyoffice $http_host 比 $host 多添加了端口号！！！ ","permalink":"https://lesanouo.github.io/blog/posts/code/175069440001/","summary":"\u003cp\u003e本文通过使用Nginx反向代理ONLYOFFICE来解决在Vue代码中写死网络路径，让修改ONLYOFFICE路径变得更加方便，不用再烦恼每次更新都需要修改代码。\u003c/p\u003e","title":"使用Nginx反向代理ONLYOFFICE"},{"content":"简介 ONLYOFFICE是一个值得推荐的软件，它能够帮助各种规模和类型的团队安全地在线协作处理文档。\n文档编辑功能 支持多种格式：可以编辑Word、Excel、PowerPoint、PDF等多种常见格式的文件。 兼容性强：与Microsoft Office和OpenOffice格式兼容，保证文件的互通性。 多种编辑工具：提供丰富的文本编辑、表格功能、图形和图像插入等多种编辑工具。 云办公支持 文档在线协作：支持多人同时编辑同一个文档，可以实时看到其他人的编辑内容。 文件共享与管理：通过ONLYOFFICE平台，可以方便地管理和共享文件。 文件版本控制：自动保存文档版本，支持版本回溯，确保文件的完整性和可追溯性。 高度集成的工作平台 邮件、日历和任务管理：集成了邮件、日历、任务等管理功能，帮助团队协作和工作流优化。 云存储：支持将文件存储在ONLYOFFICE云端，也支持第三方云存储（如Google Drive、Dropbox等）的集成。 API接口：提供丰富的API，允许开发者定制或集成ONLYOFFICE到其他业务系统中。 安全性 文件加密：支持文件加密功能，保护文件隐私。 权限控制：可以设置不同用户的访问权限，确保敏感信息的安全。 双重身份验证：增强安全性，防止未经授权的访问。 跨平台支持 桌面端与移动端支持：提供Windows、macOS和Linux版本的桌面应用，还支持iOS和Android移动端应用。 Web版：支持通过浏览器直接访问，避免设备限制。 开放源码与自托管 开源版本：ONLYOFFICE提供免费开源版本，用户可以根据需要自定义和修改代码。 自托管：允许企业将ONLYOFFICE部署在自己的服务器上，确保数据的安全和控制。 集成与兼容性 与其他工具集成：可以与Microsoft Office、Google Workspace、Nextcloud等工具进行集成。 插件支持：支持第三方插件，增强功能的灵活性。 更多ONLYOFFICE相关信息可访问其官网、GitHub、开发文档\nDocker安装 准备镜像 通过Docker我们可以很快速的安装ONLYOFFICE\nhttps://helpcenter.onlyoffice.com/docs/installation/docs-community-install-docker.aspx\ndocker pull onlyoffice/documentserver:latest 运行镜像 docker run -itd -p 8881:80 --restart=always \\ -v /data/onlyoffice/DocumentServer/prod/logs:/var/log/onlyoffice \\ -v /data/onlyoffice/DocumentServer/prod/data:/var/www/onlyoffice/Data \\ -v /data/onlyoffice/DocumentServer/prod/lib:/var/lib/onlyoffice \\ -v /data/onlyoffice/DocumentServer/prod/db:/var/lib/postgresql \\ -e JWT_SECRET=gie_jwt_secret -e ALLOW_META_IP_ADDRESS=true -e ALLOW_PRIVATE_IP_ADDRESS=true \\ --name=onlyoffice --privileged onlyoffice/documentserver 文件说明：\n/var/log/onlyoffice for ONLYOFFICE Docs logs /var/www/onlyoffice/Data for certificates /var/lib/onlyoffice for file cache /var/lib/postgresql for database 变量说明：\n-e JWT_SECRET=gie_jwt_secret JWT验证密钥，JWT_ENABLED默认为true -e ALLOW_META_IP_ADDRESS=true -e ALLOW_PRIVATE_IP_ADDRESS=true 允许内网访问 结果 通过浏览器输入http://电脑IP:8881，一定要用电脑IP，防止出现无法正常试用的问题。\n访问成功后会自动跳转welcome页面！\n一些问题！！！ 内网访问 修改容器中的/etc/onlyoffice/documentserver/default.json以下字段\n\u0026#34;request-filtering-agent\u0026#34; : { \u0026#34;allowPrivateIPAddress\u0026#34;: true, \u0026#34;allowMetaIPAddress\u0026#34;: true }, 可以通过docker cp命令进行修改，容器内没有vi或vim命令\ndocker cp onlyoffice:/etc/onlyoffice/documentserver/default.json ./ vim default.json docker cp ./default.json onlyoffice:/etc/onlyoffice/documentserver/default.json 修改local.json文件 如设置token，修改 local.json 文件时，需要执行如下命令，否则镜像重启会恢复原内容：\nsupervisorctl restart all 添加中文字体 准备中文字体 先准备好自己需要安装的字体，可以直接从windows系统C:\\Windows\\Fonts下选择拷贝，也可以参考这个网址，热心人已经给整理好了，地址：onlyoffice-chinese-fonts\n删除onlyoffice自带字体 先要进入容器删除onlyoffice原有字体，注意：如果只是添加字体，且想使用原有字体的话那么就不用删除原有字体\n# 进入容器 docker exec -it onlyoffice bash # 进入容器后执行 cd /usr/share/fonts/ rm -rf * cd /var/www/onlyoffice/documentserver/core-fonts/ rm -rf * 添加新字体 用docker cp命令将下载的字体都放到容器内的/usr/share/fonts目录下。\n生成字体 进入容器，执行命令：/usr/bin/documentserver-generate-allfonts.sh\n本文参考至 https://blog.csdn.net/fire_in_java/article/details/138905726、https://blog.csdn.net/XINYANGXINNIAN/article/details/135288590\n","permalink":"https://lesanouo.github.io/blog/posts/code/175060800002/","summary":"\u003ch2 id=\"简介\"\u003e简介\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eONLYOFFICE\u003c/code\u003e是一个值得推荐的软件，它能够帮助各种规模和类型的团队安全地在线协作处理文档。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e文档编辑功能\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e支持多种格式：可以编辑Word、Excel、PowerPoint、PDF等多种常见格式的文件。\u003c/li\u003e\n\u003cli\u003e兼容性强：与Microsoft Office和OpenOffice格式兼容，保证文件的互通性。\u003c/li\u003e\n\u003cli\u003e多种编辑工具：提供丰富的文本编辑、表格功能、图形和图像插入等多种编辑工具。\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e云办公支持\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e文档在线协作：支持多人同时编辑同一个文档，可以实时看到其他人的编辑内容。\u003c/li\u003e\n\u003cli\u003e文件共享与管理：通过ONLYOFFICE平台，可以方便地管理和共享文件。\u003c/li\u003e\n\u003cli\u003e文件版本控制：自动保存文档版本，支持版本回溯，确保文件的完整性和可追溯性。\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e高度集成的工作平台\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e邮件、日历和任务管理：集成了邮件、日历、任务等管理功能，帮助团队协作和工作流优化。\u003c/li\u003e\n\u003cli\u003e云存储：支持将文件存储在ONLYOFFICE云端，也支持第三方云存储（如Google Drive、Dropbox等）的集成。\u003c/li\u003e\n\u003cli\u003eAPI接口：提供丰富的API，允许开发者定制或集成ONLYOFFICE到其他业务系统中。\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003e安全性\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e文件加密：支持文件加密功能，保护文件隐私。\u003c/li\u003e\n\u003cli\u003e权限控制：可以设置不同用户的访问权限，确保敏感信息的安全。\u003c/li\u003e\n\u003cli\u003e双重身份验证：增强安全性，防止未经授权的访问。\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"5\"\u003e\n\u003cli\u003e跨平台支持\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e桌面端与移动端支持：提供Windows、macOS和Linux版本的桌面应用，还支持iOS和Android移动端应用。\u003c/li\u003e\n\u003cli\u003eWeb版：支持通过浏览器直接访问，避免设备限制。\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"6\"\u003e\n\u003cli\u003e开放源码与自托管\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e开源版本：ONLYOFFICE提供免费开源版本，用户可以根据需要自定义和修改代码。\u003c/li\u003e\n\u003cli\u003e自托管：允许企业将ONLYOFFICE部署在自己的服务器上，确保数据的安全和控制。\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"7\"\u003e\n\u003cli\u003e集成与兼容性\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e与其他工具集成：可以与Microsoft Office、Google Workspace、Nextcloud等工具进行集成。\u003c/li\u003e\n\u003cli\u003e插件支持：支持第三方插件，增强功能的灵活性。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e更多\u003ccode\u003eONLYOFFICE\u003c/code\u003e相关信息可访问其\u003ca href=\"https://www.onlyoffice.com/zh/\"\u003e官网\u003c/a\u003e、\u003ca href=\"https://github.com/ONLYOFFICE/DocumentServer\"\u003eGitHub\u003c/a\u003e、\u003ca href=\"https://api.onlyoffice.com/\"\u003e开发文档\u003c/a\u003e\u003c/p\u003e","title":"Docker安装ONLYOFFICE"},{"content":"当我们再Resource目录下存放了office文件（如word、ppt、excel等），一经编译后会导致文件损坏无法打开。\n原因：编译后会对文件进行转码\n解决方法：通过maven-resources-plugin排除相关文件就可以解决问题，在pom文件中添加以下代码。\n\u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-resources-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${maven-resources-plugin.version}\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;nonFilteredFileExtensions\u0026gt; \u0026lt;nonFilteredFileExtension\u0026gt;xdb\u0026lt;/nonFilteredFileExtension\u0026gt; \u0026lt;nonFilteredFileExtension\u0026gt;csv\u0026lt;/nonFilteredFileExtension\u0026gt; \u0026lt;nonFilteredFileExtension\u0026gt;xlsx\u0026lt;/nonFilteredFileExtension\u0026gt; \u0026lt;nonFilteredFileExtension\u0026gt;pdf\u0026lt;/nonFilteredFileExtension\u0026gt; \u0026lt;nonFilteredFileExtension\u0026gt;docx\u0026lt;/nonFilteredFileExtension\u0026gt; \u0026lt;nonFilteredFileExtension\u0026gt;pptx\u0026lt;/nonFilteredFileExtension\u0026gt; \u0026lt;/nonFilteredFileExtensions\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; ","permalink":"https://lesanouo.github.io/blog/posts/code/175060800001/","summary":"\u003cp\u003e当我们再Resource目录下存放了office文件（如word、ppt、excel等），一经编译后会导致文件损坏无法打开。\u003c/p\u003e\n\u003cp\u003e原因：编译后会对文件进行转码\u003c/p\u003e","title":"Maven解决Resource下office文件编译后损坏"},{"content":"数据是无价的，对于数据库来说，由于人为或自然等等各种各样的突发事件，很容易导致数据错误或数据丢失等情况，甚至是数据库崩溃，所以为了保障数据的安全，我们需要对数据库进行有效的定时全量和增量备份来保护数据库。\n通过全量备份和增量备份两种方式配合能够更高效的进行数据备份。\n全量备份 mysqldump --lock-all-tables --flush-logs --master-data=2 -u root -p test \u0026gt; xxx.sql 参数 --lock-all-tables\n对于InnoDB将替换为 --single-transaction。\n该选项在导出数据之前提交一个 BEGIN SQL 语句，BEGIN 不会阻塞任何应用程序且能保证导出时数据库的一致性状态。它只适用于事务表，例如 InnoDB 和 BDB。本选项和 \u0026ndash;lock-tables 选项是互斥的，因为 LOCK TABLES 会使任何挂起的事务隐含提交。要想导出大表的话，应结合使用 \u0026ndash;quick 选项。\n参数 --flush-logs\n结束当前日志，生成并使用新日志文件。\n参数 --master-data=2\n该选项将会在输出SQL中记录下完全备份后新日志文件的名称，用于日后恢复时参考，例如输出的备份SQL文件中含有：CHANGE MASTER TO MASTER_LOG_FILE='MySQL-bin.000002', MASTER_LOG_POS=106;。\n参数 test\n该处的test表示数据库test，如果想要将所有的数据库备份，可以换成参数 --all-databases。\n参数 --quick 或 -q\n该选项在导出大表时很有用，它强制 MySQLdump 从服务器查询取得记录直接输出而不是取得所有记录后将它们缓存到内存中。\n参数 --ignore-table\n忽略某个数据表，如 --ignore-table test.user 忽略数据库test里的user表\n更多 mysqldump 参数，请参考网址\n全量备份脚本 #!/bin/bash # 备份工具 tool=mysqldump # 用户名 username=root # 密码 password=QWE123456. # 将要备份的数据库 database_name=oa # 保存全量备份文件个数 number=15 # 备份保存路径 backup_dir=/logs/mysqlbackup # 增量备份路径 backup_daliy_dir=/logs/bkdaliy # 日志文件 logFile=/logs/mysqlbackup/bak.log # 日期 dd=`date +%Y-%m-%d-%H-%M-%S` # 备份文件 dumpFile=\u0026#34;${database_name}-${dd}.sql\u0026#34; gzDumpFile=\u0026#34;${database_name}-${dd}.sql.gz\u0026#34; beginTime=`date +\u0026#34;%Y年%m月%d日 %H:%M:%S\u0026#34;` #如果文件夹不存在则创建 if [ ! -d $backup_dir ]; then mkdir -p $backup_dir; fi #简单写法 mysqldump -u root -p123456 users \u0026gt; /root/mysqlbackup/users-$filename.sql $tool -u $username -p$password $database_name --ignore-table=$database_name.infra_api_access_log --quick --events --flush-logs --delete-master-logs --single-transaction --default-character-set=utf8mb4 | gzip \u0026gt; $backup_dir/$gzDumpFile endTime=`date +\u0026#34;%Y年%m月%d日 %H:%M:%S\u0026#34;` #写创建备份日志 echo 开始:$beginTime 结束:$endTime $gzDumpFile succ \u0026gt;\u0026gt; $logFile #找出需要删除的备份 delfile=`ls -l -crt $backup_dir/*.sql.gz | awk \u0026#39;{print $9 }\u0026#39; | head -1` #判断现在的备份数量是否大于$number count=`ls -l -crt $backup_dir/*.sql.gz | awk \u0026#39;{print $9 }\u0026#39; | wc -l` if [ $count -gt $number ] then #删除最早生成的备份，只保留number数量的备份 rm $delfile fi #删除所有增长备份数据 cd $backup_daliy_dir rm -f * 还原备份 有两种方式还原，第一种是在 MySQL 命令行中，第二种是使用 SHELL 行完成还原\n在系统命令行中，输入如下实现还原： mysql -uroot -p123456 \u0026lt; /data/mysqlDump/mydb.sql\n在登录进入mysql系统中,通过source指令找到对应系统中的文件进行还原： mysql\u0026gt; source /data/mysqlDump/mydb.sql\n增量备份 开启log_bin 检查状态 进入mysql命令行，执行 show variables like '%log_bin%' 查看log_bin开启状态\nmysql\u0026gt; show variables like \u0026#39;%log_bin%\u0026#39;; +---------------------------------+-------+ | Variable_name | Value | +---------------------------------+-------+ | log_bin | OFF | | log_bin_basename | | | log_bin_index | | | log_bin_trust_function_creators | OFF | | log_bin_use_v1_row_events | OFF | | sql_log_bin | ON | +---------------------------------+-------+ 6 rows in set (0.01 sec) 编辑 mysql 的配置文件 vim /etc/my.cnf，在 mysqld 下面添加下面2条配置 [mysqld]\rlog-bin=/var/lib/mysql/mysql-bin\rserver_id=152 Tip1: 一定要加 server_id，否则会报错。至于server_id的值，随便设就可以。\nTip2: log_bin 中间可以下划线_相连，也可以-减号相连。同理server_id也一样。\n重启mysql service mysqld restart\n再次在mysql命令行中执行 show variables like '%log_bin%' mysql\u0026gt; show variables like \u0026#39;%log_bin%\u0026#39;; +---------------------------------+--------------------------------+ | Variable_name | Value | +---------------------------------+--------------------------------+ | log_bin | ON | | log_bin_basename | /var/lib/mysql/mysql-bin | | log_bin_index | /var/lib/mysql/mysql-bin.index | | log_bin_trust_function_creators | OFF | | log_bin_use_v1_row_events | OFF | | sql_log_bin | ON | +---------------------------------+--------------------------------+ 6 rows in set (0.01 sec) 备份 进入mysql命令行，执行 show master status; mysql\u0026gt; show master status; +------------------+----------+--------------+------------------+-------------------+ | File | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set | +------------------+----------+--------------+------------------+-------------------+ | mysql-bin.000003 | 430 | | | | +------------------+----------+--------------+------------------+-------------------+ 1 row in set (0.00 sec) 当前正在记录日志的文件名是 mysql-bin.000003\n执行命令mysqladmin -uroot -p密码 flush-logs，生成并使用新的日志文件 再次查看当前使用的日志文件，已经变为 mysql-bin.000004 了。 增量备份脚本 #!/bin/bash # 增量备份时复制mysql-bin.00000*的目标目录，提前手动创建这个目录 BakDir=/logs/bkdaliy # 日志文件 LogFile=/logs/mysqlbackup/log.txt # mysql的数据目录 BinDir=/var/lib/mysql # mysql的index文件路径，放在数据目录下的 BinFile=/var/lib/mysql/mysql-bin.index # 这个是用于产生新的mysql-bin.00000*文件 mysqladmin -uroot -pQWE123456. flush-logs Counter=`wc -l $BinFile | awk \u0026#39;{print $1}\u0026#39;` NextNum=0 # 这个for循环用于比对$Counter,$NextNum这两个值来确定文件是不是存在或最新的 for file in `cat $BinFile` do base=`basename $file` NextNum=`expr $NextNum + 1` if [ $NextNum -eq $Counter ] then echo $base skip! \u0026gt;\u0026gt; $LogFile else dest=$BakDir/$base #test -e用于检测目标文件是否存在，存在就写exist!到$LogFile去 if(test -e $dest) then echo $base exist! \u0026gt;\u0026gt; $LogFile else cp $BinDir/$base $BakDir echo $base copying \u0026gt;\u0026gt; $LogFile fi fi done echo `date +\u0026#34;%Y年%m月%d日 %H:%M:%S\u0026#34;` $Next Bakup succ! \u0026gt;\u0026gt; $LogFile 还原备份 从备份的日志文件mysql-bin.000003中恢复数据\nmysqlbinlog --no-defaults /var/lib/mysql/mysql-bin.000003 | mysql -uroot -p test Enter password: ERROR 1032 (HY000) at line 36: Can\u0026#39;t find record in \u0026#39;bk_user\u0026#39; 如果遇到上述问题的话，可以试着修改 /etc/my.cnf 配置。在server_id那一行下添加了 slave_skip_errors=1032 ，然后再执行。\ncrontab定时任务 在 Linux 中，周期执行的任务一般由cron这个守护进程来处理[ps -ef|grep cron]。cron读取一个或多个配置文件，这些配置文件中包含了命令行及其调用时间。cron的配置文件称为“crontab”，是“cron table”的简写。\ncrontab语法 crontab命令用于安装、删除或者列出用于驱动cron后台进程的表格。用户把需要执行的命令序列放到crontab文件中以获得执行。每个用户都可以有自己的crontab文件。/var/spool/cron下的crontab文件不可以直接创建或者直接修改。该crontab文件是通过crontab命令创建的。\n在crontab文件中如何输入需要执行的命令和时间。该文件中每行都包括六个域，其中前五个域是指定命令被执行的时间，最后一个域是要被执行的命令。每个域之间使用空格或者制表符分隔。\n格式如下：\nminute hour day-of-month month-of-year day-of-week commands\r合法值 00-59 00-23 01-31 01-12 0-6 (0 is sunday)\r除了数字还有几个个特殊的符号就是\u0026#34;*\u0026#34;、\u0026#34;/\u0026#34;和\u0026#34;-\u0026#34;、\u0026#34;,\u0026#34;，*代表所有的取值范围内的数字，\u0026#34;/\u0026#34;代表每的意思,\u0026#34;/5\u0026#34;表示每5个单位，\u0026#34;-\u0026#34;代表从某个数字到某个数字,\u0026#34;,\u0026#34;分开几个离散的数字。\r-l 在标准输出上显示当前的crontab。\r-r 删除当前的crontab文件。\r-e 使用VISUAL或者EDITOR环境变量所指的编辑器编辑当前的crontab文件。当结束编辑离开时，编辑后的文件将自动安装。 添加执行命令 执行命令 crontab -e，添加如下配置\n# 每个星期日凌晨3:00执行完全备份脚本 0 3 * * 0 /bin/bash -x /root/bash/Mysql-FullyBak.sh \u0026gt;/dev/null 2\u0026gt;\u0026amp;1 # 周一到周六凌晨3:00做增量备份 0 3 * * 1-6 /bin/bash -x /root/bash/Mysql-DailyBak.sh \u0026gt;/dev/null 2\u0026gt;\u0026amp;1 可能遇到的问题 Can\u0026rsquo;t connect to local MySQL server through socket \u0026lsquo;/tmp/mysql.sock\u0026rsquo; mysqladmin: connect to server at \u0026#39;localhost\u0026#39; failed\rerror: \u0026#39;Can\u0026#39;t connect to local MySQL server through socket \u0026#39;/tmp/mysql.sock\u0026#39; (2)\u0026#39;\rCheck that mysqld is running and that the socket: \u0026#39;/tmp/mysql.sock\u0026#39; exists 去修改mysql的配置文件，添加\n[mysqladmin]\r# 修改为相应的sock\rsocket=/var/lib/mysql/mysql.sock 执行mysqldump时遇到 Unknown table 'column_statistics' in information_schema (1109) 如果使用MySQL 8.0+版本提供的命令行工具mysqldump来导出低于8.0版本的MySQL数据库到SQL文件，会出现Unknown table \u0026lsquo;column_statistics\u0026rsquo; in information_schema的错误，因为早期版本的MySQL数据库的information_schema数据库中没有名为COLUMN_STATISTICS的数据表。\n解决问题的方法是，使用8.0以前版本MySQL附带的mysqldump工具，最好使用待备份的MySQL服务器版本对应版本号的mysqldump工具，mysqldump可以独立运行，并不依赖完整的MySQL安装包，比如在Windows中，可以直接从MySQL安装目录的bin目录中将mysqldump.exe复制到其他文件夹，甚至从一台电脑复制到另一台电脑，然后在CMD窗口中运行。\n当使用是的MySQL 5.7.22。把5.7.20的 MYSQL_HOME/bin/mysqldump 替换掉 5.7.22的，接着就能顺利执行mysqldump了，也真是奇了怪了。\n","permalink":"https://lesanouo.github.io/blog/posts/code/175017600001/","summary":"\u003cp\u003e数据是无价的，对于数据库来说，由于人为或自然等等各种各样的突发事件，很容易导致数据错误或数据丢失等情况，甚至是数据库崩溃，所以为了保障数据的安全，我们需要对数据库进行有效的定时全量和增量备份来保护数据库。\u003c/p\u003e","title":"MySQL数据库定时全量与增量备份"},{"content":"在学习一些老旧的项目时下载各种的依赖但是下载的时候一直提示失败，显示python的依赖一直下载不下来。\n通过以下命令就能成功下载\nnpm --python_mirror=https://registry.npmmirror.com/-/binary/python/ install --global windows-build-tools\nDownloading python-2.7.15.amd64.msi Error: getaddrinfo EAI_AGAIN www.python.org:443 Downloading Python failed. Error: { Error: getaddrinfo EAI_AGAIN www.python.org:443 at Object._errnoException (util.js:992:11) at errnoException (dns.js:55:15) at GetAddrInfoReqWrap.onlookup [as oncomplete] (dns.js:92:26) code: \u0026#39;EAI_AGAIN\u0026#39;, errno: \u0026#39;EAI_AGAIN\u0026#39;, syscall: \u0026#39;getaddrinfo\u0026#39;, hostname: \u0026#39;www.python.org\u0026#39;, host: \u0026#39;www.python.org\u0026#39;, port: 443 } windows-build-tools will now exit. npm ERR! code ELIFECYCLE npm ERR! errno 1 npm ERR! windows-build-tools@5.1.0 postinstall: `node ./dist/index.js` npm ERR! Exit status 1 npm ERR! npm ERR! Failed at the windows-build-tools@5.1.0 postinstall script. npm ERR! This is probably not a problem with npm. There is likely additional logging output above. ","permalink":"https://lesanouo.github.io/blog/posts/code/175000320001/","summary":"\u003cp\u003e在学习一些老旧的项目时下载各种的依赖但是下载的时候一直提示失败，显示python的依赖一直下载不下来。\u003c/p\u003e\n\u003cp\u003e通过以下命令就能成功下载\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003enpm --python_mirror=https://registry.npmmirror.com/-/binary/python/ install --global windows-build-tools\u003c/code\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eDownloading python-2.7.15.amd64.msi\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eError: getaddrinfo EAI_AGAIN www.python.org:443\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eDownloading Python failed. Error: \u003cspan class=\"o\"\u003e{\u003c/span\u003e Error: getaddrinfo EAI_AGAIN www.python.org:443\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    at Object._errnoException \u003cspan class=\"o\"\u003e(\u003c/span\u003eutil.js:992:11\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    at errnoException \u003cspan class=\"o\"\u003e(\u003c/span\u003edns.js:55:15\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    at GetAddrInfoReqWrap.onlookup \u003cspan class=\"o\"\u003e[\u003c/span\u003eas oncomplete\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e(\u003c/span\u003edns.js:92:26\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  code: \u003cspan class=\"s1\"\u003e\u0026#39;EAI_AGAIN\u0026#39;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  errno: \u003cspan class=\"s1\"\u003e\u0026#39;EAI_AGAIN\u0026#39;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  syscall: \u003cspan class=\"s1\"\u003e\u0026#39;getaddrinfo\u0026#39;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  hostname: \u003cspan class=\"s1\"\u003e\u0026#39;www.python.org\u0026#39;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  host: \u003cspan class=\"s1\"\u003e\u0026#39;www.python.org\u0026#39;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  port: \u003cspan class=\"m\"\u003e443\u003c/span\u003e \u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ewindows-build-tools will now exit.\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003enpm ERR! code ELIFECYCLE\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003enpm ERR! errno \u003cspan class=\"m\"\u003e1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003enpm ERR! windows-build-tools@5.1.0 postinstall: \u003cspan class=\"sb\"\u003e`\u003c/span\u003enode ./dist/index.js\u003cspan class=\"sb\"\u003e`\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003enpm ERR! Exit status \u003cspan class=\"m\"\u003e1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003enpm ERR!\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003enpm ERR! Failed at the windows-build-tools@5.1.0 postinstall script.\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003enpm ERR! This is probably not a problem with npm. There is likely additional logging output above.\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"npm中windows-build-tools下载问题"},{"content":"本文为 dynamic-datasource-spring-boot-starter （基于SpringBoot的快速集成多数据源框架）的使用文档。\n特性 支持 数据源分组 ，适用于多种场景，纯粹多库、读写分离、一主多从、混合模式。 支持数据库敏感配置信息 加密(可自定义) ENC()。 支持每个数据库独立初始化表结构schema和数据库database。 支持无数据源启动，支持 懒加载数据源 （需要的时候再创建连接）。 支持 自定义注解 ，需继承DS(3.2.0+)。 提供并简化对Druid，HikariCp，BeeCp，Dbcp2的快速集成。 提供对 Mybatis-Plus ，Quartz，ShardingJdbc，P6sy，Jndi等组件的集成方案。 提供 自定义数据源来源 方案（如全从数据库加载）。 提供项目启动后 动态增加移除数据源 方案。 提供Mybatis环境下的 纯读写分离 方案。 提供使用 spel动态参数 解析数据源方案。内置spel，session，header，支持自定义。 支持 多层数据源嵌套切换 。（ServiceA \u0026raquo;\u0026gt; ServiceB \u0026raquo;\u0026gt; ServiceC）。 提供 基于seata的分布式事务方案 。 提供 本地多数据源事务方案 。 约定 dynamic-datasource只做 切换数据源 这件核心的事情，并 不限制你的具体操作 ，切换了数据源可以做任何CRUD。 配置文件所有以下划线 _ 分割的数据源 首部 即为组的名称，相同组名称的数据源会放在一个组下。 切换数据源可以是组名，也可以是具体数据源名称。 组名则切换时采用负载均衡算法切换 。 默认的数据源名称为 master ，你可以通过 spring.datasource.dynamic.primary 修改。 方法上的注解优先于类上注解。 DS支持继承抽象类上的DS，暂不支持继承接口上的DS。 使用方法 引入dynamic-datasource-spring-boot-starter spring-boot 1.5.x、2.x.x\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.baomidou\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;dynamic-datasource-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; spring-boot3及以上\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.baomidou\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;dynamic-datasource-spring-boot3-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 配置数据源 spring: datasource: dynamic: primary: master # 设置默认的数据源或者数据源组,默认值即为master strict: false # 严格匹配数据源,默认false. true未匹配到指定数据源时抛异常,false使用默认数据源 datasource: master: url: jdbc:mysql://xx.xx.xx.xx:3306/dynamic username: root password: 123456 driver-class-name: com.mysql.cj.jdbc.Driver # 3.2.0开始支持SPI可省略此配置 slave_1: url: jdbc:mysql://xx.xx.xx.xx:3307/dynamic username: root password: 123456 driver-class-name: com.mysql.cj.jdbc.Driver slave_2: url: ENC(xxxxx) # 内置加密,使用请查看详细文档 username: ENC(xxxxx) password: ENC(xxxxx) driver-class-name: com.mysql.cj.jdbc.Driver # ......省略 # 以上会配置一个默认库master，一个组slave下有两个子库slave_1,slave_2 # 多主多从 spring: datasource: dynamic: datasource: master_1: master_2: slave_1: slave_2: slave_3: # 纯粹多库（记得设置primary） spring: datasource: dynamic: datasource: mysql: oracle: sqlserver: postgresql: h2: # 混合配置 spring: datasource: dynamic: datasource: master: slave_1: slave_2: oracle_1: oracle_2: 使用 @DS 切换数据源 @DS 可以注解在方法上或类上，同时存在 就近原则，方法上注解 优先于 类上注解。\n注解 结果 没有@DS 默认数据源 @DS(\u0026ldquo;dsName\u0026rdquo;) dsName可以为组名也可以为具体某个库的名称，组名则切换时采用负载均衡算法切换 @Service @DS(\u0026#34;slave\u0026#34;) public class UserServiceImpl implements UserService { @Autowired private JdbcTemplate jdbcTemplate; // 使用slave数据源 public List selectAll() { return jdbcTemplate.queryForList(\u0026#34;select * from user\u0026#34;); } // 使用slave_1数据源 @Override @DS(\u0026#34;slave_1\u0026#34;) public List selectByCondition() { return jdbcTemplate.queryForList(\u0026#34;select * from user where age \u0026gt;10\u0026#34;); } } DS放在哪里合适 DS作为切换数据源核心注解，我应该把他注解在哪里合适？\n这其实是初次接触多数据源的人常问的问题。\n这其实没有一定的要求，只是有一些经验之谈。\n首先开发者要了解的基础知识是，DS注解是基于AOP的原理实现的，aop的常见失效场景应清楚，比如内部调用失效，shiro代理失效。\n通常建议DS放在serviceImpl的方法上，如事务注解一样。\n注解在Controller的方法上或类上 并不是不可以，作者并不建议的原因主要是controller主要作用是参数的检验等一些基础逻辑的处理，这部分操作常常并不涉及数据库。\n注解在service的实现类的方法或类上 这是作者建议的方式，service主要是对业务的处理， 在复杂的场景涉及连续切换不同的数据库。\n如果你的方法有通用性，其他service也会调用你的方法。 这样别人就不用重复处理切换数据源。\n注解在Mapper上 通常如果你某个Mapper对应的表只在确定的一个库，也是可以的，但是建议只注解在Mapper的类上。\n我之前出现多线程失效场景的时候，就是在Mapper上加了注解解决的。\n其他使用方式 继承抽象类上的DS\n比如我有一个抽象Service，我想实现继承我这个抽象Service下的子Service的所有方法除非重新指定，都用我抽象Service上注解的数据源。是否支持？\n答：支持。\n继承接口上的DS\n3.4.1开始支持， 但是需要注意的是，一个类能实现多个接口，如果多个接口都有DS会如何？\n不知道，别这么干。一般不会有人这么干吧，想一想都知道会出问题。\n连接池集成 传统多数据源集成连接池如果需要配置的参数较多，则手动编码量大，编程复杂。\ndynamic-datasource实现了常见数据源的参数配置，支持全局配置每个数据源继承。\n通过本章您可以快速掌握不同连接池的集成配置方案和继承中可能遇见的问题。\n连接池必读 每个数据源都有一个type来指定连接池。\n每个数据源甚至可以使用不同的连接池，如无特殊需要并不建议。\ntype 不是必填字段。\n在没有设置type的时候系统会自动按以下顺序查找并使用连接池：\nDruid \u0026gt; HikariCp \u0026gt; BeeCp \u0026gt; DBCP2 \u0026gt; Spring Basic。\nspring: datasource: dynamic: primary: db1 datasource: db1: url: jdbc:mysql://xx.xx.xx.xx:3306/dynamic username: root password: 123456 driver-class-name: com.mysql.cj.jdbc.Driver type: com.zaxxer.hikari.HikariDataSource # 使用Hikaricp db2: url: jdbc:mysql://xx.xx.xx.xx:3307/dynamic username: root password: 123456 driver-class-name: com.mysql.cj.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource # 使用Druid db3: url: jdbc:mysql://xx.xx.xx.xx:3308/dynamic username: root password: 123456 driver-class-name: com.mysql.cj.jdbc.Driver type: cn.beecp.BeeDataSource # 使用beecp 集成Druid 基础介绍 Druid Github：点我跳转\nDruid 文档：点我跳转\ndynamic-datasource能简单高效完成对Druid的集成并完成其参数的多元化配置。\n各个库可以使用不同的数据库连接池，如 master使用Druid，slave使用HikariCP。\n如果项目同时存在Druid和HikariCP并且未配置连接池type类型，默认Druid优先于HikariCP。\n集成步骤 1、项目引入 druid-spring-boot-starter 依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;druid-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 2、排除原生Druid的快速配置类\n注意：v3.3.3及以上 版本不用排除了。\n@SpringBootApplication(exclude = DruidDataSourceAutoConfigure.class) public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } 某些SpringBoot的版本上面可能无法排除可用以下方式排除。\nspring: autoconfigure: exclude: com.alibaba.druid.spring.boot.autoconfigure.DruidDataSourceAutoConfigure 3、参数配置\n如果参数都未配置，则保持原组件默认值。 如果配置了全局参数，则每一个数据源都会继承对应参数。 每一个数据源可以单独设置参数覆盖全局参数。 spring: datasource: druid: stat-view-servlet: enabled: true loginUsername: admin loginPassword: 123456 dynamic: druid: # 以下是支持的全局默认值 initial-size: max-active: min-idle: max-wait: time-between-eviction-runs-millis: time-between-log-stats-millis: stat-sqlmax-size: min-evictable-idle-time-millis: max-evictable-idle-time-millis: test-while-idle: test-on-borrow: test-on-return: validation-query: validation-query-timeout: use-global-datasource-stat: async-init: clear-filters-enable: reset-stat-enable: not-full-timeout-retry-count: max-wait-thread-count: fail-fast: phyTimeout-millis: keep-alive: pool-prepared-statements: init-variants: init-global-variants: use-unfair-lock: kill-when-socket-read-timeout: connection-properties: max-pool-prepared-statement-per-connection-size: init-connection-sqls: share-prepared-statements: connection-errorretry-attempts: break-after-acquire-failure: filters: stat # 注意这个值和druid原生不一致，默认启动了stat wall: noneBaseStatementAllow: callAllow: selectAllow: selectIntoAllow: selectIntoOutfileAllow: selectWhereAlwayTrueCheck: selectHavingAlwayTrueCheck: selectUnionCheck: selectMinusCheck: selectExceptCheck: selectIntersectCheck: createTableAllow: dropTableAllow: alterTableAllow: renameTableAllow: hintAllow: lockTableAllow: startTransactionAllow: blockAllow: conditionAndAlwayTrueAllow: conditionAndAlwayFalseAllow: conditionDoubleConstAllow: conditionLikeTrueAllow: selectAllColumnAllow: deleteAllow: deleteWhereAlwayTrueCheck: deleteWhereNoneCheck: updateAllow: updateWhereAlayTrueCheck: updateWhereNoneCheck: insertAllow: mergeAllow: minusAllow: intersectAllow: replaceAllow: setAllow: commitAllow: rollbackAllow: useAllow: multiStatementAllow: truncateAllow: commentAllow: strictSyntaxCheck: constArithmeticAllow: limitZeroAllow: describeAllow: showAllow: schemaCheck: tableCheck: functionCheck: objectCheck: variantCheck: mustParameterized: doPrivilegedAllow: dir: tenantTablePattern: tenantColumn: wrapAllow: metadataAllow: conditionOpXorAllow: conditionOpBitwseAllow: caseConditionConstAllow: completeInsertValuesCheck: insertValuesCheckSize: selectLimit: stat: merge-sql: log-slow-sql: slow-sql-millis: datasource: master: username: root password: 123456 driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://xx.xx.xx.xx:3306/dynamic?characterEncoding=utf8\u0026amp;useSSL=false druid: # 以下是独立参数，每个库可以重新设置 initial-size: 20 validation-query: select 1 FROM DUAL # 比如oracle就需要重新设置这个 public-key: #（非全局参数）设置即表示启用加密,底层会自动帮你配置相关的连接参数和filter，推荐使用本项目自带的加密方法。 以下是我曾经配置过的示例：\n# 数据源配置 spring: # 排除掉druid原生的自动配置 autoconfigure: exclude: com.alibaba.druid.spring.boot.autoconfigure.DruidDataSourceAutoConfigure datasource: druid: # 初始连接数 initialSize: 5 # 最小连接池数量 minIdle: 10 # 最大连接池数量 maxActive: 20 # 配置获取连接等待超时的时间 maxWait: 60000 # 配置连接超时时间 connectTimeout: 30000 # 配置网络超时时间 socketTimeout: 60000 # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 timeBetweenEvictionRunsMillis: 60000 # 配置一个连接在池中最小生存的时间，单位是毫秒 minEvictableIdleTimeMillis: 300000 # 配置一个连接在池中最大生存的时间，单位是毫秒 maxEvictableIdleTimeMillis: 900000 # 配置检测连接是否有效 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false webStatFilter: enabled: true statViewServlet: enabled: true # 设置白名单，不填则允许所有访问 allow: url-pattern: /druid/* # 控制台管理用户名和密码 login-username: admin login-password: 123456 filter: stat: enabled: true # 慢SQL记录 log-slow-sql: true slow-sql-millis: 2000 merge-sql: true wall: config: multi-statement-allow: true dynamic: druid: # 初始连接数 initial-size: 5 # 最小连接池数量 min-idle: 10 # 最大连接池数量 max-active: 20 # 配置获取连接等待超时的时间 max-wait: 60000 # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 time-between-eviction-runs-millis: 60000 # 配置一个连接在池中最小生存的时间，单位是毫秒 min-evictable-idle-time-millis: 300000 # 配置一个连接在池中最大生存的时间，单位是毫秒 max-evictable-idle-time-millis: 900000 # 配置检测连接是否有效 validation-query: SELECT 1 FROM DUAL test-while-idle: true test-on-borrow: false test-on-return: false # 打开PSCache，并指定每个连接上PSCache的大小。 # oracle设为true，mysql设为false。分库分表较多推荐设置为false pool-prepared-statements: false max-pool-prepared-statement-per-connection-size: 20 filters: stat # 注意这个值和druid原生不一致，默认启动了stat stat: merge-sql: true log-slow-sql: true slow-sql-millis: 2000 primary: master # 设置默认的数据源或者数据源组 strict: false # 设置严格模式,默认false不启动,启动后在未匹配到指定数据源时候回抛出异常,不启动会使用默认数据源 datasource: master: url: jdbc:mysql://192.168.56.101:3306/master?useUnicode=true\u0026amp;characterEncoding=utf8\u0026amp;zeroDateTimeBehavior=convertToNull\u0026amp;useSSL=true\u0026amp;serverTimezone=GMT%2B8 username: root password: root driver-class-name: com.mysql.cj.jdbc.Driver slave_1: url: jdbc:mysql://192.168.56.102:3306/slave_1?useUnicode=true\u0026amp;characterEncoding=utf8\u0026amp;zeroDateTimeBehavior=convertToNull\u0026amp;useSSL=true\u0026amp;serverTimezone=GMT%2B8\u0026amp;rewriteBatchedStatements=true username: root password: root driver-class-name: com.mysql.cj.jdbc.Driver slave_2: url: jdbc:mysql://192.168.56.103:3306/slave_2?useUnicode=true\u0026amp;characterEncoding=utf8\u0026amp;zeroDateTimeBehavior=convertToNull\u0026amp;useSSL=true\u0026amp;serverTimezone=GMT%2B8\u0026amp;rewriteBatchedStatements=true username: root password: root driver-class-name: com.mysql.cj.jdbc.Driver druid: # 以下参数针对每个库可以重新设置druid参数 initial-size: validation-query: select 1 FROM DUAL # 比如oracle就需要重新设置这个 public-key: #（非全局参数）设置即表示启用加密,底层会自动帮你配置相关的连接参数和filter。 如上即可配置访问用户和密码，访问 http://ip:端口/druid/index.html 查看druid监控。\n示例项目 点我跳转\n核心源码 Druid数据源创建器：点我跳转\nDruid参数源码：点我跳转\n集成HikariCP 基础介绍 HikariCP Github：点我跳转\nHikariCP 文档：点我跳转\n集成步骤 1、项目引入 HikariCP 依赖\nSpringBoot2.x.x默认引入了HikariCP，除非对版本有要求无需再次引入。\nSpringBoot 1.5.x需手动引入，对应的版本请根据自己环境和HikariCP官方文档自行选择。\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.zaxxer\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;HikariCP\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 2、参数配置\n如果参数都未配置，则保持原组件默认值。 如果配置了全局参数，则每一个数据源都会继承对应参数。 每一个数据源可以单独设置参数覆盖全局参数。 特别注意，hikaricp原生设置某些字段名和dynamic-datasource不一致，dynamic-datasource是根据参数反射设置，而原生hikaricp字段名称和set名称不一致。\nspring: datasource: dynamic: hikari: # 全局hikariCP参数，所有值和默认保持一致。(现已支持的参数如下,不清楚含义不要乱设置) catalog: connection-timeout: validation-timeout: idle-timeout: leak-detection-threshold: max-lifetime: max-pool-size: min-idle: initialization-fail-timeout: connection-init-sql: connection-test-query: dataSource-class-name: dataSource-jndi-name: schema: transaction-isolation-name: is-auto-commit: is-read-only: is-isolate-internal-queries: is-register-mbeans: is-allow-pool-suspension: data-source-properties: health-check-properties: datasource: master: username: root password: 123456 driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://xx.xx.xx.xx:3306/dynamic?characterEncoding=utf8\u0026amp;useSSL=false hikari: # 以下参数针对每个库可以重新设置hikari参数 max-pool-size: idle-timeout: # ...... 常见问题 Failed to validate connection com.mysql.jdbc.JDBC4Connection@xxxxx (No operations allowed after connection closed.)\nhttps://github.com/brettwooldridge/HikariCP/issues/1034\n核心意思就是HikariCP要设置 connection-test-query 并且max-lifetime要小于mysql的默认时间。\n核心源码 HikariCP数据源创建器：点我跳转\nHikariCP参数配置类：点我跳转\n第三方集成 通过本章您可以掌握数据源在集成MybatisPlus，Quartz，ShardingJdbc的方案。\n集成MybatisPlus 基础介绍 MybatisPlus Github：点我跳转\nMybatisPlus 文档： 点我跳转\n只要引入了MybatisPlus相关jar包，项目自动集成，兼容MybatisPlus2.x和3.x的版本。\n集成步骤 1、项目引入 Mybatis-Plus 依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.baomidou\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-plus-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 2、使用DS注解进行切换数据源\n@Service @DS(\u0026#34;mysql\u0026#34;) public class UserServiceImpl extends ServiceImpl\u0026lt;UserMapper, User\u0026gt; implements UserService { @DS(\u0026#34;oracle\u0026#34;) publid void addUser(User user){ //do something baseMapper.insert(user); } } 3、分页配置\n@Bean public MybatisPlusInterceptor mybatisPlusInterceptor() { MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); //如果是不同类型的库，请不要指定DbType，其会自动判断。 interceptor.addInnerInterceptor(new PaginationInnerInterceptor()); // interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); return interceptor; } 注意事项 MybatisPlus内置的ServiceImpl在新增，更改，删除等一些方法上自带事物导致不能切换数据源。\n解决方法：\n方法1：复制ServiceImpl出来为自己的MyServiceImpl，并去掉所有事务注解。\n方法2：创建一个新方法，并在此方法上加DS注解. 如上面的addUser方法。\nFAQ 为什么要单独拿出来说和MybatisPlus的集成？\n因为MybatisPlus重写了一些核心类，必须通过解析获得真实的代理对象。\n如果自己写多数据源，则很难完成与mp的集成。\n核心解析源码：点我跳转\n示例项目 点我跳转\n其他集成 集成P6spy、集成Quartz、集成ShardingJdbc\n由于以上场景暂时没用到，文章中暂时不体现了，如有用到，后面会补充上。\n进阶使用 动态添加移除数据源：指在系统运行过程中动态的添加数据源，删除数据源，多使用于基于数据库的多租户系统。\n动态解析数据源：指数据源切换是不固定的，可以根据域名，根据header参数，根据session参数，根据方法变量等来动态切换。多使用于多租户系统，支持扩展。\n数据库加密：指数据库的url，username，password需要加密，长用于安全性较高系统，不让普通开发通过配置知道生产库的连接配置。\n启动初始化脚本：指数据源启动的时候可以执行schema和data的脚本来初始化结构和数据，dynamic-datasource组件支持每个数据源加载不同的schema和data。\n自动读写分离：适用于mybatis环境，基于mybatis插件实现无注解自动读写分离。\n懒启动数据源：指配置的数据源不立即启动，等需要建立连接的时候再真正初始化连接池。\n无数据源启动：指启动的时候不配置任何数据源，全靠后期系统动态添加。\n手动切换数据源：指某些情况无法根据注解切换，通过工具类手动切换数据源。\n动态添加移除数据源 基础介绍 主要在多租户场景中，常常新的一个租户进来需要动态的添加一个数据源到库中，使得系统不用重启即可切换数据源。\n使用步骤 import com.baomidou.dynamic.datasource.DynamicRoutingDataSource; import com.baomidou.dynamic.datasource.creator.*; import com.baomidou.dynamic.datasource.spring.boot.autoconfigure.DataSourceProperty; import com.baomidou.samples.ds.dto.DataSourceDTO; import io.swagger.annotations.Api; import io.swagger.annotations.ApiOperation; import org.springframework.beans.BeanUtils; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.validation.annotation.Validated; import org.springframework.web.bind.annotation.*; import javax.sql.DataSource; import java.util.Set; @RestController @RequestMapping(\u0026#34;/datasources\u0026#34;) @Api(tags = \u0026#34;添加删除数据源\u0026#34;) public class DataSourceController { @Autowired private DataSource dataSource; // private final DataSourceCreator dataSourceCreator; // 3.3.1及以下版本使用这个通用，强烈推荐sb2用户至少升级到3.5.2版本 @Autowired private DefaultDataSourceCreator dataSourceCreator; @Autowired private BasicDataSourceCreator basicDataSourceCreator; @Autowired private JndiDataSourceCreator jndiDataSourceCreator; @Autowired private DruidDataSourceCreator druidDataSourceCreator; @Autowired private HikariDataSourceCreator hikariDataSourceCreator; @Autowired private BeeCpDataSourceCreator beeCpDataSourceCreator; @Autowired private Dbcp2DataSourceCreator dbcp2DataSourceCreator; @GetMapping @ApiOperation(\u0026#34;获取当前所有数据源\u0026#34;) public Set\u0026lt;String\u0026gt; now() { DynamicRoutingDataSource ds = (DynamicRoutingDataSource) dataSource; return ds.getDataSources().keySet(); } // 通用数据源会根据maven中配置的连接池根据顺序依次选择。 // 默认的顺序为druid\u0026gt;hikaricp\u0026gt;beecp\u0026gt;dbcp\u0026gt;spring basic @PostMapping(\u0026#34;/add\u0026#34;) @ApiOperation(\u0026#34;通用添加数据源（推荐）\u0026#34;) public Set\u0026lt;String\u0026gt; add(@Validated @RequestBody DataSourceDTO dto) { DataSourceProperty dataSourceProperty = new DataSourceProperty(); BeanUtils.copyProperties(dto, dataSourceProperty); DynamicRoutingDataSource ds = (DynamicRoutingDataSource) dataSource; DataSource dataSource = dataSourceCreator.createDataSource(dataSourceProperty); ds.addDataSource(dto.getPoolName(), dataSource); return ds.getDataSources().keySet(); } @PostMapping(\u0026#34;/addBasic(强烈不推荐，除了用了马上移除)\u0026#34;) @ApiOperation(value = \u0026#34;添加基础数据源\u0026#34;, notes = \u0026#34;调用Springboot内置方法创建数据源，兼容1,2\u0026#34;) public Set\u0026lt;String\u0026gt; addBasic(@Validated @RequestBody DataSourceDTO dto) { DataSourceProperty dataSourceProperty = new DataSourceProperty(); BeanUtils.copyProperties(dto, dataSourceProperty); DynamicRoutingDataSource ds = (DynamicRoutingDataSource) dataSource; DataSource dataSource = basicDataSourceCreator.createDataSource(dataSourceProperty); ds.addDataSource(dto.getPoolName(), dataSource); return ds.getDataSources().keySet(); } @PostMapping(\u0026#34;/addJndi\u0026#34;) @ApiOperation(\u0026#34;添加JNDI数据源\u0026#34;) public Set\u0026lt;String\u0026gt; addJndi(String pollName, String jndiName) { DynamicRoutingDataSource ds = (DynamicRoutingDataSource) dataSource; DataSource dataSource = jndiDataSourceCreator.createDataSource(jndiName); ds.addDataSource(poolName, dataSource); return ds.getDataSources().keySet(); } @PostMapping(\u0026#34;/addDruid\u0026#34;) @ApiOperation(\u0026#34;基础Druid数据源\u0026#34;) public Set\u0026lt;String\u0026gt; addDruid(@Validated @RequestBody DataSourceDTO dto) { DataSourceProperty dataSourceProperty = new DataSourceProperty(); BeanUtils.copyProperties(dto, dataSourceProperty); dataSourceProperty.setLazy(true); DynamicRoutingDataSource ds = (DynamicRoutingDataSource) dataSource; DataSource dataSource = druidDataSourceCreator.createDataSource(dataSourceProperty); ds.addDataSource(dto.getPoolName(), dataSource); return ds.getDataSources().keySet(); } @PostMapping(\u0026#34;/addHikariCP\u0026#34;) @ApiOperation(\u0026#34;基础HikariCP数据源\u0026#34;) public Set\u0026lt;String\u0026gt; addHikariCP(@Validated @RequestBody DataSourceDTO dto) { DataSourceProperty dataSourceProperty = new DataSourceProperty(); BeanUtils.copyProperties(dto, dataSourceProperty); dataSourceProperty.setLazy(true); // 3.4.0版本以下如果有此属性，需手动设置，不然会空指针。 DynamicRoutingDataSource ds = (DynamicRoutingDataSource) dataSource; DataSource dataSource = hikariDataSourceCreator.createDataSource(dataSourceProperty); ds.addDataSource(dto.getPoolName(), dataSource); return ds.getDataSources().keySet(); } @PostMapping(\u0026#34;/addBeeCp\u0026#34;) @ApiOperation(\u0026#34;基础BeeCp数据源\u0026#34;) public Set\u0026lt;String\u0026gt; addBeeCp(@Validated @RequestBody DataSourceDTO dto) { DataSourceProperty dataSourceProperty = new DataSourceProperty(); BeanUtils.copyProperties(dto, dataSourceProperty); dataSourceProperty.setLazy(true); // 3.4.0版本以下如果有此属性，需手动设置，不然会空指针。 DynamicRoutingDataSource ds = (DynamicRoutingDataSource) dataSource; DataSource dataSource = beeCpDataSourceCreator.createDataSource(dataSourceProperty); ds.addDataSource(dto.getPoolName(), dataSource); return ds.getDataSources().keySet(); } @PostMapping(\u0026#34;/addDbcp\u0026#34;) @ApiOperation(\u0026#34;基础Dbcp数据源\u0026#34;) public Set\u0026lt;String\u0026gt; addDbcp(@Validated @RequestBody DataSourceDTO dto) { DataSourceProperty dataSourceProperty = new DataSourceProperty(); BeanUtils.copyProperties(dto, dataSourceProperty); dataSourceProperty.setLazy(true); // 3.4.0版本以下如果有此属性，需手动设置，不然会空指针。 DynamicRoutingDataSource ds = (DynamicRoutingDataSource) dataSource; DataSource dataSource = dbcp2DataSourceCreator.createDataSource(dataSourceProperty); ds.addDataSource(dto.getPoolName(), dataSource); return ds.getDataSources().keySet(); } @DeleteMapping @ApiOperation(\u0026#34;删除数据源\u0026#34;) public String remove(String name) { DynamicRoutingDataSource ds = (DynamicRoutingDataSource) dataSource; ds.removeDataSource(name); return \u0026#34;删除成功\u0026#34;; } } 示例项目 点我跳转\n源码分析 public interface DataSourceCreator { /** * 通过属性创建数据源 * * @param dataSourceProperty 数据源属性 * @return 被创建的数据源 */ DataSource createDataSource(DataSourceProperty dataSourceProperty); /** * 当前创建器是否支持根据此属性创建 * * @param dataSourceProperty 数据源属性 * @return 是否支持 */ boolean support(DataSourceProperty dataSourceProperty); } DataSourceCreator是一个接口，定义了根据参数创建数据源的接口。\n其他creator实现此接口，dynamic-datasource项目暂时实现了Druid和Hikaricp的等连接池的实现。\nBasicDataSourceCreator 是调用Spring原生的创建方式，只支持最最原始的基础配置。\nDefaultDataSourceCreator 是一个通用的创建器，其根据环境自动选择连接池。\n动态解析数据源 基础介绍 默认有三个职责链来处理动态参数解析器 header -\u0026gt; session -\u0026gt; spel\n所有以 # 开头的参数都会从参数中获取数据源\n@DS(\u0026#34;#session.tenantName\u0026#34;) // 从session获取 public List selectSpelBySession() { return userMapper.selectUsers(); } @DS(\u0026#34;#header.tenantName\u0026#34;) // 从header获取 public List selectSpelByHeader() { return userMapper.selectUsers(); } @DS(\u0026#34;#tenantName\u0026#34;) // 使用spel从参数获取 public List selectSpelByKey(String tenantName) { return userMapper.selectUsers(); } @DS(\u0026#34;#user.tenantName\u0026#34;) // 使用spel从复杂参数获取 public List selecSpelByTenant(User user) { return userMapper.selectUsers(); } 如何扩展 我想从cookie中获取参数解析? 我想从其他环境属性中来计算? 参考header解析器，继承DsProcessor，如果matches返回true则匹配成功，调用doDetermineDatasource返回匹配到的数据源，否则跳到下一个解析器。\n1、自定义一个处理器\npublic class DsHeaderProcessor extends DsProcessor { private static final String HEADER_PREFIX = \u0026#34;#header\u0026#34;; @Override public boolean matches(String key) { return key.startsWith(HEADER_PREFIX); } @Override public String doDetermineDatasource(MethodInvocation invocation, String key) { HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest(); return request.getHeader(key.substring(8)); } } 2、重写完后重新注入一个根据自己解析顺序的解析处理器\n@Configuration public class MyDynamicDataSourceConfig{ @Bean public DsProcessor dsProcessor() { DsHeaderProcessor headerProcessor = new DsHeaderProcessor(); DsSessionProcessor sessionProcessor = new DsSessionProcessor(); DsSpelExpressionProcessor spelExpressionProcessor = new DsSpelExpressionProcessor(); headerProcessor.setNextProcessor(sessionProcessor); sessionProcessor.setNextProcessor(spelExpressionProcessor); return headerProcessor; } } 注意 如果在Mapper接口下面的方法使用：\npublic interface UserMapper{ // 前缀可以是p0,a0 @DS(\u0026#34;#p0.tenantName\u0026#34;) public List selecSpelByTenant(User user); } 对于在接口下面的使用, 由于编译器的默认配置没有将接口参数的元数据写入字节码文件中 所以spring el会无法识别参数名称, 只能用默认的参数命名方式\n第一个参数: p0，a0,(加入-parameters后，可以使用参数具体的名字，例如这里的#user) 第二个参数: p1，a1 第三个参数: P2,，a2 可以通过修改maven配置和java编译配置将接口参数信息写入字节码文件\n\u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-compiler-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;!-- 想启用 \u0026lt;parameters\u0026gt;true\u0026lt;/parameters\u0026gt; 的maven编译最低版本为:3.6.2 --\u0026gt; \u0026lt;version\u0026gt;3.6.2\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;source\u0026gt;${java.version}\u0026lt;/source\u0026gt; \u0026lt;target\u0026gt;${java.version}\u0026lt;/target\u0026gt; \u0026lt;parameters\u0026gt;true\u0026lt;/parameters\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; idea java编译配置: -parameters\njava 支持-parameters的最低版本为 1.8\n数据库加密 基础介绍 在一些项目中，有对数据库关键字段加密的需求，大家熟悉的是Druid的加密方式。\n在连接池集成中的Druid章节里有对应的加密方式，但是如果我不用Druid也想用加密呢？\n所以作者copy了Druid的加密相关源码，嘿嘿。\ndynamic-datasource项目也支持支持url , username, password 的加密。\n使用的RAS加密，相关原理文章 https://www.cnblogs.com/pcheng/p/9629621.html。\n简单来说就是生成两把钥匙，私钥加密，公钥解密。\n公钥可以发布出去，解密也是用的公钥。\n具体使用 1、获得加密字符串\nimport com.baomidou.dynamic.datasource.toolkit.CryptoUtils; public class Demo { public static void main(String[] args) throws Exception { String password = \u0026#34;123456\u0026#34;; // 使用默认的publicKey ，建议还是使用下面的自定义 String encodePassword = CryptoUtils.encrypt(password); System.out.println(encodePassword); } // 自定义publicKey public static void main(String[] args) throws Exception { String[] arr = CryptoUtils.genKeyPair(512); System.out.println(\u0026#34;privateKey: \u0026#34; + arr[0]); System.out.println(\u0026#34;publicKey: \u0026#34; + arr[1]); System.out.println(\u0026#34;url: \u0026#34; + CryptoUtils.encrypt(arr[0], \u0026#34;jdbc:mysql://127.0.0.1:3306/order\u0026#34;)); System.out.println(\u0026#34;username: \u0026#34; + CryptoUtils.encrypt(arr[0], \u0026#34;root\u0026#34;)); System.out.println(\u0026#34;password: \u0026#34; + CryptoUtils.encrypt(arr[0], \u0026#34;123456\u0026#34;)); } } 2、配置加密yml\nENC(xxx) 中包裹的xxx即为使用上面加密方法后生成的字符串\nspring: datasource: dynamic: public-key: # 有默认值，强烈建议更换 datasource: master: url: ENC(xxx) username: ENC(xxx) password: ENC(xxx) driver-class-name: com.mysql.cj.jdbc.Driver public-key: # 每个数据源可以独立设置，没有就继承上面的。 自定义解密 一些公司要求使用自己的方式加密，解密。\n从3.5.0版本开始，扩展了一个event，用户自行实现注入即可。\npublic interface DataSourceInitEvent { /** * 连接池创建前执行（可用于参数解密） * * @param dataSourceProperty 数据源基础信息 */ void beforeCreate(DataSourceProperty dataSourceProperty); /** * 连接池创建后执行 * * @param dataSource 连接池 */ void afterCreate(DataSource dataSource); } 默认的实现是EncDataSourceInitEvent，即ENC方式的。\n为什么不是公钥加密，私钥解密 根据RSA的设计，大部分人会认为应该是公钥加密，私钥解密。 为什么Druid设计相反？\n建议更高的安全，可以把publicKey在启动时候传进去，或者配置中心配好，不让普通开发接触到就好。\n查询了Druid的ISSUE和一些文章：\n1、Druid作者wenshao自己的回答：点我跳转\n2、知乎一些文章片段\n启动初始化执行脚本 3.5.0 之前版本\nspring: datasource: dynamic: primary: order datasource: order: # 基础配置省略... schema: db/order/schema.sql # 配置则生效,自动初始化表结构 data: db/order/data.sql # 配置则生效,自动初始化数据 continue-on-error: true # 默认true,初始化失败是否继续 separator: \u0026#34;;\u0026#34; # sql默认分号分隔符，一般无需更改 product: schema: classpath*:db/product/schema.sql data: classpath*:db/product/data.sql user: schema: classpath*:db/user/schema/**/*.sql data: classpath*:db/user/data/**/*.sql 3.5.0（含） 之后版本 (层级多了一层init，保持和新版springboot一致)\nspring: datasource: dynamic: primary: order datasource: order: # 基础配置省略... init: schema: db/order/schema.sql # 配置则生效,自动初始化表结构 data: db/order/data.sql # 配置则生效,自动初始化数据 continue-on-error: true # 默认true,初始化失败是否继续 separator: \u0026#34;;\u0026#34; # sql默认分号分隔符，一般无需更改 懒启动数据源 懒启动：连接池创建出来后并不会立即初始化连接池，等需要使用connection的时候再初始化。\n暂时只支持Druid和HikariCp和BeeCp连接池。\n主要场景可能适合于数据源很多，又不需要启动立即初始化的情况，可以减少系统启动时间。\n缺点在于，如果参数配置有误，则启动的时候不知道，初始化的时候失败，可能一直抛异常。\n配置使用 spring: datasource: dynamic: primary: master # 设置默认的数据源或者数据源组,默认值即为master strict: false # 设置严格模式,默认false不启动. 启动后在未匹配到指定数据源时候会抛出异常,不启动则使用默认数据源. lazy: true # 默认false非懒启动，系统加载到数据源立即初始化连接池 datasource: master: url: jdbc:mysql://xx.xx.xx.xx:3306/dynamic username: root password: 123456 driver-class-name: com.mysql.cj.jdbc.Driver lazy: true #表示这个数据源懒启动 db1: url: jdbc:mysql://xx.xx.xx.xx:3307/dynamic username: root password: 123456 driver-class-name: com.mysql.cj.jdbc.Driver db2: url: jdbc:mysql://xx.xx.xx.xx:3307/dynamic username: root password: 123456 driver-class-name: com.mysql.cj.jdbc.Driver 无数据源启动 基础介绍 场景：部分系统可能启动的时候完全不需要数据源，全靠启动后动态添加。\n配置方式 即基本不需要配置，可能根据需要配置一些类似Druid和HikariCp全局参数。\n如需配置Druid和HikariCp全局参数可参考对应章节文档。\nspring: datasource: dynamic: primary: master # 设置默认的数据源或者数据源组,默认值即为master strict: false # 设置严格模式,默认false不启动. 启动后在未匹配到指定数据源时候会抛出异常,不启动则使用默认数据源. 因为没有匹配的主数据源，启动的时候你会见到类似如下日志。\ndynamic-datasource initial loaded 0 datasource,Please add your primary datasource or check your configuration 手动切换数据源 在某些情况您可能需要手动切换数据源。\nimport com.baomidou.dynamic.datasource.toolkit.DynamicDataSourceContextHolder; @Service public class UserServiceImpl implements UserService { @Autowired private JdbcTemplate jdbcTemplate; public List selectAll() { DynamicDataSourceContextHolder.push(\u0026#34;slave\u0026#34;); // 手动切换 return jdbcTemplate.queryForList(\u0026#34;select * from user\u0026#34;); } } 需要注意的是手动切换的数据源，最好自己在合适的位置调用DynamicDataSourceContextHolder.clear()清空当前线程的数据源信息，防止内存泄漏，因为一层使用的是ThreadLocal\n如果你不太清楚什么时候调用，那么可以参考下面写一个拦截器，注册进spring里即可。\n@Slf4j public class DynamicDatasourceClearInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) { // 入口处清空看个人，有的新人在异步里切了数据源但是忘记清除了，下一个请求遇到这个线程就会带进来。 // DynamicDataSourceContextHolder.clear(); return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) { } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) { DynamicDataSourceContextHolder.clear(); } } 手动注入多数据源 什么时候需要手动注入多数据源？\n绝大部分是因为您的系统需要和其他数据源共同存在使用。\n如Quartz和ShardingJdbc等都需要使用独立的数据源。\ndynamic-datasource 3.4.0及以上版本和老版本注入方式有一定差别，根据自己版本注入。\n注意一定要让多数据源使用 @Primary ，让其成为主数据源。\n// 3.4.0版本以下 @Primary @Bean public DataSource dataSource(DynamicDataSourceProvider dynamicDataSourceProvider) { DynamicRoutingDataSource dataSource = new DynamicRoutingDataSource(); dataSource.setPrimary(properties.getPrimary()); dataSource.setStrict(properties.getStrict()); dataSource.setStrategy(properties.getStrategy()); dataSource.setProvider(dynamicDataSourceProvider); dataSource.setP6spy(properties.getP6spy()); dataSource.setSeata(properties.getSeata()); return dataSource; } // 3.4.0版本及以上 @Primary @Bean public DataSource dataSource() { DynamicRoutingDataSource dataSource = new DynamicRoutingDataSource(); dataSource.setPrimary(properties.getPrimary()); dataSource.setStrict(properties.getStrict()); dataSource.setStrategy(properties.getStrategy()); dataSource.setP6spy(properties.getP6spy()); dataSource.setSeata(properties.getSeata()); return dataSource; } 主要变更是因为3.4.0支持了多个provider同时生效，采取了内部注入，具体源码改动。\n自定义 自定义注解：不满足于默认DS注解，希望自定义注解。\n自定义数据源来源：默认的数据源来源是基于yml或者properties配置来的，组件支持同时从多个地方来加载初始化数据源。常用于多租户系统，从一个租户信息库多加载不同租户的数据源。\n自定义负载均衡策略：常用的有轮询，随机。支持扩展。\n自定义切面：支持不使用注解，通过配置来切换数据源。如某个包下所有service方法以select*开头的都走slave库，以add*开头的都走master库。\n自定义注解 基础介绍 如果你只有几个确定的库，可以尝试自定义注解替换掉@DS。\n建议从3.2.1版本开始使用自定义注解，另外组件自带了@Master和@Slave注解。\n使用方法 下面我们自定义一个产品库的注解，方便我们后面程序的使用。\n1、需要自己定义一个注解并继承自DS\nimport com.baomidou.dynamic.datasource.annotation.DS; import java.lang.annotation.*; @Target({ElementType.TYPE, ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented @DS(\u0026#34;product\u0026#34;) public @interface Product { } 2、注解在需要切换数据源的方法上或类上\n@Service @Product public class ProductServiceImpl implements ProductService { @Product public List selectAll() { return jdbcTemplate.queryForList(\u0026#34;select * from products\u0026#34;); } } 自定义数据源来源 基础介绍 数据源来源的默认实现是YmlDynamicDataSourceProvider，其从yaml或properties中读取信息并解析出所有数据源信息。\npublic interface DynamicDataSourceProvider { /** * 加载所有数据源 * * @return 所有数据源，key为数据源名称 */ Map\u0026lt;String, DataSource\u0026gt; loadDataSources(); } 自定义示例 可以参考 AbstractJdbcDataSourceProvider （仅供参考）来实现从JDBC数据库中获取数据库连接信息。\n@Bean public DynamicDataSourceProvider jdbcDynamicDataSourceProvider() { return new AbstractJdbcDataSourceProvider(\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;, \u0026#34;jdbc:mysql://xx.xx.xx.xx:3306/dynamic\u0026#34;, \u0026#34;root\u0026#34;, \u0026#34;root\u0026#34;) { @Override protected Map\u0026lt;String, DataSourceProperty\u0026gt; executeStmt(Statement statement) throws SQLException { ResultSet rs = statement.executeQuery(\u0026#34;select * from DB\u0026#34;); while (rs.next()) { String name = rs.getString(\u0026#34;name\u0026#34;); String username = rs.getString(\u0026#34;username\u0026#34;); String password = rs.getString(\u0026#34;password\u0026#34;); String url = rs.getString(\u0026#34;url\u0026#34;); String driver = rs.getString(\u0026#34;driver\u0026#34;); DataSourceProperty property = new DataSourceProperty(); property.setUsername(username); property.setPassword(password); property.setUrl(url); property.setDriverClassName(driver); map.put(name, property); } return map; } }; } PS: 从3.4.0开始，可以注入多个DynamicDataSourceProvider的Bean以实现同时从多个不同来源加载数据源，注意同名会被覆盖。\n自定义负载均衡策略 基础介绍 如下slave组下有三个数据源，当用户使用slave切换数据源时会使用负载均衡算法。\n系统自带了两个负载均衡算法:\nLoadBalanceDynamicDataSourceStrategy 轮询,是默认的。 RandomDynamicDataSourceStrategy 随机的。 spring: datasource: dynamic: datasource: master: username: root password: root url: jdbc:mysql://xx.xx.xx.xx:3306/dynamic driver-class-name: com.mysql.cj.jdbc.Driver schema: db/schema.sql slave_1: username: root password: root url: jdbc:mysql://xx.xx.xx.xx:3307/dynamic driver-class-name: com.mysql.cj.jdbc.Driver slave_2: username: root password: root url: jdbc:mysql://xx.xx.xx.xx:3308/dynamic driver-class-name: com.mysql.cj.jdbc.Driver slave_3: username: root password: root url: jdbc:mysql://xx.xx.xx.xx:3309/dynamic driver-class-name: com.mysql.cj.jdbc.Driver strategy: com.baomidou.dynamic.datasource.strategy.LoadBalanceDynamicDataSourceStrategy 如何自定义 如果默认的两个都不能满足要求，可以参考源码自定义，暂时只能全局更改。\nimport java.util.List; import java.util.concurrent.ThreadLocalRandom; import javax.sql.DataSource; public class RandomDynamicDataSourceStrategy implements DynamicDataSourceStrategy { public RandomDynamicDataSourceStrategy() { } public DataSource determineDataSource(List\u0026lt;DataSource\u0026gt; dataSources) { return (DataSource)dataSources.get(ThreadLocalRandom.current().nextInt(dataSources.size())); } } 无注解方案 不管是出于注解侵入性还是代码整洁等理由，我们都有需求不想使用注解的需求。\n但是需要理解多数据源实现的核心。\npublic class DynamicRoutingDataSource { @Override public DataSource determineDataSource() { // 这里是核心，是从ThreadLocal中获取当前数据源。 String dsKey = DynamicDataSourceContextHolder.peek(); return getDataSource(dsKey); } 所以我们就可以根据需求，选择合适的时机调用DynamicDataSourceContextHolder.push(\u0026quot;对应数据源\u0026quot;)。\n默认的@DS注解来切换数据源是根据spring AOP的特性，在方法开启前设置数据源KEY，方法执行完成后移除对应数据源KEY。\nfilter切换数据源 目标：拦截以filter/**开头的所有请求，如果后面的方法以a开头就切换到db1，以b开头就切换到db2，其余使用默认数据源。\n实现如下：\n@Slf4j @WebFilter(filterName = \u0026#34;dsFilter\u0026#34;, urlPatterns = {\u0026#34;/filter/*\u0026#34;}) public class DynamicDatasourceFilter implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { log.info(\u0026#34;loading filter {}\u0026#34;, filterConfig.getFilterName()); } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { HttpServletRequest request = (HttpServletRequest) servletRequest; HttpServletResponse response = (HttpServletResponse) servletResponse; String requestURI = request.getRequestURI(); log.info(\u0026#34;经过多数据源filter,当前路径是{}\u0026#34;, requestURI); // String headerDs = request.getHeader(\u0026#34;ds\u0026#34;); // Object sessionDs = request.getSession().getAttribute(\u0026#34;ds\u0026#34;); String s = requestURI.replaceFirst(\u0026#34;/filter/\u0026#34;, \u0026#34;\u0026#34;); String dsKey = \u0026#34;master\u0026#34;; if (s.startsWith(\u0026#34;a\u0026#34;)) { dsKey = \u0026#34;db1\u0026#34;; } else if (s.startsWith(\u0026#34;b\u0026#34;)) { dsKey = \u0026#34;db2\u0026#34;; } else { } // 执行 try { DynamicDataSourceContextHolder.push(dsKey); filterChain.doFilter(servletRequest, servletResponse); } finally { DynamicDataSourceContextHolder.poll(); } } @Override public void destroy() { } } @SpringBootApplication @ServletComponentScan // filter必须使用这个 @MapperScan(\u0026#34;com.baomidou.samples.ds.mapper\u0026#34;) public class AllDataSourceApplication { public static void main(String[] args) { SpringApplication.run(AllDataSourceApplication.class, args); } } 扩展：从request中还能获取到很多东西，如header和session，同理可以根据自己业务需求根据header值和session里对应的用户来动态设置和切换数据源。\nintercepror切换数据源 目标：拦截以interceptor/**开头的所有请求，如果后面的方法以a开头就切换到db1，以b开头就切换到db2，其余使用默认数据源。\n实现如下：\nimport com.baomidou.dynamic.datasource.toolkit.DynamicDataSourceContextHolder; import lombok.extern.slf4j.Slf4j; import org.springframework.web.servlet.HandlerInterceptor; import org.springframework.web.servlet.ModelAndView; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; @Slf4j public class DynamicDatasourceInterceptor implements HandlerInterceptor { /** * 在请求处理之前进行调用（Controller方法调用之前） */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) { String requestURI = request.getRequestURI(); log.info(\u0026#34;经过多数据源Interceptor,当前路径是{}\u0026#34;, requestURI); // String headerDs = request.getHeader(\u0026#34;ds\u0026#34;); // Object sessionDs = request.getSession().getAttribute(\u0026#34;ds\u0026#34;); String s = requestURI.replaceFirst(\u0026#34;/interceptor/\u0026#34;, \u0026#34;\u0026#34;); String dsKey = \u0026#34;master\u0026#34;; if (s.startsWith(\u0026#34;a\u0026#34;)) { dsKey = \u0026#34;db1\u0026#34;; } else if (s.startsWith(\u0026#34;b\u0026#34;)) { dsKey = \u0026#34;db2\u0026#34;; } else { } DynamicDataSourceContextHolder.push(dsKey); return true; } /** * 请求处理之后进行调用，但是在视图被渲染之前（Controller方法调用之后） */ @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) { } /** * 在整个请求结束之后被调用，也就是在DispatcherServlet渲染了对应的视图之后执行（主要是用于进行资源清理工作） */ @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) { DynamicDataSourceContextHolder.clear(); } } import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.InterceptorRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; @Configuration public class MyWebAutoConfig implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new DynamicDatasourceInterceptor()).addPathPatterns(\u0026#34;/interceptor/**\u0026#34;); } } 自定义切面 从3.4.0开始支持自定义切面。\n使用这个方式，原注解方式并不会失效。 注意：不要在同一个切面同时使用注解又使用自定义切面。 @Configuration public class MyConfig { @Bean public DynamicDatasourceNamedInterceptor dsAdvice(DsProcessor dsProcessor) { DynamicDatasourceNamedInterceptor interceptor = new DynamicDatasourceNamedInterceptor(dsProcessor); Map\u0026lt;String, String\u0026gt; patternMap = new HashMap\u0026lt;\u0026gt;(); patternMap.put(\u0026#34;select*\u0026#34;, \u0026#34;slave\u0026#34;); patternMap.put(\u0026#34;add*\u0026#34;, \u0026#34;master\u0026#34;); patternMap.put(\u0026#34;update*\u0026#34;, \u0026#34;master\u0026#34;); patternMap.put(\u0026#34;delete*\u0026#34;, \u0026#34;master\u0026#34;); interceptor.addPatternMap(patternMap); return interceptor; } @Bean public Advisor dsAdviceAdvisor(DynamicDatasourceNamedInterceptor dsAdvice) { AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut(); pointcut.setExpression(\u0026#34;execution (* com.baomidou.samples.pattern..service.*.*(..))\u0026#34;); return new DefaultPointcutAdvisor(pointcut, dsAdvice); } } 以上实现com.baomidou.samples.pattern包service下所有类的add/update/delete开头的方法使用master数据源，select使用slave数据源。\n更复杂的切点表达式语法需自行学习。\nmybatis下读写分离 场景：\n在纯的读写分离环境，写操作全部是master，读操作全部是slave。 不想通过注解配置完成以上功能。 答：在mybatis环境下可以基于mybatis插件结合dynamic-datasource完成以上功能。\n手动注入插件：\n@Bean public MasterSlaveAutoRoutingPlugin masterSlaveAutoRoutingPlugin(){ return new MasterSlaveAutoRoutingPlugin(); } 默认主库名称master，从库名称slave。\n暂不支持更多，源码简单可参考重写。\n@Intercepts({@Signature(type = Executor.class, method = \u0026#34;query\u0026#34;, args = {MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class}), @Signature(type = Executor.class, method = \u0026#34;update\u0026#34;, args = {MappedStatement.class, Object.class})}) @Slf4j public class MasterSlaveAutoRoutingPlugin implements Interceptor { private static final String MASTER = \u0026#34;master\u0026#34;; private static final String SLAVE = \u0026#34;slave\u0026#34;; @Override public Object intercept(Invocation invocation) throws Throwable { Object[] args = invocation.getArgs(); MappedStatement ms = (MappedStatement) args[0]; try { DynamicDataSourceContextHolder.push(SqlCommandType.SELECT == ms.getSqlCommandType() ? SLAVE : MASTER); return invocation.proceed(); } finally { DynamicDataSourceContextHolder.clear(); } } @Override public Object plugin(Object target) { return target instanceof Executor ? Plugin.wrap(target, this) : target; } @Override public void setProperties(Properties properties) { } } 事务专栏 使用多数据源的你一定会遇到事务问题：\n为什么使用了事务就切换不了数据源了啊？ 有没有什么解决方案啊？ 有没有使用案例和注意事项啊。 以上问题都能在本章节得到解答。\n方案一：dynamic-datasource集成了alibaba分布式事务组件seata。\n方案二：dynamic-datasource提供了无需外部组件的本地多数据源事务。\n各有各的优劣，总有一款适合你。\n事务概念 什么是事务？ 事务：是数据库操作的最小工作单元，是作为单个逻辑工作单元执行的一系列操作；这些操作作为一个整体一起向系统提交，要么都执行、要么都不执行；事务是一组不可再分割的操作集合（工作逻辑单元）。\n事务的四大特性：\n原子性 事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做 。\n一致性 事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统 运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是 不一致的状态。\n隔离性 一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。\n持续性 也称永久性，指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其它操作或故障不应该对其执行结果有任何影响。\n原生JDBC处理事务 try { connection.setAutoCommit(false); // 这里用connection对数据库做了一系列操作，CRUD connection.commit(); // 没有异常就提交 } catch(Exception ex){ connection.rollback(); // 异常回滚 } finally { connection.setAutoCommit(true); } 以上是事务的核心，所有操作要一起成功，只要出错就回滚。\nSpring处理事务 spring开启事务很简单，在需要事务的方法和类上添加@Transactional注解。\n@Transactional public void test() { Aservice.dosometing(); Bservice.dosometing(); } 使用了@Transactional，spring会保证整个事务下都复用同一个connection。\n在默认配置下，只要事务中发生RuntimeException，就会回滚。\n基础知识 问：使用了事务如@Transational无法切换数据源？\n答： 是的，本组件是基于springAop的方案来进行多数据源的管理和切换的，要想保证多个库的整体事务则需要分布式事务。\n问：为什么使用了事务如@Transational就无法切换数据源？\n答：开启了事务后，spring事务管理器会保证在事务下整个线程后续拿到的都是同一个connection。\n问：事务下无法切换数据源我知道了，那我单库的事务的可以用吗？\n答：完全可以的。只要事务下不切换数据源就OK。\n问：我的业务必须要保证事务，还有什么解决办法？\n方案一：seata就是解决此问题，本组件已完成和seata的自动集成。\n方案二：本组件从3.3.0开始支持本地多数据源事务，无需第三方。\n本地事务 背景 多数据源事务方案一直是一个难题，通常的解决方案有以下二种。\n利用atomiks手动构建多数据源事务，适合数据源较少，配置的参数也不太多,性能要求不高的项目。难点就是手动配置量大，需要耗费一定时间。\n用seata类似的分布式事务解决方案，难点就是需要搭建维护如seata-server的统一管理中心。 每一种方案都有其适用场景。你可能遇到最多的问题就是：\n为什么我加了事务注解，切换数据源失败？\n我了解涉及了分布式事务了，但我不想用seata，我场景简单，有没有不依赖第三方的方案？\n基础介绍 自从3.3.0开始，由seata的核心贡献者 https://github.com/a364176773 贡献了基于connection代理的方案。\n建议从3.4.0版本开始使用，其修复了一个功能，老版本不加@DS只加@DSTransactional会报错。\n注意事项 本地事务实现很简单，就是循环提交，发生错误，循环回滚。\n我们默认的前提是数据库本身不会异常，比如宕机。\n如数据在回滚的过程突然宕机，本地事务就会有问题。如果你需要完整分布式方案请使用seata方案。\n不支持spring原生事务，不支持spring事务，不支持spring事务，可分别使用，千万不能混用。 再次强调不支持spring事务注解，可理解成独立写了一套事务方案。 只适合简单本地多数据源场景， 如果涉及异步和微服务等完整事务场景，请使用seata方案。 暂时不支持更多配置，如只读，如spring的传播特性。 后续会根据反馈考虑支持。 使用方法 在最外层的方法添加 @DSTransactional，底下调用的各个类该切数据源就正常使用DS切换数据源即可，就是这么简单。\n// 如AService调用BService和CService的方法，A,B,C分别对应不同数据源。 @Service public class AService { @DS(\u0026#34;a\u0026#34;) // 如果a是默认数据源则不需要DS注解。 @DSTransactional public void dosomething(){ BService.dosomething(); CService.dosomething(); } } @Service public class BService { @DS(\u0026#34;b\u0026#34;) public void dosomething(){ // dosomething } } @Service public class CService { @DS(\u0026#34;c\u0026#34;) public void dosomething(){ // dosomething } } 只要@DSTransactional注解下任一环节发生异常，则全局多数据源事务回滚。\n如果BC上也有@DSTransactional会有影响吗？答：没有影响的。\n示例项目 点我跳转\n完整示例项目，数据库都已准备好，可以直接运行测试。\n示例项目A,B,C分别对应OrderService,ProductService，AccountService，分别是独立的数据库。\n用户下单分别调用产品库扣库存，账户库扣余额。\n如果库存不足，或用户余额不足都抛出RuntimeException，触发整体回滚。\n@Slf4j @Service @AllArgsConstructor public class OrderService { private final OrderMapper orderMapper; private final AccountService accountService; private final ProductService productService; // @DS(\u0026#34;order\u0026#34;) 这里不需要，因为order是默认库，如果开启事务的不是默认库则必须加 @DSTransactional // 注意这里开启事务 public void placeOrder(PlaceOrderRequest request) { log.info(\u0026#34;=============ORDER START=================\u0026#34;); Long userId = request.getUserId(); Long productId = request.getProductId(); Integer amount = request.getAmount(); log.info(\u0026#34;收到下单请求,用户:{}, 商品:{},数量:{}\u0026#34;, userId, productId, amount); log.info(\u0026#34;当前 XID: {}\u0026#34;, TransactionContext.getXID()); Order order = Order.builder() .userId(userId) .productId(productId) .status(OrderStatus.INIT) .amount(amount) .build(); orderMapper.insert(order); log.info(\u0026#34;订单一阶段生成，等待扣库存付款中\u0026#34;); // 扣减库存并计算总价 Double totalPrice = productService.reduceStock(productId, amount); // 扣减余额 accountService.reduceBalance(userId, totalPrice); order.setStatus(OrderStatus.SUCCESS); order.setTotalPrice(totalPrice); orderMapper.updateById(order); log.info(\u0026#34;订单已成功下单\u0026#34;); log.info(\u0026#34;=============ORDER END=================\u0026#34;); } } @Slf4j @Service @RequiredArgsConstructor public class ProductService { private final ProductMapper productMapper; @DS(\u0026#34;product\u0026#34;) public Double reduceStock(Long productId, Integer amount) { log.info(\u0026#34;=============PRODUCT START=================\u0026#34;); log.info(\u0026#34;当前 XID: {}\u0026#34;, TransactionContext.getXID()); // 检查库存 Product product = productMapper.selectById(productId); Assert.notNull(product, \u0026#34;商品不存在\u0026#34;); Integer stock = product.getStock(); log.info(\u0026#34;商品编号为 {} 的库存为{},订单商品数量为{}\u0026#34;, productId, stock, amount); if (stock \u0026lt; amount) { log.warn(\u0026#34;商品编号为{} 库存不足，当前库存:{}\u0026#34;, productId, stock); throw new RuntimeException(\u0026#34;库存不足\u0026#34;); } log.info(\u0026#34;开始扣减商品编号为 {} 库存,单价商品价格为{}\u0026#34;, productId, product.getPrice()); // 扣减库存 int currentStock = stock - amount; product.setStock(currentStock); productMapper.updateById(product); double totalPrice = product.getPrice() * amount; log.info(\u0026#34;扣减商品编号为 {} 库存成功,扣减后库存为{}, {} 件商品总价为 {} \u0026#34;, productId, currentStock, amount, totalPrice); log.info(\u0026#34;=============PRODUCT END=================\u0026#34;); return totalPrice; } } @Slf4j @Service @RequiredArgsConstructor public class AccountService { private final AccountMapper accountMapper; @DS(\u0026#34;account\u0026#34;) public void reduceBalance(Long userId, Double price) { log.info(\u0026#34;=============ACCOUNT START=================\u0026#34;); log.info(\u0026#34;当前 XID: {}\u0026#34;, TransactionContext.getXID()); Account account = accountMapper.selectById(userId); Assert.notNull(account, \u0026#34;用户不存在\u0026#34;); Double balance = account.getBalance(); log.info(\u0026#34;下单用户{}余额为 {},商品总价为{}\u0026#34;, userId, balance, price); if (balance \u0026lt; price) { log.warn(\u0026#34;用户 {} 余额不足，当前余额:{}\u0026#34;, userId, balance); throw new RuntimeException(\u0026#34;余额不足\u0026#34;); } log.info(\u0026#34;开始扣减用户 {} 余额\u0026#34;, userId); double currentBalance = account.getBalance() - price; account.setBalance(currentBalance); accountMapper.updateById(account); log.info(\u0026#34;扣减用户 {} 余额成功,扣减后用户账户余额为{}\u0026#34;, userId, currentBalance); log.info(\u0026#34;=============ACCOUNT END=================\u0026#34;); } } 原理介绍 点我跳转\n核心原理就是代理connection，并根据不同数据库获取到一个connection放入ConnectionFactory。\n如果成功了整体提交，失败了整体回滚。\nseata事务 基础介绍 seata Github地址：点我跳转\nseata 文档：点我跳转\nseata 示例：点我跳转\nPS：一般需要分布式事务的场景大多数都是微服务化，个人并不建议在单体项目引入多数据源+分布式事务，有能力尽早拆开，可为过度方案。\n注意事项 dynamic-datasource-sring-boot-starter 组件内部开启seata后会自动使用DataSourceProxy来包装DataSource，所以需要以下方式来保持兼容。\n1、如果你引入的是seata-all,请不要使用@EnableAutoDataSourceProxy注解。\n2、如果你引入的是seata-spring-boot-starter 请关闭自动代理。\nseata: enable-auto-data-source-proxy: false 示例项目 点我跳转\n此工程为 多数据源+druid+seata+mybatisPlus的版本。\n模拟用户下单，扣商品库存，扣用户余额，初步可分为订单服务+商品服务+用户服务。\n环境准备 为了快速演示相关环境都采用docker部署，生产上线请参考seata官方文档使用。\n1、准备seata-server。\ndocker run --name seata-server -p 8091:8091 -d seataio/seata-server 2、准备mysql数据库，账户root密码123456。\ndocker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7 3、创建相关数据库。\n创建 seata-order seata-product seata-account 模拟连接不同的数据库。\nCREATE DATABASE IF NOT EXIST seata-order;\rCREATE DATABASE IF NOT EXIST seata-product;\rCREATE DATABASE IF NOT EXIST seata-account; 4、准备相关数据库脚本。\n每个数据库下脚本相关的表，seata需要undo_log来监测和回滚。\n相关的seata脚本可到seata官方获取，另外配合多数据源的自动执行脚本功能，应用启动后会自动执行。\n工程准备 1、引入相关依赖，seata+druid+MybatisPlus+dynamic-datasource+mysql+lombok。\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.seata\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;seata-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.baomidou\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;dynamic-datasource-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; # 省略，查看示例项目 2、编写相关yaml配置。\nspring: application: name: dynamic datasource: dynamic: primary: order strict: true seata: true # 开启seata代理，开启后默认每个数据源都代理，如果某个不需要代理可单独关闭 seata-mode: AT # 支持XA及AT模式,默认AT datasource: order: username: root password: 123456 url: jdbc:mysql://192.168.56.101:3306/seata_order?useUnicode=true\u0026amp;characterEncoding=utf8\u0026amp;allowMultiQueries=true\u0026amp;useSSL=false driver-class-name: com.mysql.cj.jdbc.Driver schema: classpath:db/schema-order.sql account: username: root password: 123456 url: jdbc:mysql://192.168.56.101:3306/seata_account?useUnicode=true\u0026amp;characterEncoding=utf8\u0026amp;allowMultiQueries=true\u0026amp;useSSL=false driver-class-name: com.mysql.cj.jdbc.Driver schema: classpath:db/schema-account.sql product: username: root password: 123456 url: jdbc:mysql://192.168.56.101:3306/seata_product?useUnicode=true\u0026amp;characterEncoding=utf8\u0026amp;allowMultiQueries=true\u0026amp;useSSL=false driver-class-name: com.mysql.cj.jdbc.Driver schema: classpath:db/schema-product.sql test: username: lijing password: \u0026#34;\u0026#34; url: jdbc:h2:mem:test driver-class-name: org.h2.Driver seata: false # 这个数据源不需要seata seata: enabled: true application-id: applicationName tx-service-group: my_test_tx_group enable-auto-data-source-proxy: false #一定要是false service: vgroup-mapping: my_test_tx_group: default # key与上面的tx-service-group的值对应 grouplist: default: 192.168.56.101:8091 # seata-server地址仅file注册中心需要 config: type: file registry: type: file 代码编写 参考工程下面的代码完成controller,service,maaper,entity,dto等。\n订单服务\n@Slf4j @Service public class OrderServiceImpl implements OrderService { @Resource private OrderDao orderDao; @Autowired private AccountService accountService; @Autowired private ProductService productService; @DS(\u0026#34;order\u0026#34;)// 每一层都需要使用多数据源注解切换所选择的数据库 @Override @Transactional @GlobalTransactional // 重点 第一个开启事务的需要添加seata全局事务注解 public void placeOrder(PlaceOrderRequest request) { log.info(\u0026#34;=============ORDER START=================\u0026#34;); Long userId = request.getUserId(); Long productId = request.getProductId(); Integer amount = request.getAmount(); log.info(\u0026#34;收到下单请求,用户:{}, 商品:{},数量:{}\u0026#34;, userId, productId, amount); log.info(\u0026#34;当前 XID: {}\u0026#34;, RootContext.getXID()); Order order = Order.builder() .userId(userId) .productId(productId) .status(OrderStatus.INIT) .amount(amount) .build(); orderDao.insert(order); log.info(\u0026#34;订单一阶段生成，等待扣库存付款中\u0026#34;); // 扣减库存并计算总价 Double totalPrice = productService.reduceStock(productId, amount); // 扣减余额 accountService.reduceBalance(userId, totalPrice); order.setStatus(OrderStatus.SUCCESS); order.setTotalPrice(totalPrice); orderDao.updateById(order); log.info(\u0026#34;订单已成功下单\u0026#34;); log.info(\u0026#34;=============ORDER END=================\u0026#34;); } } 商品服务\n@Slf4j @Service public class ProductServiceImpl implements ProductService { @Resource private ProductDao productDao; /** * 事务传播特性设置为 REQUIRES_NEW 开启新的事务 重要！！！！一定要使用REQUIRES_NEW */ @DS(\u0026#34;product\u0026#34;) @Transactional(propagation = Propagation.REQUIRES_NEW) @Override public Double reduceStock(Long productId, Integer amount) { log.info(\u0026#34;=============PRODUCT START=================\u0026#34;); log.info(\u0026#34;当前 XID: {}\u0026#34;, RootContext.getXID()); // 检查库存 Product product = productDao.selectById(productId); Integer stock = product.getStock(); log.info(\u0026#34;商品编号为 {} 的库存为{},订单商品数量为{}\u0026#34;, productId, stock, amount); if (stock \u0026lt; amount) { log.warn(\u0026#34;商品编号为{} 库存不足，当前库存:{}\u0026#34;, productId, stock); throw new RuntimeException(\u0026#34;库存不足\u0026#34;); } log.info(\u0026#34;开始扣减商品编号为 {} 库存,单价商品价格为{}\u0026#34;, productId, product.getPrice()); // 扣减库存 int currentStock = stock - amount; product.setStock(currentStock); productDao.updateById(product); double totalPrice = product.getPrice() * amount; log.info(\u0026#34;扣减商品编号为 {} 库存成功,扣减后库存为{}, {} 件商品总价为 {} \u0026#34;, productId, currentStock, amount, totalPrice); log.info(\u0026#34;=============PRODUCT END=================\u0026#34;); return totalPrice; } } 用户服务\n@Slf4j @Service public class AccountServiceImpl implements AccountService { @Resource private AccountDao accountDao; /** * 事务传播特性设置为 REQUIRES_NEW 开启新的事务 重要！！！！一定要使用REQUIRES_NEW */ @DS(\u0026#34;account\u0026#34;) @Override @Transactional(propagation = Propagation.REQUIRES_NEW) public void reduceBalance(Long userId, Double price) { log.info(\u0026#34;=============ACCOUNT START=================\u0026#34;); log.info(\u0026#34;当前 XID: {}\u0026#34;, RootContext.getXID()); Account account = accountDao.selectById(userId); Double balance = account.getBalance(); log.info(\u0026#34;下单用户{}余额为 {},商品总价为{}\u0026#34;, userId, balance, price); if (balance \u0026lt; price) { log.warn(\u0026#34;用户 {} 余额不足，当前余额:{}\u0026#34;, userId, balance); throw new RuntimeException(\u0026#34;余额不足\u0026#34;); } log.info(\u0026#34;开始扣减用户 {} 余额\u0026#34;, userId); double currentBalance = account.getBalance() - price; account.setBalance(currentBalance); accountDao.updateById(account); log.info(\u0026#34;扣减用户 {} 余额成功,扣减后用户账户余额为{}\u0026#34;, userId, currentBalance); log.info(\u0026#34;=============ACCOUNT END=================\u0026#34;); } } 测试 自行编写接口测试，注意观察运行日志，至此分布式事务集成案例全流程完毕。\n事务常见问题 建议先阅读基础知识。\n核心知识： spring原生事务会保证在事务下整个线程后续拿到的都是同一个connection。\n核心知识： spring原生事务会保证在事务下整个线程后续拿到的都是同一个connection。\n核心知识： spring原生事务会保证在事务下整个线程后续拿到的都是同一个connection。\n原生Spring中@Transational能和@DS一起使用吗？ public class AService { @DS(\u0026#34;a\u0026#34;) @Transational public void dosomething(){ // some code } } 可以的，其会先切换使用数据源a再开启事务，整个原生事务内部不管是注解切换还是手动调用代码切换都不能切换，会一直使用a数据源。\n所以确认整个事务下不再切换其他数据源，用原生 @Transational 是建议的，毕竟其更完善。\n本地事务和Spring原生事务不能混用是什么意思？ 场景一：先使用的Spring@Transational 内部方法调用了本地@DSTransactional。\npublic class AService { @DS(\u0026#34;a\u0026#34;) @Transational public void dosomething(){ Bservice.dosomething(); // B是另外数据源，然后注解了@DS(\u0026#34;b\u0026#34;)和@DSTransactional Cservice.dosomething(); // C是另外数据源，然后注解了@DS(\u0026#34;c\u0026#34;)和@DSTransactional } } 基于核心知识： 事务下都是a数据源，内部无论做什么都改变不了使用a数据源。\n场景二： 先使用的本地@DSTransactional内部方法调用了Spring@Transational 。\npublic class AService { @DS(\u0026#34;a\u0026#34;) @DSTransactional public void dosomething(){ Amapper.updateSomeThing(); Bservice.dosomething(); // B是另外数据源，然后注解了@DS(\u0026#34;b\u0026#34;)和@Transational Cservice.dosomething(); // C是另外数据源，然后注解了@DS(\u0026#34;c\u0026#34;)和@Transational } } B和C都是独立的事务。C发生错误B会回滚吗？不会B已经提交了。A会回滚吗？会。\n不建议混用，除非你确实非常理解事务，能随心所欲掌握你代码的执行流程。\n本地事务标准使用 public class AService { @DS(\u0026#34;a\u0026#34;) @DSTransactional // 最外层开启即可 public void dosomething(){ Amapper.updateSomeThing(); Bservice.dosomething(); // B是另外数据源，然后注解了@DS(\u0026#34;b\u0026#34;) Cservice.dosomething(); // C是另外数据源，然后注解了@DS(\u0026#34;c\u0026#34;) } } 调试源码 1、开启动态数据源的debug日志。\nlogging: level: com.baomidou.dynamic: debug 检查日志输出是否正确。\n2、断点调试DynamicDataSourceAnnotationInterceptor。\npublic class DynamicDataSourceAnnotationInterceptor implements MethodInterceptor { private static final String DYNAMIC_PREFIX = \u0026#34;#\u0026#34;; private final DataSourceClassResolver dataSourceClassResolver; private final DsProcessor dsProcessor; public DynamicDataSourceAnnotationInterceptor(Boolean allowedPublicOnly, DsProcessor dsProcessor) { dataSourceClassResolver = new DataSourceClassResolver(allowedPublicOnly); this.dsProcessor = dsProcessor; } @Override public Object invoke(MethodInvocation invocation) throws Throwable { try { // 这里把获取到的数据源标识如master存入本地线程 String dsKey = determineDatasourceKey(invocation); ● DynamicDataSourceContextHolder.push(dsKey); return invocation.proceed(); } finally { DynamicDataSourceContextHolder.poll(); } } private String determineDatasourceKey(MethodInvocation invocation) { String key = dataSourceClassResolver.findDSKey(invocation.getMethod(), invocation.getThis()); return (!key.isEmpty() \u0026amp;\u0026amp; key.startsWith(DYNAMIC_PREFIX)) ? dsProcessor.determineDatasource(invocation, key) : key; } } 3、断点调试DynamicRoutingDataSource。\npublic class DynamicRoutingDataSource extends AbstractRoutingDataSource { private Map\u0026lt;String, DataSource\u0026gt; dataSourceMap = new LinkedHashMap\u0026lt;\u0026gt;(); private Map\u0026lt;String, DynamicGroupDataSource\u0026gt; groupDataSources = new ConcurrentHashMap\u0026lt;\u0026gt;(); @Override public DataSource determineDataSource() { // 从本地线程获取key解析最终真实的数据源 ● String dsKey = DynamicDataSourceContextHolder.peek(); return getDataSource(dsKey); } private DataSource determinePrimaryDataSource() { log.debug(\u0026#34;从默认数据源中返回数据\u0026#34;); return groupDataSources.containsKey(primary) ? groupDataSources.get(primary).determineDataSource() : dataSourceMap.get(primary); } public DataSource getDataSource(String ds) { if (StringUtils.isEmpty(ds)) { return determinePrimaryDataSource(); } else if (!groupDataSources.isEmpty() \u0026amp;\u0026amp; groupDataSources.containsKey(ds)) { log.debug(\u0026#34;从 {} 组数据源中返回数据源\u0026#34;, ds); return groupDataSources.get(ds).determineDataSource(); } else if (dataSourceMap.containsKey(ds)) { log.debug(\u0026#34;从 {} 单数据源中返回数据源\u0026#34;, ds); return dataSourceMap.get(ds); } return determinePrimaryDataSource(); } } 常见问题之-切换数据源失败 开启了spring的事务 原因： spring开启事务后会维护一个ConnectionHolder，保证在整个事务下，都是用同一个数据库连接。\n请检查整个调用链路涉及的类的方法和类本身还有继承的抽象类上是否有@Transactional注解。\n如强烈需要事务保证多个库同时执行成功或者失败，请查看事务专栏的解决办法。\n方法内部调用 查看以下示例\n外部调用 userservice.test1() 能在执行到 test2() 切换到second数据源吗？\npublic UserService { @DS(\u0026#34;first\u0026#34;) public void test1() { // do something test2(); } @DS(\u0026#34;second\u0026#34;) public void test2() { // do something } } 答案：！！！不能不能不能！！！数据源核心原理是基于aop代理实现切换，内部方法调用不会使用aop。\n解决方法:\n把test2()方法提到另外一个service，单独调用。\nPostConstruct初始化顺序 初始化包括: @PostConstruct 注解, InitializingBean接口, 自定义init-method\n@Component public class MyConfiguration { @Resource private UserMapper userMapper; @DS(\u0026#34;slave\u0026#34;) @PostConstruct public void init(){ // 无法选择正确的数据源 userMapper.selectById(1); } } 解决方法：监听容器启动完成事件, 在容器完成后做初始化。\n@Component public class MyConfiguration { @DS(\u0026#34;slave\u0026#34;) @EventListener public void onApplicationEvent(ContextRefreshedEvent event) { // 成功选择正确的数据源 userMapper.selectById(1); } } 相关spring源码 : org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#initializeBean\n在初始化完成后, bean 进入增强阶段, 所以这个阶段的任何AOP都是无效的。\nDruid版本过低 请升级druid1.1.22及以上版本，这个版本修复了在高并发下偶发的切换失效问题。\n@Async或者java8的ParallelStream并行流之类方法 这种情况都是新开了线程去异步处理，不受当前线程管控了。\n可以在新开的方法上加对应的DS注解解决。\n知识库 如何注入多数据源？ public class A{ @Autowired private DataSource dataSource; public void dosomething{ // 使用的时候需要强转 DynamicRoutingDataSource ds = (DynamicRoutingDataSource) dataSource; } } 如何获取当前线程数据源名称？ DynamicDataSourceContextHolder.peek() 如何获取当前线程数据源？ public void dosomething{ DynamicRoutingDataSource ds = (DynamicRoutingDataSource) dataSource; DataSource datasource=ds.determineDataSource(); } 本文参考至：https://www.xiaojingge.com/archives/ef008289-8ab8-485c-8019-2703267c7beb\n","permalink":"https://lesanouo.github.io/blog/posts/code/174974400001/","summary":"\u003cp\u003e本文为 \u003ccode\u003edynamic-datasource-spring-boot-starter\u003c/code\u003e （基于SpringBoot的快速集成多数据源框架）的使用文档。\u003c/p\u003e\n\u003ch1 id=\"特性\"\u003e特性\u003c/h1\u003e\n\u003col\u003e\n\u003cli\u003e支持 \u003ccode\u003e数据源分组\u003c/code\u003e ，适用于多种场景，纯粹多库、读写分离、一主多从、混合模式。\u003c/li\u003e\n\u003cli\u003e支持数据库敏感配置信息 \u003ccode\u003e加密(可自定义)\u003c/code\u003e ENC()。\u003c/li\u003e\n\u003cli\u003e支持每个数据库独立初始化表结构schema和数据库database。\u003c/li\u003e\n\u003cli\u003e支持无数据源启动，支持 \u003ccode\u003e懒加载数据源\u003c/code\u003e （需要的时候再创建连接）。\u003c/li\u003e\n\u003cli\u003e支持 \u003ccode\u003e自定义注解\u003c/code\u003e ，需继承DS(3.2.0+)。\u003c/li\u003e\n\u003cli\u003e提供并简化对Druid，HikariCp，BeeCp，Dbcp2的快速集成。\u003c/li\u003e\n\u003cli\u003e提供对 \u003ccode\u003eMybatis-Plus\u003c/code\u003e ，Quartz，ShardingJdbc，P6sy，Jndi等组件的集成方案。\u003c/li\u003e\n\u003cli\u003e提供 \u003ccode\u003e自定义数据源来源\u003c/code\u003e 方案（如全从数据库加载）。\u003c/li\u003e\n\u003cli\u003e提供项目启动后 \u003ccode\u003e动态增加移除数据源\u003c/code\u003e 方案。\u003c/li\u003e\n\u003cli\u003e提供Mybatis环境下的 \u003ccode\u003e纯读写分离\u003c/code\u003e 方案。\u003c/li\u003e\n\u003cli\u003e提供使用 \u003ccode\u003espel动态参数\u003c/code\u003e 解析数据源方案。内置spel，session，header，支持自定义。\u003c/li\u003e\n\u003cli\u003e支持 \u003ccode\u003e多层数据源嵌套切换\u003c/code\u003e 。（ServiceA \u0026raquo;\u0026gt; ServiceB \u0026raquo;\u0026gt; ServiceC）。\u003c/li\u003e\n\u003cli\u003e提供 \u003ccode\u003e基于seata的分布式事务方案\u003c/code\u003e 。\u003c/li\u003e\n\u003cli\u003e提供 \u003ccode\u003e本地多数据源事务方案\u003c/code\u003e 。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"约定\"\u003e约定\u003c/h1\u003e\n\u003col\u003e\n\u003cli\u003edynamic-datasource只做 \u003ccode\u003e切换数据源\u003c/code\u003e 这件核心的事情，并 \u003ccode\u003e不限制你的具体操作\u003c/code\u003e ，切换了数据源可以做任何CRUD。\u003c/li\u003e\n\u003cli\u003e配置文件所有以下划线 \u003ccode\u003e_\u003c/code\u003e 分割的数据源 \u003ccode\u003e首部\u003c/code\u003e 即为组的名称，相同组名称的数据源会放在一个组下。\u003c/li\u003e\n\u003cli\u003e切换数据源可以是组名，也可以是具体数据源名称。 \u003ccode\u003e组名则切换时采用负载均衡算法切换\u003c/code\u003e 。\u003c/li\u003e\n\u003cli\u003e默认的数据源名称为 \u003ccode\u003emaster\u003c/code\u003e ，你可以通过 \u003ccode\u003espring.datasource.dynamic.primary\u003c/code\u003e 修改。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e方法上的注解优先于类上注解\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003eDS支持继承抽象类上的DS，暂不支持继承接口上的DS。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"使用方法\"\u003e使用方法\u003c/h1\u003e\n\u003col\u003e\n\u003cli\u003e引入dynamic-datasource-spring-boot-starter\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003espring-boot 1.5.x、2.x.x\u003c/p\u003e","title":"dynamic-datasource文档"},{"content":"创建用户 命令 CREATE USER \u0026#39;username\u0026#39;@\u0026#39;host\u0026#39; IDENTIFIED BY \u0026#39;password\u0026#39;; 说明 username：你将创建的用户名 host：指定该用户在哪个主机上可以登陆，如果是本地用户可用localhost，如果想让该用户可以从任意远程主机登陆，可以使用通配符 % password：该用户的登陆密码，密码可以为空，如果为空则该用户可以不需要密码登陆服务器 例子 CREATE USER \u0026#39;dog\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED BY \u0026#39;123456\u0026#39;; CREATE USER \u0026#39;pig\u0026#39;@\u0026#39;192.168.1.101\u0026#39; IDENDIFIED BY \u0026#39;123456\u0026#39;; CREATE USER \u0026#39;pig\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED BY \u0026#39;123456\u0026#39;; CREATE USER \u0026#39;pig\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED BY \u0026#39;\u0026#39;; CREATE USER \u0026#39;pig\u0026#39;@\u0026#39;%\u0026#39;; 授权 命令 GRANT privileges ON databasename.tablename TO \u0026#39;username\u0026#39;@\u0026#39;host\u0026#39; 说明 privileges：用户的操作权限，如SELECT，INSERT，UPDATE等，如果要授予所的权限则使用ALL databasename：数据库名 tablename：表名，如果要授予该用户对所有数据库和表的相应操作权限则可用*表示，如*.* 设置与更改用户密码 命令 SET PASSWORD FOR \u0026#39;username\u0026#39;@\u0026#39;host\u0026#39; = PASSWORD(\u0026#39;newpassword\u0026#39;); 如果是当前登陆用户用:\nSET PASSWORD = PASSWORD(\u0026#34;newpassword\u0026#34;); 例子 SET PASSWORD FOR \u0026#39;pig\u0026#39;@\u0026#39;%\u0026#39; = PASSWORD(\u0026#34;123456\u0026#34;); 撤销用户权限 命令 REVOKE privilege ON databasename.tablename FROM \u0026#39;username\u0026#39;@\u0026#39;host\u0026#39;; 说明 privilege, databasename, tablename：同授权部分\n例子 REVOKE SELECT ON *.* FROM \u0026#39;pig\u0026#39;@\u0026#39;%\u0026#39;; 注意 假如你在给用户'pig'@'%'授权的时候是这样的（或类似的）：GRANT SELECT ON test.user TO 'pig'@'%'，则在使用REVOKE SELECT ON *.* FROM 'pig'@'%';命令并不能撤销该用户对test数据库中user表的SELECT 操作。相反，如果授权使用的是GRANT SELECT ON *.* TO 'pig'@'%';则REVOKE SELECT ON test.user FROM 'pig'@'%';命令也不能撤销该用户对test数据库中user表的Select权限。\n具体信息可以用命令SHOW GRANTS FOR 'pig'@'%'; 查看。\n删除用户 命令 DROP USER \u0026#39;username\u0026#39;@\u0026#39;host\u0026#39;; ","permalink":"https://lesanouo.github.io/blog/posts/code/174931200001/","summary":"\u003ch2 id=\"创建用户\"\u003e创建用户\u003c/h2\u003e\n\u003ch3 id=\"命令\"\u003e命令\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sql\" data-lang=\"sql\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eCREATE\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eUSER\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;username\u0026#39;\u003c/span\u003e\u003cspan class=\"o\"\u003e@\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;host\u0026#39;\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eIDENTIFIED\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eBY\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;password\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"说明\"\u003e说明\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eusername：你将创建的用户名\u003c/li\u003e\n\u003cli\u003ehost：指定该用户在哪个主机上可以登陆，如果是本地用户可用\u003ccode\u003elocalhost\u003c/code\u003e，如果想让该用户可以从任意远程主机登陆，可以使用通配符 \u003ccode\u003e%\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003epassword：该用户的登陆密码，密码可以为空，如果为空则该用户可以不需要密码登陆服务器\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"例子\"\u003e例子\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sql\" data-lang=\"sql\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eCREATE\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eUSER\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;dog\u0026#39;\u003c/span\u003e\u003cspan class=\"o\"\u003e@\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;localhost\u0026#39;\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eIDENTIFIED\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eBY\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;123456\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eCREATE\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eUSER\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;pig\u0026#39;\u003c/span\u003e\u003cspan class=\"o\"\u003e@\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;192.168.1.101\u0026#39;\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eIDENDIFIED\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eBY\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;123456\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eCREATE\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eUSER\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;pig\u0026#39;\u003c/span\u003e\u003cspan class=\"o\"\u003e@\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;%\u0026#39;\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eIDENTIFIED\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eBY\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;123456\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eCREATE\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eUSER\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;pig\u0026#39;\u003c/span\u003e\u003cspan class=\"o\"\u003e@\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;%\u0026#39;\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eIDENTIFIED\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eBY\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eCREATE\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eUSER\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;pig\u0026#39;\u003c/span\u003e\u003cspan class=\"o\"\u003e@\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;%\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"授权\"\u003e授权\u003c/h2\u003e\n\u003ch3 id=\"命令-1\"\u003e命令\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sql\" data-lang=\"sql\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eGRANT\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eprivileges\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eON\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003edatabasename\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003etablename\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eTO\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;username\u0026#39;\u003c/span\u003e\u003cspan class=\"o\"\u003e@\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;host\u0026#39;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"说明-1\"\u003e说明\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eprivileges：用户的操作权限，如\u003ccode\u003eSELECT\u003c/code\u003e，\u003ccode\u003eINSERT\u003c/code\u003e，\u003ccode\u003eUPDATE\u003c/code\u003e等，如果要授予所的权限则使用\u003ccode\u003eALL\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003edatabasename：数据库名\u003c/li\u003e\n\u003cli\u003etablename：表名，如果要授予该用户对所有数据库和表的相应操作权限则可用\u003ccode\u003e*\u003c/code\u003e表示，如\u003ccode\u003e*.*\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"设置与更改用户密码\"\u003e设置与更改用户密码\u003c/h2\u003e\n\u003ch3 id=\"命令-2\"\u003e命令\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sql\" data-lang=\"sql\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eSET\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ePASSWORD\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eFOR\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;username\u0026#39;\u003c/span\u003e\u003cspan class=\"o\"\u003e@\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;host\u0026#39;\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ePASSWORD\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;newpassword\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e如果是当前登陆用户用:\u003c/p\u003e","title":"MySQL创建用户与授权"},{"content":"Vue官方构建工具 npm init vue@latest 用ref()定义响应式变量 const count = ref(0) count.value++ 计算属性 计算属性值会基于其响应式依赖被缓存、不要在计算函数中做异步请求或者更改 DOM、避免直接修改计算属性值\nconst publishedBooksMessage = computed(() =\u0026gt; { return author.books.length \u0026gt; 0 ? \u0026#39;Yes\u0026#39; : \u0026#39;No\u0026#39; }) // {{ publishedBooksMessage }} Class 与 Style 绑定 Class绑定：\u0026lt;MyComponent :class=\u0026quot;{ active: isActive }\u0026quot; /\u0026gt;\nStyle绑定：\u0026lt;div :style=\u0026quot;{ color: activeColor, fontSize: fontSize + 'px' }\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\n侦听器 watch 的第一个参数可以是不同形式的“数据源”：它可以是一个 ref (包括计算属性)、一个响应式对象、一个 getter 函数、或多个数据源组成的数组：\nconst x = ref(0) const y = ref(0) // 单个 ref watch(x, (newX) =\u0026gt; { console.log(`x is ${newX}`) }) // getter 函数(当需要侦听响应式对象的属性时，需要使用getter函数：()=\u0026gt;obj.count) watch( () =\u0026gt; x.value + y.value, (sum) =\u0026gt; { console.log(`sum of x + y is: ${sum}`) } ) // 多个来源组成的数组 watch([x, () =\u0026gt; y.value], ([newX, newY]) =\u0026gt; { console.log(`x is ${newX} and y is ${newY}`) }) watchEffect()： watchEffect() 会立即执行一遍回调函数，如果这时函数产生了副作用，Vue 会自动追踪副作用的依赖关系，自动分析出响应源\nwatchEffect(async () =\u0026gt; { const response = await fetch(url.value) data.value = await response.json() }) Props const props = defineProps({ // 基础类型检查 // （给出 `null` 和 `undefined` 值则会跳过任何类型检查） propA: Number, // 多种可能的类型 propB: [String, Number], // 必传，且为 String 类型 propC: { type: String, required: true }, // Number 类型的默认值 propD: { type: Number, default: 100 }, // 对象类型的默认值 propE: { type: Object, // 对象或数组的默认值 // 必须从一个工厂函数返回。 // 该函数接收组件所接收到的原始 prop 作为参数。 default(rawProps) { return { message: \u0026#39;hello\u0026#39; } } }, // 自定义类型校验函数 propF: { validator(value) { // The value must match one of these strings return [\u0026#39;success\u0026#39;, \u0026#39;warning\u0026#39;, \u0026#39;danger\u0026#39;].includes(value) } }, // 函数类型的默认值 propG: { type: Function, // 不像对象或数组的默认，这不是一个工厂函数。这会是一个用来作为默认值的函数 default() { return \u0026#39;Default function\u0026#39; } } }) console.log(props.foo) 事件 const emit = defineEmits([\u0026#39;inFocus\u0026#39;, \u0026#39;submit\u0026#39;]) function buttonClick() { emit(\u0026#39;submit\u0026#39;) } 插槽 // 使用组件 \u0026lt;FancyList :api-url=\u0026#34;url\u0026#34; :per-page=\u0026#34;10\u0026#34;\u0026gt; \u0026lt;template #item=\u0026#34;{ body, username, likes }\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{{ body }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;by {{ username }} | {{ likes }} likes\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/FancyList\u0026gt; // 组件定义 \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;item in items\u0026#34;\u0026gt; \u0026lt;slot name=\u0026#34;item\u0026#34; v-bind=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; ","permalink":"https://lesanouo.github.io/blog/posts/snippet/vue3/","summary":"\u003ch2 id=\"vue官方构建工具-npm-init-vuelatest\"\u003eVue官方构建工具 \u003ccode\u003enpm init vue@latest\u003c/code\u003e\u003c/h2\u003e\n\u003ch2 id=\"用ref定义响应式变量\"\u003e用ref()定义响应式变量\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kr\"\u003econst\u003c/span\u003e \u003cspan class=\"nx\"\u003ecount\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003eref\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nx\"\u003ecount\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003evalue\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"计算属性\"\u003e计算属性\u003c/h2\u003e\n\u003cp\u003e计算属性值会基于其响应式依赖被缓存、不要在计算函数中做异步请求或者更改 DOM、避免直接修改计算属性值\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kr\"\u003econst\u003c/span\u003e \u003cspan class=\"nx\"\u003epublishedBooksMessage\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003ecomputed\u003c/span\u003e\u003cspan class=\"p\"\u003e(()\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"nx\"\u003eauthor\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003ebooks\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003elength\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e \u003cspan class=\"o\"\u003e?\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;Yes\u0026#39;\u003c/span\u003e \u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;No\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e})\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// {{ publishedBooksMessage }}\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"class-与-style-绑定\"\u003eClass 与 Style 绑定\u003c/h2\u003e\n\u003cp\u003eClass绑定：\u003ccode\u003e\u0026lt;MyComponent :class=\u0026quot;{ active: isActive }\u0026quot; /\u0026gt;\u003c/code\u003e\u003c/p\u003e","title":"Vue3 代码片段"},{"content":"本片文章记录在Linux（CentOS7）中如何使用systemctl命令进行系统和服务管理\nsystemctl命令 # 设置开机自启动，可在任意目录下执行 systemctl enable xxx.service # 启动nginx服务 systemctl start xxx.service # 停止开机自启动 systemctl disable xxx.service # 查看服务当前状态 systemctl status xxx.service # 重新启动服务 systemctl restart xxx.service # 查看所有已启动的服务 systemctl list-units --type=service 创建xxx.service 在/etc/systemd/system/路径下，新增一个myTest.service文件，文件内容如下\n# Unit 文件描述\r[Unit]\rDescription=myTest service\r# Service 配置参数\r[Service]\rType=simple\rGuessMainPID=true\r# 自启动项目所在的位置路径\rWorkingDirectory=/root/myTestWeb\rStandardOutput=journal\rStandardError=journal\r# 自启动项目的命令，这里用了dotnet启动，所以前面添加了dotnet的路径/usr/bin/\rExecStart=/usr/bin/dotnet myTest.dll --Urls=http://*:端口号\rRestart=always\rRestartSec=10\r[Install]\rWantedBy=multi-user.target 设置开机自启动myTest.service systemctl enable myTest.service 开启服务，查看状态 systemctl start myTest.service\rsystemctl status myTest.service ","permalink":"https://lesanouo.github.io/blog/posts/code/171423360001/","summary":"\u003cp\u003e本片文章记录在Linux（CentOS7）中如何使用\u003ccode\u003esystemctl\u003c/code\u003e命令进行系统和服务管理\u003c/p\u003e\n\u003ch2 id=\"systemctl命令\"\u003e\u003ccode\u003esystemctl\u003c/code\u003e命令\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 设置开机自启动，可在任意目录下执行\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esystemctl \u003cspan class=\"nb\"\u003eenable\u003c/span\u003e xxx.service\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 启动nginx服务\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esystemctl start xxx.service\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 停止开机自启动\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esystemctl disable xxx.service\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 查看服务当前状态\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esystemctl status xxx.service\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 重新启动服务\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esystemctl restart xxx.service\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 查看所有已启动的服务\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esystemctl list-units --type\u003cspan class=\"o\"\u003e=\u003c/span\u003eservice\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"创建xxxservice\"\u003e创建xxx.service\u003c/h2\u003e\n\u003cp\u003e在\u003ccode\u003e/etc/systemd/system/\u003c/code\u003e路径下，新增一个\u003ccode\u003emyTest.service\u003c/code\u003e文件，文件内容如下\u003c/p\u003e","title":"Linux系统使用systemd配置.NET项目开机自启动"},{"content":"前言 使用 Git 作为代码版本管理，早已是现在开发工程师必备的技能。可大多数工程师还是只会最基本的保存、拉取、推送，遇到一些commit管理的问题就束手无策，或者用一些不优雅的方式解决。\n本文分享我在开发工作中实践过的实用命令。这些都能够大大提高工作效率，还能解决不少疑难场景。下面会介绍命令，列出应用场景，手把手教学使用，让大家看完即学会。\nstash 描述 官方解释：当您想记录工作目录和索引的当前状态，但又想返回一个干净的工作目录时，请使用git stash。该命令将保存本地修改，并恢复工作目录以匹配头部提交。\nstash 命令能够将还未 commit 的代码存起来，让你的工作目录变得干净。\n应用场景 我猜你心里一定在想：为什么要变干净？\n应用场景：某一天你正在 feature 分支开发新需求，突然产品经理跑过来说线上有bug，必须马上修复。而此时你的功能开发到一半，于是你急忙想切到 master 分支，然后你就会看到报错：Please commit your change or stash them before you switch branches.\n因为当前有文件更改了，需要提交commit保持工作区干净才能切分支。由于情况紧急，你只有急忙 commit 上去，commit 信息也随便写了个“暂存代码”，于是该分支提交记录就留了一条黑历史\n命令使用 如果你学会 stash，就不用那么狼狈了。你只需要：git stash\n就这么简单，代码就被存起来了。\n当你修复完线上问题，切回 feature 分支，想恢复代码也只需要：git stash apply\n相关命令\n# 保存当前未commit的代码\rgit stash\r# 保存当前未commit的代码并添加备注\rgit stash save \u0026#34;备注的内容\u0026#34;\r# 列出stash的所有记录\rgit stash list\r# 删除stash的所有记录\rgit stash clear\r# 应用最近一次的stash\rgit stash apply\r# 应用最近一次的stash，随后删除该记录\rgit stash pop\r# 删除最近的一次stash\rgit stash drop 当有多条 stash，可以指定操作stash，首先使用stash list 列出所有记录：\n$ git stash list\rstash@{0}: WIP on ...\rstash@{1}: WIP on ...\rstash@{2}: On ... 应用第二条记录：\n$ git stash apply stash@{1} pop，drop 同理。\nreset \u0026ndash;soft 描述 完全不接触索引文件或工作树（但会像所有模式一样，将头部重置为）。这使您的所有更改的文件更改为“要提交的更改”。\n回退你已提交的 commit，并将 commit 的修改内容放回到暂存区。\n一般我们在使用 reset 命令时，git reset \u0026ndash;hard会被提及的比较多，它能让 commit 记录强制回溯到某一个节点。而git reset \u0026ndash;soft的作用正如其名，\u0026ndash;soft(柔软的) 除了回溯节点外，还会保留节点的修改内容。\n应用场景 回溯节点，为什么要保留修改内容？\n应用场景1：有时候手滑不小心把不该提交的内容 commit 了，这时想改回来，只能再 commit 一次，又多一条“黑历史”。\n应用场景2：规范些的团队，一般对于 commit 的内容要求职责明确，颗粒度要细，便于后续出现问题排查。本来属于两块不同功能的修改，一起 commit 上去，这种就属于不规范。这次恰好又手滑了，一次性 commit 上去。\n命令使用 学会reset \u0026ndash;soft之后，你只需要：\n# 恢复最近一次 commit\rgit reset --soft HEAD^ reset \u0026ndash;soft相当于后悔药，给你重新改过的机会。对于上面的场景，就可以再次修改重新提交，保持干净的 commit 记录。\n以上说的是还未 push 的commit。对于已经 push 的 commit，也可以使用该命令，不过再次 push 时，由于远程分支和本地分支有差异，需要强制推送git push -f来覆盖被 reset 的 commit。\n还有一点需要注意，在reset \u0026ndash;soft指定 commit 号时，会将该 commit 到最近一次 commit 的所有修改内容全部恢复，而不是只针对该 commit。\n举个例子：\ncommit 记录有 c、b、a。\nreset 到 a。\ngit reset --soft 1a900ac29eba73ce817bf959f82ffcb0bfa38f75\n此时的 HEAD 到了 a，而 b、c 的修改内容都回到了暂存区。\ncherry-pick 描述 给定一个或多个现有提交，应用每个提交引入的更改，为每个提交记录一个新的提交。这需要您的工作树清洁（没有从头提交的修改）。\n将已经提交的 commit，复制出新的 commit 应用到分支里\n应用场景 commit 都提交了，为什么还要复制新的出来？\n应用场景1：有时候版本的一些优化需求开发到一半，可能其中某一个开发完的需求要临时上，或者某些原因导致待开发的需求卡住了已开发完成的需求上线。这时候就需要把 commit 抽出来，单独处理。\n应用场景2：有时候开发分支中的代码记录被污染了，导致开发分支合到线上分支有问题，这时就需要拉一条干净的开发分支，再从旧的开发分支中，把 commit 复制到新分支。\n命令使用 复制单个 需要把 b 复制到另一个分支，首先把 commitHash 复制下来，然后切到 master 分支。\n当前 master 最新的记录是 a，使用cherry-pick把 b 应用到当前分支。\ngit cherry-pick 1a900ac29eba73ce817bf959f82ffcb0bfa38f75\n完成后看下最新的 log，b 已经应用到 master，作为最新的 commit 了。可以看到 commitHash 和之前的不一样，但是提交时间还是保留之前的。\n复制多个 以上是单个 commit 的复制，下面再来看看 cherry-pick 多个 commit 要如何操作。\n一次转移多个提交：\ngit cherry-pick commit1 commit2\n上面的命令将 commit1 和 commit2 两个提交应用到当前分支。\n多个连续的commit，也可区间复制：\ngit cherry-pick commit1^..commit2\n上面的命令将 commit1 到 commit2 这个区间的 commit 都应用到当前分支（包含commit1、commit2），commit1 是最早的提交。\ncherry-pick 代码冲突 在cherry-pick多个commit时，可能会遇到代码冲突，这时cherry-pick会停下来，让用户决定如何继续操作。下面看看怎么解决这种场景。\n还是 feature 分支，现在需要把 c、d、e 都复制到 master 分支上。先把起点c和终点e的 commitHash 记下来。\n切到 master 分支，使用区间的cherry-pick。可以看到 c 被成功复制，当进行到 d 时，发现代码冲突，cherry-pick中断了。这时需要解决代码冲突，重新提交到暂存区。\n然后使用cherry-pick \u0026ndash;continue让cherry-pick继续进行下去。最后 e 也被复制进来，整个流程就完成了。\n以上是完整的流程，但有时候可能需要在代码冲突后，放弃或者退出流程：\n放弃 cherry-pick：\ngit cherry-pick --abort\n回到操作前的样子，就像什么都没发生过。\n退出 cherry-pick：\ngit cherry-pick --quit\n不回到操作前的样子。即保留已经cherry-pick成功的 commit，并退出cherry-pick流程。\nrevert 描述 给定一个或多个现有提交，恢复相关提交引入的更改，并记录一些这些更改的新提交。这就要求你的工作树是干净的（没有来自头部的修改）。\n将现有的提交还原，恢复提交的内容，并生成一条还原记录。\n应用场景 应用场景：有一天测试突然跟你说，你开发上线的功能有问题，需要马上撤回，否则会影响到系统使用。这时可能会想到用 reset 回退，可是你看了看分支上最新的提交还有其他同事的代码，用 reset 会把这部分代码也撤回了。由于情况紧急，又想不到好方法，还是任性的使用 reset，然后再让同事把他的代码合一遍（同事听到想打人），于是你的技术形象在同事眼里一落千丈。\n命令使用 revert 普通提交 学会 revert 之后，立马就可以拯救这种尴尬的情况。\ngit revert 21dcd937fe555f58841b17466a99118deb489212\nrevert 掉自己提交的 commit。\n因为 revert 会生成一条新的提交记录，这时会让你编辑提交信息，编辑完后 :wq 保存退出就好了。\n再来看下最新的 log，生成了一条 revert 记录，虽然自己之前的提交记录还是会保留着，但你修改的代码内容已经被撤回了。\nrevert 合并提交 在 git 的 commit 记录里，还有一种类型是合并提交，想要 revert 合并提交，使用上会有些不一样。\n现在的 master 分支里多了条合并提交。\n使用刚刚同样的 revert 方法，会发现命令行报错了。为什么会这样？在官方文档中有解释。\n通常无法 revert 合并，因为您不知道合并的哪一侧应被视为主线。此选项指定主线的父编号（从1开始），并允许 revert 反转相对于指定父编号的更改\n我的理解是因为合并提交是两条分支的交集节点，而 git 不知道需要撤销的哪一条分支，需要添加参数 -m 指定主线分支，保留主线分支的代码，另一条则被撤销。\n-m 后面要跟一个 parent number 标识出\u0026quot;主线\u0026quot;，一般使用 1 保留主分支代码。\ngit revert -m 1 \u0026lt;commitHash\u0026gt;\nrevert 合并提交后，再次合并分支会失效 还是上面的场景，在 master 分支 revert 合并提交后，然后切到 feature 分支修复好 bug，再合并到 master 分支时，会发现之前被 revert 的修改内容没有重新合并进来。\n因为使用 revert 后， feature 分支的 commit 还是会保留在 master 分支的记录中，当你再次合并进去时，git 判断有相同的 commitHash，就忽略了相关 commit 修改的内容。\n这时就需要 revert 掉之前 revert 的合并提交，有点拗口，接下来看操作吧。\n现在 master 的记录是这样的。\n再次使用 revert，之前被 revert 的修改内容就又回来了。\nreflog 描述 此命令管理重录中记录的信息。\n如果说reset \u0026ndash;soft是后悔药，那 reflog 就是强力后悔药。它记录了所有的 commit 操作记录，便于错误操作后找回记录。\n应用场景 应用场景：某天你眼花，发现自己在其他人分支提交了代码还推到远程分支，这时因为分支只有你的最新提交，就想着使用reset \u0026ndash;hard，结果紧张不小心记错了 commitHash，reset 过头，把同事的 commit 搞没了。没办法，reset \u0026ndash;hard是强制回退的，找不到 commitHash 了，只能让同事从本地分支再推一次（同事瞬间拳头就硬了，怎么又是你）。于是，你的技术形象又一落千丈。\n命令使用 分支记录如上，想要 reset 到 b。\n误操作 reset 过头，b 没了，最新的只剩下 a。\n这时用git reflog查看历史记录，把错误提交的那次 commitHash 记下。\n再次 reset 回去，就会发现 b 回来了。\n总结 本文主要分享了5个在开发中实用的 Git 命令和设置短命令的方式。\nstash：存储临时代码。 reset \u0026ndash;soft：软回溯，回退 commit 的同时保留修改内容。 cherry-pick：复制 commit。 revert：撤销 commit 的修改内容。 reflog：记录了 commit 的历史操作。 ","permalink":"https://lesanouo.github.io/blog/posts/code/170196480001/","summary":"\u003ch2 id=\"前言\"\u003e前言\u003c/h2\u003e\n\u003cp\u003e使用 Git 作为代码版本管理，早已是现在开发工程师必备的技能。可大多数工程师还是只会最基本的保存、拉取、推送，遇到一些commit管理的问题就束手无策，或者用一些不优雅的方式解决。\u003c/p\u003e","title":"Git中提高效率的5条命令"},{"content":"什么是策略模式 策略模式，应该是工作中比较常用的设计模式，调用方自己选择用哪一种策略完成对数据的操作，也就是“一个类的行为或其算法可以在运行时更改”，将一些除了过程不同其他都一样的函数封装成策略，然后调用方自己去选择想让数据执行什么过程策略。常见的例子为根据用户分类推荐不同的排行榜（用户关注点不一样，推荐榜单就不一样）\n和单例模式一样，随着时间发展，不再推荐经典策略模式，更推荐简单策略用枚举策略模式，复杂地用工厂策略模式。下面引入一个例子，我们的需求是：对一份股票数据列表，给出低价榜、高价榜、涨幅榜。这其中只有排序条件的区别，比较适合作为策略模式的例子\n经典策略模式 数据DTO\n@Data public class Stock { // 股票交易代码 private String code; // 现价 private Double price; // 涨幅 private Double rise; } 抽象得到的策略接口\npublic interface Strategy { /** * 将股票列表排序 * * @param source 源数据 * @return 排序后的榜单 */ List\u0026lt;Stock\u0026gt; sort(List\u0026lt;Stock\u0026gt; source); } 实现我们的策略类\n/** * 高价榜 */ public class HighPriceRank implements Strategy { @Override public List\u0026lt;Stock\u0026gt; sort(List\u0026lt;Stock\u0026gt; source) { return source.stream() .sorted(Comparator.comparing(Stock::getPrice).reversed()) .collect(Collectors.toList()); } } /** * 低价榜 */ public class LowPriceRank implements Strategy { @Override public List\u0026lt;Stock\u0026gt; sort(List\u0026lt;Stock\u0026gt; source) { return source.stream() .sorted(Comparator.comparing(Stock::getPrice)) .collect(Collectors.toList()); } } /** * 高涨幅榜 */ public class HighRiseRank implements Strategy { @Override public List\u0026lt;Stock\u0026gt; sort(List\u0026lt;Stock\u0026gt; source) { return source.stream() .sorted(Comparator.comparing(Stock::getRise).reversed()) .collect(Collectors.toList()); } } 经典的Context类\npublic class Context { private Strategy strategy; public void setStrategy(Strategy strategy) { this.strategy = strategy; } public List\u0026lt;Stock\u0026gt; getRank(List\u0026lt;Stock\u0026gt; source) { return strategy.sort(source); } } 于是 我们顺礼成章地得到调用类\u0026ndash;榜单实例 RankServiceImpl\n@Service public class RankServiceImpl { /** * dataService.getSource() 提供原始的股票数据 */ @Resource private DataService dataService; /** * 前端传入榜单类型, 返回排序完的榜单 * * @param rankType 榜单类型 * @return 榜单数据 */ public List\u0026lt;Stock\u0026gt; getRank(String rankType) { // 创建上下文 Context context = new Context(); // 这里选择策略 switch (rankType) { case \u0026#34;HighPrice\u0026#34;: context.setStrategy(new HighPriceRank()); break; case \u0026#34;LowPrice\u0026#34;: context.setStrategy(new LowPriceRank()); break; case \u0026#34;HighRise\u0026#34;: context.setStrategy(new HighRiseRank()); break; default: throw new IllegalArgumentException(\u0026#34;rankType not found\u0026#34;); } // 然后执行策略 return context.getRank(dataService.getSource()); } } 我们可以看到经典方法，创建了一个接口、三个策略类，还是比较啰嗦的。调用类的实现也待商榷，新增一个策略类还要修改榜单实例（可以用抽象工厂解决，但是复杂度又上升了）。加之我们有更好的选择，所以此处不再推荐经典策略模式。\n基于枚举的策略模式 这里对这种简单的策略，推荐用枚举进行优化。枚举的本质是创建了一些静态类的集合。\n我下面直接给出例子，大家可以直观感受一下\n枚举策略类\npublic enum RankEnum { // 以下三个为策略实例 HighPrice { @Override public List\u0026lt;Stock\u0026gt; sort(List\u0026lt;Stock\u0026gt; source) { return source.stream() .sorted(Comparator.comparing(Stock::getPrice).reversed()) .collect(Collectors.toList()); } }, LowPrice { @Override public List\u0026lt;Stock\u0026gt; sort(List\u0026lt;Stock\u0026gt; source) { return source.stream() .sorted(Comparator.comparing(Stock::getPrice)) .collect(Collectors.toList()); } }, HighRise { @Override public List\u0026lt;Stock\u0026gt; sort(List\u0026lt;Stock\u0026gt; source) { return source.stream() .sorted(Comparator.comparing(Stock::getRise).reversed()) .collect(Collectors.toList()); } }; // 这里定义了策略接口 public abstract List\u0026lt;Stock\u0026gt; sort(List\u0026lt;Stock\u0026gt; source); } 对应的调用类也得以优化，榜单实例 RankServiceImpl\n@Service public class RankServiceImpl { /** * dataService.getSource() 提供原始的股票数据 */ @Resource private DataService dataService; /** * 前端传入榜单类型, 返回排序完的榜单 * * @param rankType 榜单类型 形似 RankEnum.HighPrice.name() * @return 榜单数据 */ public List\u0026lt;Stock\u0026gt; getRank(String rankType) { // 获取策略，这里如果未匹配会抛 IllegalArgumentException异常 RankEnum rank = RankEnum.valueOf(rankType); // 然后执行策略 return rank.sort(dataService.getSource()); } } 可以看到，如果策略简单的话，基于枚举的策略模式优雅许多，调用方也做到了0修改，但正确地使用枚举策略模式需要额外考虑以下几点。\n枚举的策略类是公用且静态，这意味着这个策略过程不能引入非静态的部分，扩展性受限\n策略模式的目标之一，是优秀的扩展性和可维护性，最好能新增或修改某一策略类时，对其他类是无改动的。而枚举策略如果过多或者过程复杂，维护是比较困难的，可维护性受限\n基于工厂的策略模式 为了解决良好的扩展性和可维护性，我更推荐以下利用spring自带beanFactory的优势，实现一个基于工厂的策略模式。 策略类改动只是添加了@Service注解，并指定了Service的value属性\n/** * 高价榜 * 注意申明 Service.value = HighPrice,他是我们的key,下同 */ @Service(\u0026#34;HighPrice\u0026#34;) public class HighPriceRank implements Strategy { @Override public List\u0026lt;Stock\u0026gt; sort(List\u0026lt;Stock\u0026gt; source) { return source.stream() .sorted(Comparator.comparing(Stock::getPrice).reversed()) .collect(Collectors.toList()); } } /** * 低价榜 */ @Service(\u0026#34;LowPrice\u0026#34;) public class LowPriceRank implements Strategy { @Override public List\u0026lt;Stock\u0026gt; sort(List\u0026lt;Stock\u0026gt; source) { return source.stream() .sorted(Comparator.comparing(Stock::getPrice)) .collect(Collectors.toList()); } } /** * 高涨幅榜 */ @Service(\u0026#34;HighRise\u0026#34;) public class HighRiseRank implements Strategy { @Override public List\u0026lt;Stock\u0026gt; sort(List\u0026lt;Stock\u0026gt; source) { return source.stream() .sorted(Comparator.comparing(Stock::getRise).reversed()) .collect(Collectors.toList()); } } 调用类修改较大，接入借助spring工厂特性，完成策略类\n@Service public class RankServiceImpl { /** * dataService.getSource() 提供原始的股票数据 */ @Resource private DataService dataService; /** * 利用注解@Resource和@Autowired特性,直接获取所有策略类 * key = @Service的value */ @Resource private Map\u0026lt;String, Strategy\u0026gt; rankMap; /** * 前端传入榜单类型, 返回排序完的榜单 * * @param rankType 榜单类型 和Service注解的value属性一致 * @return 榜单数据 */ public List\u0026lt;Stock\u0026gt; getRank(String rankType) { // 判断策略是否存在 if (!rankMap.containsKey(rankType)) { throw new IllegalArgumentException(\u0026#34;rankType not found\u0026#34;); } // 获得策略实例 Strategy rank = rankMap.get(rankType); // 执行策略 return rank.sort(dataService.getSource()); } } 工厂策略模式会比枚举策略模式啰嗦，但也更加灵活、易扩展性和易维护。故简单策略推荐枚举策略模式，复杂策略才推荐工厂策略模式。\n","permalink":"https://lesanouo.github.io/blog/posts/code/170187840001/","summary":"\u003ch2 id=\"什么是策略模式\"\u003e什么是策略模式\u003c/h2\u003e\n\u003cp\u003e策略模式，应该是工作中比较常用的设计模式，调用方自己选择用哪一种策略完成对数据的操作，也就是“一个类的行为或其算法可以在运行时更改”，将一些除了过程不同其他都一样的函数封装成策略，然后调用方自己去选择想让数据执行什么过程策略。常见的例子为根据用户分类推荐不同的排行榜（用户关注点不一样，推荐榜单就不一样）\u003c/p\u003e","title":"如何更优雅地实现策略模式"},{"content":"1. 系统主链路尽可能单点 单点系统，就像苏伊士运河一样，一旦航道出故障，整个运输系统都瘫痪，非常酸爽。\n2. 程序中多用循环 无限死循环，当你看到CPU利用率百分百的时候，你就知道应该甩锅给运维了。\n3. 系统间增加依赖 在系统里增加内部依赖、外部依赖、第三方依赖。总之，能依赖的，决不自己动手写。\n4. 不做服务补偿 很多东西，错过就是错过，没法补偿，这就是人生。\n5. 不做幂等设计 凭啥后端接口要做幂等性设计？前端提交的时候不做判断吗？全都丢给后端开发做？\n6. 不设置超时 连接超时、读超时，有多大设置多大，不管内部调用还是外部调用，都设置成60分钟。只要努力搞，没有时间搞不砸的事情。做不成时间的朋友，就做时间的炮友。\n7. 不控制流量 让流量来得猛烈一些吧，千万别限流，什么漏桶算法、令牌桶算法，那都不如啤酒桶算法\u0026mdash;-喝完就睡，爱谁谁。\n8. 不做监控预警 大家都是职场成年人，做好分内事，别多管闲事。工作几年以后，我明白一个道理：熟练的运用“关我屁事”和“关你屁事”，可以省下人生80%的时间。\n9. 没有重试策略 服务调用失败，你还想重试？我可不是随便的接口。人生不能重来，更不能乱来。\n10. 不做系统隔离 千万别做系统隔离，要挂一起挂。什么是真正的兄弟？就是当兄弟需要女人的时候，挺身而出做他的女人。面对困男，要排除万男，迎男而上。\n11. 代码同步调用 做系统就要步调一致、讲究和谐，尽量同步调用，多写bug。通常我写bug的时候，喜欢中午写，知道为什么吗？因为早晚会有报应。\n12. 不做热数据缓存 RPC的意义是什么？就是被调用啊。疯狂地调用，是对一个服务最起码的尊重。\n13. 不做系统分级 对系统要一视同仁，不要区分核心系统、非核心系统，你有考虑过系统的感受吗？如果你被分门别类，你会开心吗？回想起来，小时候我们都很快乐，就是因为那个时候的我们，丑和穷得都还不是那么明显。\n14. 没有服务降级 服务降级就low了，就算宕机也要一起扛。人生没有白走的路，如果有，那就是微信运动出bug了。\n15. 无灰度和回滚方案 上线全凭运气，没有回滚方案！就是那么自信。我这个人，长这么大没学到别的本事，就掌握了一项特殊技能，白天不用安眠药也能安眠，晚上不用兴奋剂也能兴奋。\n16. 程序多做远程调用 能远程调用的，绝不本地调用，都5G时代了，网络延迟那点事不算什么。\n17. 不做熔断机制 炒股炒昏头了吧，做啥熔断机制？你问过韭零后吗？基金都绿成啥样了，他喊熔断了吗？作为韭菜，学费还是要交的，趁年轻的时候多交点，这样到老了再交你就习惯了。\n18. 不做代码扫描 要有工匠精神，自己代码自己review，机器哪里懂得欣赏你的代码艺术？我那骚气的注释、奇妙的函数、神乎其技的Copy/Paste。每次看代码，都被自己的才华吓到。\n19. 不做线上压测 上线就完了，后面的事情交给菩萨吧。一分耕耘，一分收获。天下没有免费的午餐，所以我一般都睡到下午才起床。\n","permalink":"https://lesanouo.github.io/blog/posts/code/169954560001/","summary":"\u003ch2 id=\"1-系统主链路尽可能单点\"\u003e1. 系统主链路尽可能单点\u003c/h2\u003e\n\u003cp\u003e单点系统，就像苏伊士运河一样，一旦航道出故障，整个运输系统都瘫痪，非常酸爽。\u003c/p\u003e\n\u003ch2 id=\"2-程序中多用循环\"\u003e2. 程序中多用循环\u003c/h2\u003e\n\u003cp\u003e无限死循环，当你看到CPU利用率百分百的时候，你就知道应该甩锅给运维了。\u003c/p\u003e","title":"一个技术架构的反例"},{"content":"修改.gitignore立即生效 git rm -r –cached . git add . git commit -m \u0026#34;update .gitignore\u0026#34; ","permalink":"https://lesanouo.github.io/blog/posts/snippet/git/","summary":"\u003ch2 id=\"修改gitignore立即生效\"\u003e修改.gitignore立即生效\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit rm -r –cached .\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit add .\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit commit -m \u003cspan class=\"s2\"\u003e\u0026#34;update .gitignore\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"Git 代码片段"},{"content":"在工作中，公司内部往往需要一个私有的MAVEN仓库进行统一管理，本篇文章就带大家如何通过nexus搭建一个自己的MAVEN私有仓库\n下载 nexus 安装包 nexus官网地址：https://www.sonatype.com/products/sonatype-nexus-oss-download\n由于官网下载有一定的限制，提供百度网盘下载地址，提取码：797P\n其中：\nwin64后缀为window安装包 unix后缀为linux安装包 mac后缀为mac安装包 安装 nexus 由于服务器一般为linux系统（centos/ubuntu），下面演示为linux系统安装nexus\n将unix后缀安装包上传至服务器任意目录 解压安装包：tar -zxvf nexus-3.19.1-01-unix.tar.gz 进入解压完成的目录下的bin目录，执行：./nexus start启动nexus 启动成功后通过浏览器访问：http://IP:8081（8081为默认端口，可在etc/nexus-default.properties修改） ./nexus start启动成功后无法访问http://ip:port时，可以使用./nexus run命令启动，该命令会打印启动日志进行排查启动失败原因，但该命令在退出命令行时同时会停止nexus进程\n配置 nexus 初始化密码 首次登陆后需要更新初始化密码 nexus3以前的默认用户名密码 admin / admin123 nexus3的默认用户名依然是admin， 密码在admin.password文件中，可以通过find / | grep 'admin.password'查找路径，一般在解压后的sonatype-work目录下 登录成功后会多一个设置菜单 配置仓库 系统默认有以下几个maven仓库：\nmaven-central (proxy) : 远程中央仓库 maven-releases (hosted): 私库发行仓库 maven-snapshots (hosted): 私库快照仓库 maven-public (group) : 仓库组 仓库类型：\nproxy：可以自主配置使用的远程仓库地址 hosted：内部项目构件发布的仓库类型 virtual：虚拟仓库类型（基本不用） group：可以自由顺序组合多个仓库使用 创建阿里云maven远程仓库 菜单选择路径：\nRepository \u0026ndash;\u0026gt; Repositories \u0026ndash;\u0026gt; Create repository \u0026ndash;\u0026gt; maven2(proxy)\n阿里云仓库地址：http://maven.aliyun.com/nexus/content/groups/public/\n配置仓库组： 菜单选择路径（默认已有maven-public）：\nRepository \u0026ndash;\u0026gt; Repositories \u0026ndash;\u0026gt; Create repository \u0026ndash;\u0026gt; maven2(group)\n⚠️ 注意仓库顺序，maven查找依赖时会依次遍历仓库组中的仓库\n创建角色及用户 创建角色并分配权限 菜单选择路径：\nSecurity \u0026ndash;\u0026gt; Roles \u0026ndash;\u0026gt; Create\n创建用户并分配角色 菜单选择路径：\nSecurity \u0026ndash;\u0026gt; Users \u0026ndash;\u0026gt; Create\n测试 nexus settings.xml 配置 pom.xml 配置 实际使用中distributionManagement可以配置在parent项目中，子项目无需重复配置\n测试 上述配置全部完成后就可以在项目中使用mven clean deploy将项目的jar包上传到自己的私服上了\n本篇文章引用自：https://blog.csdn.net/z562743237/article/details/108852509、https://blog.csdn.net/qq_62851576/article/details/144337703\n","permalink":"https://lesanouo.github.io/blog/posts/code/169531200001/","summary":"\u003cp\u003e在工作中，公司内部往往需要一个私有的MAVEN仓库进行统一管理，本篇文章就带大家如何通过nexus搭建一个自己的MAVEN私有仓库\u003c/p\u003e\n\u003ch2 id=\"下载-nexus-安装包\"\u003e下载 nexus 安装包\u003c/h2\u003e\n\u003cp\u003enexus官网地址：https://www.sonatype.com/products/sonatype-nexus-oss-download\u003c/p\u003e","title":"MAVEN私有仓库搭建与配置"},{"content":"编写完go程序后编译成exe后，双击可正常执行，但是通过sc注册为服务后启动报错错误1053：服务没有及时响应启动或控制请求，百思不得其解，只能看看能不能有别的方式注册成服务。\n通过使用开源库github.com/kardianos/service可以更方便的注册成windows服务，并不会出现上述情况，下面就是简单的测试代码。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/kardianos/service\u0026#34; \u0026#34;os\u0026#34; ) func main() { srvConfig := \u0026amp;service.Config{ Name: \u0026#34;WinServiceExample\u0026#34;, DisplayName: \u0026#34;WinServiceExample\u0026#34;, Description: \u0026#34;WinServiceExample\u0026#34;, } prg := \u0026amp;program{} s, err := service.New(prg, srvConfig) if err != nil { fmt.Println(err) } if len(os.Args) \u0026gt; 1 { serviceAction := os.Args[1] switch serviceAction { case \u0026#34;install\u0026#34;: err := s.Install() if err != nil { fmt.Println(\u0026#34;安装服务失败: \u0026#34;, err.Error()) } else { fmt.Println(\u0026#34;安装服务成功\u0026#34;) } return case \u0026#34;uninstall\u0026#34;: err := s.Uninstall() if err != nil { fmt.Println(\u0026#34;卸载服务失败: \u0026#34;, err.Error()) } else { fmt.Println(\u0026#34;卸载服务成功\u0026#34;) } return case \u0026#34;start\u0026#34;: err := s.Start() if err != nil { fmt.Println(\u0026#34;运行服务失败: \u0026#34;, err.Error()) } else { fmt.Println(\u0026#34;运行服务成功\u0026#34;) } return case \u0026#34;stop\u0026#34;: err := s.Stop() if err != nil { fmt.Println(\u0026#34;停止服务失败: \u0026#34;, err.Error()) } else { fmt.Println(\u0026#34;停止服务成功\u0026#34;) } return } } err = s.Run() if err != nil { fmt.Println(err) } } type program struct{} func (p *program) Start(s service.Service) error { fmt.Println(\u0026#34;服务运行...\u0026#34;) go p.run() return nil } func (p *program) run() { // 具体的服务实现 } func (p *program) Stop(s service.Service) error { return nil } 注意：启动go编译好的exe时，需要使用管理员权限运行才能够注册到服务中。\n","permalink":"https://lesanouo.github.io/blog/posts/code/168960960001/","summary":"\u003cp\u003e编写完go程序后编译成exe后，双击可正常执行，但是通过\u003ccode\u003esc\u003c/code\u003e注册为服务后启动报错\u003ccode\u003e错误1053：服务没有及时响应启动或控制请求\u003c/code\u003e，百思不得其解，只能看看能不能有别的方式注册成服务。\u003c/p\u003e","title":"go程序注册为windows服务"},{"content":"Cannot read properties of null (reading ‘pickAlgorithm‘) npm cache clear --force 单次 npm 使用代理和镜像 npm --registry https://registry.npmmirror.com --proxy http://xxx:9999 i ","permalink":"https://lesanouo.github.io/blog/posts/snippet/npm/","summary":"\u003ch2 id=\"cannot-read-properties-of-null-reading-pickalgorithm\"\u003eCannot read properties of null (reading ‘pickAlgorithm‘)\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003enpm cache clear --force\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"单次-npm-使用代理和镜像\"\u003e单次 npm 使用代理和镜像\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003enpm --registry https://registry.npmmirror.com --proxy http://xxx:9999 i\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"NPM 代码片段"},{"content":"大文件上传是提高用户体验感的重要功能，像百度网盘、阿里网盘等等都支持断点续传和文件秒传功能，减少了网络波动和网络带宽对文件的限制。\n「文件分块」：将大文件拆分成小文件，将小文件上传\\下载，最后再将小文件组装成大文件； 「断点续传」：在文件分块的基础上，将每个小文件采用单独的线程进行上传\\下载，如果碰到网络故障，可以从已经上传\\下载的部分开始继续上传\\下载未完成的部分，而没有必要从头开始上传\\下载； 「文件秒传」：资源服务器中已经存在该文件，其他人上传时直接返回该文件的URI。 本文将介绍SpringBoot中实现大文件上传的主要代码：\n文件分块 文件分块需要在前端处理，前端通过获取文件的唯一md5的值来区分不同文件，通过确定文件分块的大小和分块的数量，为每一个分块指定一个索引值后上传不同块文件。\n通过md5也可以用来校验服务器上是否存在该文件以及文件的上传状态。\n如果文件存在，直接返回文件地址； 如果文件不存在，但是有上传状态，即部分分块上传成功，则返回未上传的分块索引数组； 如果文件不存在，且上传状态为空，则所有分块均需要上传。 const readFileMD5 = () =\u0026gt; { let fileReader = new FileReader(); fileReader.readAsBinaryString(file) fileReader.addEventListener(\u0026#34;load\u0026#34;, (e) =\u0026gt; { let fileBlob = e.target.result fileMD5 = md5(fileBlob) const formData = new FormData(); formData.append(\u0026#34;md5\u0026#34;, fileMD5) axios .post(\u0026#34;http://localhost:9191/fileUpload/checkFileMd5\u0026#34;, formData) .then((res) =\u0026gt; { if (res.data.message == \u0026#34;文件已存在\u0026#34;) { //文件已存在不走后面分片了，直接返回文件地址到前台页面 console.log(res.data) } else { //文件不存在存在两种情况，一种是返回data：null代表未上传过 一种是data:[xx，xx] 还有哪几片未上传 if (res.data.data != null) { //还有几片未上传情况，断点续传 chunkArr = res.data.data; } readChunkMD5(); } }) .catch((e) =\u0026gt; { }) }) } 通过slice方法来取出索引在文件中对应位置的分块。\nconst getChunkInfo = (file, currentChunk, chunkSize) =\u0026gt; { let start = currentChunk * chunkSize let end = Math.min(file.size, start + chunkSize) let chunk = file.slice(start, end) return {start, end, chunk} } 断点续传、文件秒传 通过redis来存储上传文件的状态和上传文件的地址。\n如果文件完整上传，返回文件路径；如果部分上传则返回未上传的分块数组；如果未上传过返回提示信息。\nNote: 在上传分块时会产生两个文件，一个是文件主体，一个是临时文件。临时文件可以看做是一个数组文件，为每一个分块分配一个值为127的字节。\n校验MD5值时会用到两个值：\n文件上传状态：只要该文件上传过就不为空，如果完整上传则为true，部分上传返回false； 文件上传地址：如果文件完整上传，返回文件路径；部分上传返回临时文件路径。 @PostMapping(\u0026#34;/checkFileMd5\u0026#34;) @ResponseBody public Result checkFileMd5(String md5) throws IOException { Object processingObj = stringRedisTemplate.opsForHash().get(UploadConstants.FILE_UPLOAD_STATUS, md5); if (processingObj == null) { return Result.ok(\u0026#34;该文件没有上传过\u0026#34;); } boolean processing = Boolean.parseBoolean(processingObj.toString()); String value = stringRedisTemplate.opsForValue().get(UploadConstants.FILE_MD5_KEY + md5); if (processing) { return Result.ok(value, \u0026#34;文件已存在\u0026#34;); } else { File confFile = new File(value); byte[] completeList = FileUtil.readBytes(confFile); List\u0026lt;Integer\u0026gt; missChunkList = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; completeList.length; i++) { if (completeList[i] != Byte.MAX_VALUE) { missChunkList.add(i); } } return Result.ok(missChunkList, \u0026#34;该文件上传了一部分\u0026#34;); } } 分块上传、文件合并 上面利用文件的md5值来维护分块和文件的关系，因此我们会将具有相同md5值的分块进行合并，由于每个分块都有自己的索引值，所以我们会将分块按索引像插入数组一样分别插入文件中，形成完整的文件。\n分块上传时，要和前端的分块大小、分块数量、当前分块索引等对应好，以备文件合并时使用，此处我们采用的是磁盘映射的方式来合并文件。\npublic boolean uploadFileByMappedByteBuffer(MultipartFileDTO multipartFileDTO) throws IOException { // 路径：服务器存储地址/md5字符串 String uploadDirPath = finalDirPath + multipartFileDTO.getMd5(); File tmpDir = new File(uploadDirPath); if (!tmpDir.exists()) { tmpDir.mkdirs(); } String fileName = multipartFileDTO.getName(); // 临时文件名 String tempFileName = fileName + \u0026#34;_tmp\u0026#34;; File tmpFile = new File(uploadDirPath, tempFileName); // 读操作和写操作都是允许的 RandomAccessFile tempRaf = new RandomAccessFile(tmpFile, \u0026#34;rw\u0026#34;); //它返回的就是nio通信中的file的唯一channel FileChannel fileChannel = tempRaf.getChannel(); // 写入该分片数据 分片大小 * 第几块分片获取偏移量 long offset = CHUNK_SIZE * multipartFileDTO.getChunk(); // 分片文件大小 byte[] fileData = multipartFileDTO.getFile().getBytes(); // 将文件的区域直接映射到内存 MappedByteBuffer mappedByteBuffer = fileChannel.map(FileChannel.MapMode.READ_WRITE, offset, fileData.length); mappedByteBuffer.put(fileData); // 释放 FileMD5Util.freedMappedByteBuffer(mappedByteBuffer); fileChannel.close(); boolean isOk = checkAndSetUploadProgress(multipartFileDTO, uploadDirPath); if (isOk) { boolean flag = renameFile(tmpFile, fileName); System.out.println(\u0026#34;upload complete !!\u0026#34; + flag + \u0026#34; name=\u0026#34; + fileName); return flag; } return false; } public boolean renameFile(File toBeRenamed, String toFileNewName) { // 检查要重命名的文件是否存在，是否是文件 if (!toBeRenamed.exists() || toBeRenamed.isDirectory()) { log.info(\u0026#34;File does not exist: \u0026#34; + toBeRenamed.getName()); return false; } String p = toBeRenamed.getParent(); File newFile = new File(p + File.separatorChar + toFileNewName); // 修改文件名 return toBeRenamed.renameTo(newFile); } 每当完成一次分块的上传，还需要去检查文件的上传进度，看文件是否上传完成。\nprivate boolean checkAndSetUploadProgress(MultipartFileDTO multipartFileDTO, String uploadDirPath) throws IOException { String fileName = multipartFileDTO.getName(); // 路径/filename.conf File confFile = new File(uploadDirPath, fileName + \u0026#34;.conf\u0026#34;); RandomAccessFile accessConfFile = new RandomAccessFile(confFile, \u0026#34;rw\u0026#34;); // 把该分段标记为 true 表示完成 System.out.println(\u0026#34;set part \u0026#34; + multipartFileDTO.getChunk() + \u0026#34; complete\u0026#34;); accessConfFile.setLength(multipartFileDTO.getChunks()); accessConfFile.seek(multipartFileDTO.getChunk()); accessConfFile.write(Byte.MAX_VALUE); // completeList 检查是否全部完成,如果数组里是否全部都是(全部分片都成功上传) byte[] completeList = FileUtil.readBytes(confFile); byte isComplete = Byte.MAX_VALUE; for (int i = 0; i \u0026lt; completeList.length \u0026amp;\u0026amp; isComplete == Byte.MAX_VALUE; i++) { //与运算, 如果有部分没有完成则 isComplete 不是 Byte.MAX_VALUE isComplete = (byte) (isComplete \u0026amp; completeList[i]); System.out.println(\u0026#34;check part \u0026#34; + i + \u0026#34; complete?:\u0026#34; + completeList[i]); } accessConfFile.close(); // 更新redis中的状态：如果是true的话证明是已经该大文件全部上传完成 if (isComplete == Byte.MAX_VALUE) { stringRedisTemplate.opsForHash().put(UploadConstants.FILE_UPLOAD_STATUS, multipartFileDTO.getMd5(), \u0026#34;true\u0026#34;); stringRedisTemplate.opsForValue().set(UploadConstants.FILE_MD5_KEY + multipartFileDTO.getMd5(), uploadDirPath + \u0026#34;/\u0026#34; + fileName); return true; } else { if (!stringRedisTemplate.opsForHash().hasKey(UploadConstants.FILE_UPLOAD_STATUS, multipartFileDTO.getMd5())) { stringRedisTemplate.opsForHash().put(UploadConstants.FILE_UPLOAD_STATUS, multipartFileDTO.getMd5(), \u0026#34;false\u0026#34;); } if (!stringRedisTemplate.hasKey(UploadConstants.FILE_MD5_KEY + multipartFileDTO.getMd5())) { stringRedisTemplate.opsForValue().set(UploadConstants.FILE_MD5_KEY + multipartFileDTO.getMd5(), uploadDirPath + \u0026#34;/\u0026#34; + fileName + \u0026#34;.conf\u0026#34;); } return false; } } 在MappedByteBuffer释放后再对它进行读操作的话就会引发jvm crash，在并发情况下很容易发生正在释放时另一个线程正开始读取，于是crash就发生了。所以为了系统稳定性释放前一般需要检查是否还有线程在读或写。\npublic static void freedMappedByteBuffer(final MappedByteBuffer mappedByteBuffer) { try { if (mappedByteBuffer == null) { return; } mappedByteBuffer.force(); AccessController.doPrivileged(new PrivilegedAction\u0026lt;Object\u0026gt;() { @Override public Object run() { try { Method getCleanerMethod = mappedByteBuffer.getClass().getMethod(\u0026#34;cleaner\u0026#34;, new Class[0]); getCleanerMethod.setAccessible(true); sun.misc.Cleaner cleaner = (sun.misc.Cleaner) getCleanerMethod.invoke(mappedByteBuffer, new Object[0]); cleaner.clean(); } catch (Exception e) { log.error(\u0026#34;clean MappedByteBuffer error!!!\u0026#34;, e); } log.info(\u0026#34;clean MappedByteBuffer completed!!!\u0026#34;); return null; } }); } catch (Exception e) { e.printStackTrace(); } } 技术点 RandomAccessFile RandomAccessFile相当于是FileInputStream与FileOutputStream的封装结合，即可以读也可以写，并且RandomAccessFile支持移动到文件指定位置处开始读或写。\nMappedByteBuffer MappedByteBuffer是Java提供的基于操作系统虚拟内存映射（MMAP）技术的文件读写API，底层不再通过read、write、seek等系统调用实现文件的读写。\nAccessController.doPrivileged() AccessController.doPrivileged是一个在AccessController类中的静态方法，允许在一个类实例中的代码通知这个AccessController：它的代码主体是享受\u0026quot;privileged(特权的)\u0026quot;，它单独负责对它的可得的资源的访问请求，而不管这个请求是由什么代码所引发的。 这就是说，一个调用者在调用doPrivileged方法时，可被标识为 \u0026ldquo;特权\u0026rdquo;。在做访问控制决策时，如果checkPermission方法遇到一个通过doPrivileged调用而被表示为 \u0026ldquo;特权\u0026quot;的调用者，并且没有上下文自变量，checkPermission方法则将终止检查。如果那个调用者的域具有特定的许可，则不做进一步检查，checkPermission安静地返回，表示那个访问请求是被允许的；如果那个域没有特定的许可，则象通常一样，一个异常被抛出。\n本文参考自： https://gitee.com/zhangxiaoQ/large-file-upload.git\n","permalink":"https://lesanouo.github.io/blog/posts/code/168831360001/","summary":"\u003cp\u003e大文件上传是提高用户体验感的重要功能，像百度网盘、阿里网盘等等都支持断点续传和文件秒传功能，减少了网络波动和网络带宽对文件的限制。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e「文件分块」：将大文件拆分成小文件，将小文件上传\\下载，最后再将小文件组装成大文件；\u003c/li\u003e\n\u003cli\u003e「断点续传」：在文件分块的基础上，将每个小文件采用单独的线程进行上传\\下载，如果碰到网络故障，可以从已经上传\\下载的部分开始继续上传\\下载未完成的部分，而没有必要从头开始上传\\下载；\u003c/li\u003e\n\u003cli\u003e「文件秒传」：资源服务器中已经存在该文件，其他人上传时直接返回该文件的URI。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e本文将介绍SpringBoot中实现大文件上传的主要代码：\u003c/p\u003e","title":"SpringBoot实现大文件上传"},{"content":"在电商、支付等系统中，一般都是先创建订单（支付单），再给用户一定的时间进行支付，如果没有按时支付的话，就需要把之前的订单（支付单）取消掉。\n这种类似的场景有很多，还有比如到期自动收货、超时自动退款、下单后自动发送短信等等都是类似的业务问题。\nRedisson是一个在Redis的基础上实现的框架，它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务。Redission中定义了分布式延迟队列RDelayedQueue，这是一种基于我们前面介绍过的zset结构实现的延时队列，它允许以指定的延迟时长将元素放到目标队列中。\n本文通过使用Redisson中的RDelayedQueue来实现一个简单的过期自动取消功能：\n1. 自定义对象 @Data @AllArgsConstructor public class DelayJobDto implements Serializable { private String username; private String msg; } 2. 创建Bean @Configuration public class DelayJobConfig { @Autowired private RedissonClient redissonClient; @Bean(\u0026#34;blockQueue\u0026#34;) public RBlockingDeque\u0026lt;DelayJobDto\u0026gt; getBlockQueue() { RBlockingDeque\u0026lt;DelayJobDto\u0026gt; blockingDeque = redissonClient.getBlockingDeque(\u0026#34;delay:job:result\u0026#34;); return blockingDeque; } @Bean(\u0026#34;delayedQueue\u0026#34;) public RDelayedQueue\u0026lt;DelayJobDto\u0026gt; getDelayQueue() { RBlockingDeque\u0026lt;DelayJobDto\u0026gt; blockingDeque = getBlockQueue(); RDelayedQueue\u0026lt;DelayJobDto\u0026gt; delayedQueue = redissonClient.getDelayedQueue(blockingDeque); return delayedQueue; } } 3. 编写到期处理服务 @Slf4j @Service public class DelayJobService\u0026lt;T\u0026gt; { @Async public void expire(DelayJobDto delayJobDto) { log.info(\u0026#34;用户：{} 已到期：msg：{}\u0026#34;, delayJobDto.getUsername(), delayJobDto.getMsg()); } } 4. 创建线程 方式一：\n@Slf4j @Component public class DelayJobThread { @Autowired private DelayJobService\u0026lt;DelayJobDto\u0026gt; synthesisResultConsumer; @Autowired private RBlockingDeque\u0026lt;DelayJobDto\u0026gt; blockingDeque; @PostConstruct // 当依赖注入完成后用于执行初始化的方法，并且只会被执行一次 public void listen() { new Thread(()-\u0026gt;{ while (true) { try { log.info(\u0026#34;延时队列的数量：{}\u0026#34;, blockingDeque.size()); log.info(\u0026#34;listen 本次监听时间：{}\u0026#34;, DateUtil.formatDate(new Date())); DelayJobDto dto = blockingDeque.take(); //到期时自动取出 log.info(\u0026#34;listen 从队列中获取需要查询结果的延时任务信息：{}\u0026#34;, JSON.toJSONString(dto)); synthesisResultConsumer.expire(dto); } catch (InterruptedException e) { e.printStackTrace(); } } }).start(); } } 方式二：\n@Slf4j @Component public class DelayJobRunner implements CommandLineRunner { // 程序启动后执行的功能 @Autowired private DelayJobService\u0026lt;DelayJobDto\u0026gt; synthesisResultConsumer; @Autowired private RBlockingDeque\u0026lt;DelayJobDto\u0026gt; blockingDeque; @Override public void run(String... args) { new Thread(()-\u0026gt;{ while (true) { try { log.info(\u0026#34;延时队列的数量：{}\u0026#34;, blockingDeque.size()); log.info(\u0026#34;listen 本次监听时间：{}\u0026#34;, DateUtil.formatDate(new Date())); DelayJobDto dto = blockingDeque.take(); //到期时自动取出 log.info(\u0026#34;listen 从队列中获取需要查询结果的延时任务信息：{}\u0026#34;, JSON.toJSONString(dto)); synthesisResultConsumer.expire(dto); } catch (InterruptedException e) { e.printStackTrace(); } } }).start(); } } 5. 创建延时任务 @Autowired private RDelayedQueue\u0026lt;DelayJobDto\u0026gt; delayedQueue; delayedQueue.offer(new DelayJobDto(\u0026#34;Lesan\u0026#34;, \u0026#34;延时任务\u0026#34;), 1, TimeUnit.MINUTES); 本文参考自： https://www.jianshu.com/p/3b6ad5d21e59\n","permalink":"https://lesanouo.github.io/blog/posts/code/168814080001/","summary":"\u003cp\u003e在电商、支付等系统中，一般都是先创建订单（支付单），再给用户一定的时间进行支付，如果没有按时支付的话，就需要把之前的订单（支付单）取消掉。\u003c/p\u003e\n\u003cp\u003e这种类似的场景有很多，还有比如到期自动收货、超时自动退款、下单后自动发送短信等等都是类似的业务问题。\u003c/p\u003e","title":"SpringBoot+Redisson实现延迟队列"},{"content":"函数节流（throttle）是 JS 中一个非常常见的优化手段，可以有效的避免函数过于频繁的执行。\n举个例子：一个保存按钮，为了避免重复提交或者服务器考虑，往往需要对点击行为做一定的限制，比如只允许每300ms提交一次，这时候我想大部分同学都会到网上直接拷贝一段throttle函数，或者直接引用lodash工具库\nbtn.addEventListener(\u0026#39;click\u0026#39;, _.throttle(save, 300)) 其实除了 JS 方式， CSS 也可以非常轻易的实现这样一个功能，无需任何框架库\nCSS实现思路分析 CSS 实现和 JS 的思维不同，需要从另一个角度去看待这个问题。\n比如这里的需要对点击事件进行限制，也就是禁用点击事件，想想有什么方式可以禁用事件，没错，就是pointer-events;\n然后是时间的限制，每次点击后需要自动禁用300ms，时间过后重新恢复，那么，有什么特性和时间以及状态恢复有关呢？没错，就是animation;\n除此之外，还需要有触发时机，这里是点击行为，所以必然和伪类:active有关联。\n因此，综合分析，实现这样一个功能需要用到pointer-events、animation以及:active，那么如何将这些思路串联起来呢？\n其实这种场景可以理解成是对 CSS 动画的控制，比如有一个动画控制按钮从禁用-\u0026gt;可点击的变化，每次点击时让这个动画重新执行一遍，在执行的过程中，一直处于禁用状态，是不是就达到了“节流”的效果了？\nCSS 动画的精准控制 假设有一个按钮，绑定了一个点击事件\n\u0026lt;button onclick=\u0026#34;console.log(\u0026#39;保存\u0026#39;)\u0026#34;\u0026gt;保存\u0026lt;/button\u0026gt; 这时的按钮连续点击就会不断地触发\n下面定义一个关于pointer-events的动画，就叫做 throttle 吧\n@keyframes throttle { from { pointer-events: none; } to { pointer-events: all; } } 很简单吧，就是从禁用到可点击的变化。\n接下来，将这个动画绑定在按钮上，这里为了方便测试，将动画设置成了2s\nbutton{ animation: throttle 2s step-end forwards; } 注意，这里动画的缓动函数设置成了阶梯曲线，step-end，它可以很方便的控制pointer-events的变化时间点。\n如下示意，pointer-events在0~2秒内的值都是none，一旦到达2秒，就立刻变成了all，由于是forwards，会一直保持all的状态\n最后，在点击时重新执行一遍动画，只需要在按下时设置动画为none就行了\n实现如下\nbutton:active{ animation: none; } 为了演示方便，我们暂时把颜色变化也加在动画里\n@keyframes throttle { from { color: red; pointer-events: none; } to { color: green; pointer-events: all; } } 现在如果文字是red，表示是禁用态，只有是green，才表示可以被点击，非常清晰明了\n完整代码如下，就这么几行，如果需要改限制时间，直接改动画时间就行了 button{ animation: throttle 2s step-end forwards; } button:active{ animation: none; } @keyframes throttle { from { pointer-events: none; } to { pointer-events: all; } } CSS 实现的其他思路 具体思路是这样的，通过:active去触发transition变化，然后通过监听transition回调去动态设置按钮的禁用状态，实现如下\n定义一个无关紧要的过渡属性，比如opacity\nbutton{ opacity: .99; transition: opacity 2s; } button:not(:disabled):active{ opacity: 1; transition: 0s; } 然后监听transition的起始回调\n// 过渡开始 document.addEventListener(\u0026#39;transitionstart\u0026#39;, function(ev){ ev.target.disabled = true }) // 过渡结束 document.addEventListener(\u0026#39;transitionend\u0026#39;, function(ev){ ev.target.disabled = false }) 这样做的最大好处是，这部分禁用的逻辑是完全和业务逻辑是解耦的，可以在任意时候，任意场合下无缝接入，也不受框架和环境影响\n总结 以上通过 CSS 的思路实现了类似“节流”的功能，相比 JS 实现而言，实现更精简、使用更简单，没有框架限制，下面一起总结一下实现要点：\n函数节流是一个非常常见的优化方式，可以有效避免函数过于频繁的执行 CSS 的实现思路和 JS 不同，重点在于在于找到和该场景相关联的属性 CSS 实现“节流”其实就是控制一个动画的精准控制，假设有一个动画控制按钮从禁用-\u0026gt;可点击的变化，每次点击时让这个动画重新执行一遍，在执行的过程中，一直处于禁用状态，这样就达到了“节流”的效果 还可以通过 transition 的回调函数动态设置按钮禁用态 这种实现的好处在于禁用逻辑和业务逻辑是完全解耦的 不过，这种实现方式还是比较有局限的，仅限于点击行为，像很多时候，节流可能会用在滚动事件或者键盘事件上，像这些场景就用传统方式实现就行了。\n","permalink":"https://lesanouo.github.io/blog/posts/code/168805440004/","summary":"\u003cp\u003e函数节流（throttle）是 JS 中一个非常常见的优化手段，可以有效的避免函数过于频繁的执行。\u003c/p\u003e\n\u003cp\u003e举个例子：一个保存按钮，为了避免重复提交或者服务器考虑，往往需要对点击行为做一定的限制，比如只允许每300ms提交一次，这时候我想大部分同学都会到网上直接拷贝一段throttle函数，或者直接引用lodash工具库\u003c/p\u003e","title":"CSS实现防止按钮重复点击"},{"content":"本篇文章主要简要总结Redis的常见用途\n1、缓存 String类型\n例如：热点数据缓存（例如报表、明星出轨），对象缓存、全页缓存、可以提升热点数据的访问数据。\n2、数据共享分布式 String 类型，因为 Redis 是分布式的独立服务，可以在多个应用之间共享\n例如：分布式Session\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.session\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-session-data-redis\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 3、分布式锁 String 类型setnx方法，只有不存在时才能添加成功，返回true\npublic static boolean getLock(String key) { Long flag = jedis.setnx(key, \u0026#34;1\u0026#34;); if (flag == 1) { jedis.expire(key, 10); } return flag == 1; } public static void releaseLock(String key) { jedis.del(key); } 4、全局ID int类型，incrby，利用原子性\nincrby userid 1000\n分库分表的场景，一次性拿一段\n5、计数器 int类型，incr方法\n例如：文章的阅读量、微博点赞数、允许一定的延迟，先写入Redis再定时同步到数据库\n6、限流 int类型，incr方法\n以访问者的ip和其他信息作为key，访问一次增加一次计数，超过次数则返回false\n7、位统计 String类型的bitcount（1.6.6的bitmap数据结构介绍）\n字符是以8位二进制存储的\nset k1 a setbit k1 6 1 setbit k1 7 0 get k1 /* 6 7 代表的a的二进制位的修改 a 对应的ASCII码是97，转换为二进制数据是01100001 b 对应的ASCII码是98，转换为二进制数据是01100010 因为bit非常节省空间（1 MB=8388608 bit），可以用来做大数据量的统计。 */ 例如：在线用户统计，留存用户统计\nsetbit onlineusers 01 setbit onlineusers 11 setbit onlineusers 20 支持按位与、按位或等等操作\nBITOPANDdestkeykey[key...] ，对一个或多个 key 求逻辑并，并将结果保存到 destkey 。 BITOPORdestkeykey[key...] ，对一个或多个 key 求逻辑或，并将结果保存到 destkey 。 BITOPXORdestkeykey[key...] ，对一个或多个 key 求逻辑异或，并将结果保存到 destkey 。 BITOPNOTdestkeykey ，对给定 key 求逻辑非，并将结果保存到 destkey 。 计算出7天都在线的用户\nBITOP \u0026#34;AND\u0026#34; \u0026#34;7_days_both_online_users\u0026#34; \u0026#34;day_1_online_users\u0026#34; \u0026#34;day_2_online_users\u0026#34; ... \u0026#34;day_7_online_users\u0026#34; 8、购物车 String 或hash。所有String可以做的hash都可以做\nkey：用户id；field：商品id；value：商品数量。\n+1：hincr。-1：hdecr。删除：hdel。全选：hgetall。商品数：hlen。\n9、用户消息时间线timeline list，双向链表，直接作为timeline就好了。插入有序\n10、消息队列 List提供了两个阻塞的弹出操作：blpop/brpop，可以设置超时时间\nblpop：blpop key1 timeout 移除并获取列表的第一个元素，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。\nbrpop：brpop key1 timeout 移除并获取列表的最后一个元素，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。\n上面的操作。其实就是java的阻塞队列。学习的东西越多。学习成本越低\n队列：先进先除：rpush blpop，左头右尾，右边进入队列，左边出队列\n栈：先进后出：rpush brpop\n11、抽奖 自带一个随机获得值\nspop myset 12、点赞、签到、打卡 假如上面的微博ID是t1001，用户ID是u3001\n用 like:t1001 来维护 t1001 这条微博的所有点赞用户\n点赞了这条微博：sadd like:t1001 u3001\n取消点赞：srem like:t1001 u3001\n是否点赞：sismember like:t1001 u3001\n点赞的所有用户：smembers like:t1001\n点赞数：scard like:t1001\n是不是比数据库简单多了。\n13、商品标签 老规矩，用 tags:i5001 来维护商品所有的标签。\nsadd tags:i5001 画面清晰细腻\nsadd tags:i5001 真彩清晰显示屏\nsadd tags:i5001 流程至极\n14、商品筛选 // 获取差集\rsdiff set1 set2\r// 获取交集（intersection ）\rsinter set1 set2\r// 获取并集\rsunion set1 set2 假如：iPhone11 上市了\nsadd brand:apple iPhone11\rsadd brand:ios iPhone11\rsad screensize:6.0-6.24 iPhone11\rsad screentype:lcd iPhone 11 赛选商品，苹果的、ios的、屏幕在6.0-6.24之间的，屏幕材质是LCD屏幕\nsinter brand:apple brand:ios screensize:6.0-6.24 screentype:lcd 15、用户关注、推荐模型 follow 关注 fans 粉丝\n相互关注：\nsadd 1:follow 2\nsadd 2:fans 1\nsadd 1:fans 2\nsadd 2:follow 1\n我关注的人也关注了他(取交集)：\nsinter 1:follow 2:fans 可能认识的人：\n用户1可能认识的人(差集)：sdiff 2:follow 1:follow\n用户2可能认识的人：sdiff 1:follow 2:follow\n16、排行榜 id 为6001 的新闻点击数加1：\nzincrby hotNews:20190926 1 n6001 获取今天点击最多的15条：\nzrevrange hotNews:20190926 0 15 withscores ","permalink":"https://lesanouo.github.io/blog/posts/code/168805440003/","summary":"\u003cp\u003e本篇文章主要简要总结Redis的常见用途\u003c/p\u003e\n\u003ch2 id=\"1缓存\"\u003e1、缓存\u003c/h2\u003e\n\u003cp\u003eString类型\u003c/p\u003e\n\u003cp\u003e例如：热点数据缓存（例如报表、明星出轨），对象缓存、全页缓存、可以提升热点数据的访问数据。\u003c/p\u003e","title":"Redis常见用途"},{"content":"本文用最短的时间给大家分享手写 starter 的完整流程。\n创建项目 首先我们用 IDEA 开发工具来初始化一个 Spring Boot 项目，注意 Java 版本不要选太高、Spring Boot 版本不要选 3.x\n引入依赖 初始化项目后，我们要在项目依赖文件 pom.xml 中引入几个核心依赖：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-autoconfigure\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-configuration-processor\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; 其中，spring-boot-autoconfigure 用于自动加载配置，spring-boot-configuration-processor 用于自动生成配置文件的自动提示。\n有这些依赖就足够了，我们尽量保证 starter 的精简，便于其他项目引用时的兼容性。\n此外，还要把 pom.xml 中的下面这段代码删掉：\n\u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; 编写starter 接下来，假设我们已经开发了一个 Client（实现了主要功能的类），我们要编写一个配置类，用于自动创建 Client 实例。\n@Configuration @ConfigurationProperties(prefix = \u0026#34;yuapi.client\u0026#34;) @Data @ComponentScan public class YuApiClientConfig { /** * appId */ private String appId; /** * 秘钥 */ private String appSecret; @Bean public YuApiClient yuApiClient() { return new YuApiClient(appId, appSecret, userId); } } 上述代码中，比较关键的注解是：\n@Configuration：告诉 Spring Boot 这是一个配置类，可以在该类中创建 Bean @ConfigurationProperties：和配置文件（一般是 application.yml）进行绑定，将配置文件中对应的配置映射到对象的属性中。比如 application.yml 中 yuapi.client.appId 的值会自动注入到 YuApiClientConfig 实例的 appId 属性。不用再把值硬编码到类中了！ 写完这个配置类后，还要把它进行注册，创建一个配置文件 resources/META_INF/spring.factories ，编写如下代码：\n# spring boot starter\rorg.springframework.boot.autoconfigure.EnableAutoConfiguration=com.yupi.mystarter.YuApiClientConfig 这样，就相当于给了项目一个启动入口（类似 main）。\n然后，我们的 stater 类库就编写完毕啦！执行 mvn install 命令，就可以把它打包为本地依赖，供其他项目使用。\n比如：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.yupi\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;my-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; ","permalink":"https://lesanouo.github.io/blog/posts/code/168805440002/","summary":"\u003cp\u003e本文用最短的时间给大家分享手写 starter 的完整流程。\u003c/p\u003e\n\u003ch2 id=\"创建项目\"\u003e创建项目\u003c/h2\u003e\n\u003cp\u003e首先我们用 IDEA 开发工具来初始化一个 Spring Boot 项目，注意 Java 版本不要选太高、Spring Boot 版本不要选 3.x\u003c/p\u003e\n\u003ch2 id=\"引入依赖\"\u003e引入依赖\u003c/h2\u003e\n\u003cp\u003e初始化项目后，我们要在项目依赖文件 pom.xml 中引入几个核心依赖：\u003c/p\u003e","title":"SpringBoot自建starter库"},{"content":"本篇文章分享网上看到的一些非常有用的 SQL 语句，并不复杂，希望大家要用到的时候能想起来有这么一些东西。\n下面以最经典的数据库之一 MySQL 的语法为例，其实很多语法和函数其他的数据库也是支持的。\ngroup_concat 在我们平常的工作中，使用group by进行分组的场景，是非常多的。\n比如想统计出用户表中，名称不同的用户的具体名称有哪些？\n具体sql如下：\nselect name from `user` group by name; 但如果想把name相同的code拼接在一起，放到另外一列中该怎么办呢？\n答：使用group_concat函数。\n例如：\nselect name,group_concat(code) from `user` group by name; 使用group_concat函数，可以轻松的把分组后，name相同的数据拼接到一起，组成一个字符串，用逗号分隔。\nchar_length 有时候我们需要获取字符的长度，然后根据字符的长度进行排序。\nMYSQL给我们提供了一些有用的函数，比如：char_length。\n通过该函数就能获取字符长度。\n获取字符长度并且排序的sql如下：\nselect * from brand where name like \u0026#39;%苏三%\u0026#39; order by char_length(name) asc limit 5; name字段使用关键字模糊查询之后，再使用char_length函数获取name字段的字符长度，然后按长度升序。\nlocate 有时候我们在查找某个关键字，比如：苏三，需要明确知道它在某个字符串中的位置时，该怎么办呢？\n答：使用locate函数。\n使用locate函数改造之后sql如下：\nselect * from brand where name like \u0026#39;%苏三%\u0026#39; order by char_length(name) asc, locate(\u0026#39;苏三\u0026#39;,name) asc limit 5,5; 先按长度排序，小的排在前面。如果长度相同，则按关键字从左到右进行排序，越靠左的越排在前面。\n除此之外，我们还可以使用：instr和position函数，它们的功能跟locate函数类似，在这里就不一一介绍了。\nreplace 我们经常会有替换字符串中部分内容的需求，比如：将字符串中的字符A替换成B。\n这种情况就能使用replace函数。\n例如：\nupdate brand set name=REPLACE(name,\u0026#39;A\u0026#39;,\u0026#39;B\u0026#39;) where id=1; 这样就能轻松实现字符替换功能。\n也能用该函数去掉前后空格：\nupdate brand set name=REPLACE(name,\u0026#39; \u0026#39;,\u0026#39;\u0026#39;) where name like \u0026#39; %\u0026#39;; update brand set name=REPLACE(name,\u0026#39; \u0026#39;,\u0026#39;\u0026#39;) where name like \u0026#39;% \u0026#39;; 使用该函数还能替换json格式的数据内容，真的非常有用。\nnow 时间是个好东西，用它可以快速缩小数据范围，我们经常有获取当前时间的需求。\n在MYSQL中获取当前时间，可以使用now()函数，例如：\nselect now() from brand limit 1; 它会包含年月日时分秒。\n如果你还想返回毫秒，可以使用now(3)，例如：\nselect now(3) from brand limit 1; insert into \u0026hellip; select 在工作中很多时候需要插入数据。\n传统的插入数据的sql是这样的：\nINSERT INTO `brand`(`id`, `code`, `name`, `edit_date`) VALUES (5, \u0026#39;108\u0026#39;, \u0026#39;苏三\u0026#39;, \u0026#39;2022-09-02 19:42:21\u0026#39;); 它主要是用于插入少量并且已经确定的数据。但如果有大批量的数据需要插入，特别是是需要插入的数据来源于，另外一张表或者多张表的结果集中。\n这种情况下，使用传统的插入数据的方式，就有点束手无策了。\n这时候就能使用MYSQL提供的：insert into \u0026hellip; select语法。\n例如：\nINSERT INTO `brand`(`id`, `code`, `name`, `edit_date`) select null,code,name,now(3) from `order` where code in (\u0026#39;004\u0026#39;,\u0026#39;005\u0026#39;); 这样就能将order表中的部分数据，非常轻松插入到brand表中。\ninsert into \u0026hellip; ignore 不知道你有没有遇到过这样的场景：在插入1000个品牌之前，需要先根据name，判断一下是否存在。如果存在，则不插入数据。如果不存在，才需要插入数据。\n如果直接这样插入数据：\nINSERT INTO `brand`(`id`, `code`, `name`, `edit_date`) VALUES (123, \u0026#39;108\u0026#39;, \u0026#39;苏三\u0026#39;, now(3)); 肯定不行，因为brand表的name字段创建了唯一索引，同时该表中已经有一条name等于苏三的数据了。\n这就需要在插入之前加一下判断。\n当然很多人通过在sql语句后面拼接not exists语句，也能达到防止出现重复数据的目的，比如：\nINSERT INTO `brand`(`id`, `code`, `name`, `edit_date`) select null,\u0026#39;108\u0026#39;, \u0026#39;苏三\u0026#39;,now(3) from dual where not exists (select * from `brand` where name=\u0026#39;苏三\u0026#39;); 这条sql确实能够满足要求，但是总觉得有些麻烦。那么，有没有更简单的做法呢？\n答：可以使用insert into ... ignore语法。\n例如：\nINSERT ignore INTO `brand`(`id`, `code`, `name`, `edit_date`) VALUES (123, \u0026#39;108\u0026#39;, \u0026#39;苏三\u0026#39;, now(3)); 这样改造之后，如果brand表中没有name为苏三的数据，则可以直接插入成功。\n但如果brand表中已经存在name为苏三的数据了，则该sql语句也能正常执行，并不会报错。因为它会忽略异常，返回的执行结果影响行数为0，它不会重复插入数据。\nselect \u0026hellip; for update MYSQL数据库自带了悲观锁，它是一种排它锁，根据锁的粒度从大到小分为：表锁、间隙锁和行锁。\n在我们的实际业务场景中，有些情况并发量不太高，为了保证数据的正确性，使用悲观锁也可以。\n比如：用户扣减积分，用户的操作并不集中。但也要考虑系统自动赠送积分的并发情况，所以有必要加悲观锁限制一下，防止出现积分加错的情况发生。\n这时候就可以使用MYSQL中的select ... for update语法了。\n例如：\nbegin; select * from `user` where id=1 for update; //业务逻辑处理 update `user` set score=score-1 where id=1; commit; 这样在一个事务中使用for update锁住一行记录，其他事务就不能在该事务提交之前，去更新那一行的数据。\n需要注意的是for update前的id条件，必须是表的主键或者唯一索引，不然行锁可能会失效，有可能变成表锁。\non duplicate key update 通常情况下，我们在插入数据之前，一般会先查询一下，该数据是否存在。如果不存在，则插入数据。如果已存在，则不插入数据，而直接返回结果。\n在没啥并发量的场景中，这种做法是没有什么问题的。但如果插入数据的请求，有一定的并发量，这种做法就可能会产生重复的数据。\n当然防止重复数据的做法很多，比如：加唯一索引、加分布式锁等。\n但这些方案，都没法做到让第二次请求也更新数据，它们一般会判断已经存在就直接返回了。\n这种情况可以使用on duplicate key update语法。\n该语法会在插入数据之前判断，如果主键或唯一索引不存在，则插入数据。如果主键或唯一索引存在，则执行更新操作。\n具体需要更新的字段可以指定，例如：\nINSERT INTO `brand`(`id`, `code`, `name`, `edit_date`) VALUES (123, \u0026#39;108\u0026#39;, \u0026#39;苏三\u0026#39;, now(3)) on duplicate key update name=\u0026#39;苏三\u0026#39;,edit_date=now(3); 这样一条语句就能轻松搞定需求，既不会产生重复数据，也能更新最新的数据。\n但需要注意的是，在高并发的场景下使用on duplicate key update语法，可能会存在死锁的问题，所以要根据实际情况酌情使用。\nshow create table 有时候，我们想快速查看某张表的字段情况，通常会使用desc命令，比如：\ndesc `order`; 确实能够看到order表中的字段名称、字段类型、字段长度、是否允许为空，是否主键、默认值等信息。\n但看不到该表的索引信息，如果想看创建了哪些索引，该怎么办呢？\n答：使用show index命令。\n比如：\nshow index from `order`; 也能查出该表所有的索引，但查看字段和索引数据呈现方式，总觉得有点怪怪的，有没有一种更直观的方式？\n答：这就需要使用show create table命令了。\n例如：\nshow create table `order`; 我们能够看到非常完整的建表语句，表名、字段名、字段类型、字段长度、字符集、主键、索引、执行引擎等都能看到。\n非常直接明了。\ncreate table \u0026hellip; select 有时候，我们需要快速备份表。\n通常情况下，可以分两步走：\n创建一张临时表 将数据插入临时表 创建临时表可以使用命令：\ncreate table order_2022121819 like `order`; 创建成功之后，就会生成一张名称叫：order_2022121819，表结构跟order一模一样的新表，只是该表的数据为空而已。\n接下来使用命令：\ninsert into order_2022121819 select * from `order`; 执行之后就会将order表的数据插入到order_2022121819表中，也就是实现数据备份的功能。\n但有没有命令，一个命令就能实现上面这两步的功能呢？\n答：用create table \u0026hellip; select命令。\n例如：\ncreate table order_2022121820 select * from `order`; 执行完之后，就会将order_2022121820表创建好，并且将order表中的数据自动插入到新创建的order_2022121820中。\n一个命令就能轻松搞定表备份。\nexplain 很多时候，我们优化一条sql语句的性能，需要查看索引执行情况。\n答：可以使用explain命令，查看mysql的执行计划，它会显示索引的使用情况。\n例如：\nexplain select * from `order` where code=\u0026#39;002\u0026#39;; 通过这几列可以判断索引使用情况，执行计划包含列的含义如所示：\nid（select唯一标识） select_type（select类型） table（表名称） partitions（匹配的分区） type（连接类型） possible_keys（可能的索引选择） key（实际用到的索引） key_len（实际索引长度） ref（与索引比较的列） rows（预计要检查的行数） filtered（按表条件过滤的行百分比） Extra（附加信息） 说实话，sql语句没有走索引，排除没有建索引之外，最大的可能性是索引失效了。\n下面说说索引失效的常见原因：\n不满足最左前缀原则 范围索引列没有放最后 使用了select * 索引列上有计算 索引列上使用了函数 字符类型没加引号 用is null 和 is neot null 没注意字段是否允许为空 like查询左边有% 使用or关键字时没有注意 如果不是上面的这些原因，则需要再进一步排查一下其他原因。\nshow processlist 有些时候我们线上sql或者数据库出现了问题。比如出现了数据库连接过多问题，或者发现有一条sql语句的执行时间特别长。\n这时候该怎么办呢？\n答：我们可以使用show processlist命令查看当前线程执行情况。\n从执行结果中，我们可以查看当前的连接状态，帮助识别出有问题的查询语句。\nid 线程id User 执行sql的账号 Host 执行sql的数据库的ip和端号 db 数据库名称 Command 执行命令，包括：Daemon、Query、Sleep等。 Time 执行sql所消耗的时间 State 执行状态 info 执行信息，里面可能包含sql信息。 如果发现了异常的sql语句，可以直接kill掉，确保数据库不会出现严重的问题。\nmysqldump 有时候我们需要导出 MYSQL 表中的数据。\n这种情况就可以使用mysqldump工具，该工具会将数据查出来，转换成insert语句，写入到某个文件中，相当于数据备份。\n我们获取到该文件，然后执行相应的insert语句，就能创建相关的表，并且写入数据了，这就相当于数据还原。\nmysqldump命令的语法为：mysqldump -h主机名 -P端口 -u用户名 -p密码 参数1,参数2\u0026hellip;. \u0026gt; 文件名称.sql\n备份远程数据库中的数据库：\nmysqldump -h 192.22.25.226 -u root -p123456 dbname \u0026gt; backup.sql ","permalink":"https://lesanouo.github.io/blog/posts/code/168805440001/","summary":"\u003cp\u003e本篇文章分享网上看到的一些非常有用的 SQL 语句，并不复杂，希望大家要用到的时候能想起来有这么一些东西。\u003c/p\u003e\n\u003cp\u003e下面以最经典的数据库之一 MySQL 的语法为例，其实很多语法和函数其他的数据库也是支持的。\u003c/p\u003e","title":"一些简单好用的SQL语法"},{"content":"从数组中删除重复项 const numbers = [1, 1, 20, 3, 3, 3, 9, 9]; const uniqueNumbers = [...new Set(numbers)]; // -\u0026gt; [1, 20, 3, 9] 在 JavaScript 中，Set 是一个集合，它允许你仅存储唯一值。这意味着删除任何重复的值\n展开运算符\u0026hellip;将任何可迭代对象转换为数组\n较短的 If-Else 的空合并 let maybeSomething; // LONG FORM if(maybeSomething){ console.log(maybeSomething) } else { console.log(\u0026#34;Nothing found\u0026#34;) } // SHORTHAND console.log(maybeSomething ?? \u0026#34;Nothing found\u0026#34;) nullish合并操作 ??，如果没有定义左侧返回右侧。如果是，则返回左侧\n防止崩溃的可选链 const student = { name: \u0026#34;Matt\u0026#34;, age: 27, address: { state: \u0026#34;New York\u0026#34; }, }; // LONG FORM console.log(student \u0026amp;\u0026amp; student.address \u0026amp;\u0026amp; student.address.ZIPCode); // Doesn\u0026#39;t exist - Returns undefined // SHORTHAND console.log(student?.address?.ZIPCode); // Doesn\u0026#39;t exist - Returns undefined 在未定义属性时使用可选链运算符，undefined将返回而不是错误。这可以防止你的代码崩溃\n在没有第三个变量的情况下交换两个变量 let x = 1; let y = 2; // LONGER FORM let temp = x; x = y; y = temp; // SHORTHAND [x, y] = [y, x]; 在 JavaScript 中，你可以使用解构从数组中拆分值\n将任何值转换为布尔值 !!true // true !!2 // true !![] // true !!\u0026#34;Test\u0026#34; // true !!false // false !!0 // false !!\u0026#34;\u0026#34; // false 在 JavaScript 中，你可以使用 !! 在 JS 中将任何内容转换为布尔值\n扩展运算符 const nums1 = [1, 2, 3]; const nums2 = [4, 5, 6]; // LONG FORM let newArray = nums1.concat(nums2); // SHORTHAND newArray = [...nums1, ...nums2]; 使用扩展运算符组合两个数组\nlet numbers = [1, 2, 3]; // LONGER FORM numbers.push(4); numbers.push(5); // SHORTHAND numbers = [...numbers, 4, 5]; 也可以使用此语法代替将值推送到数组\n传播解构 const student = { name: \u0026#34;Matt\u0026#34;, age: 23, city: \u0026#34;Helsinki\u0026#34;, state: \u0026#34;Finland\u0026#34;, }; // LONGER FORM const name = student.name; const age = student.age; const address = { city: student.city, state: student.state }; // SHORTHAND const { name, age, ...address } = student; 使用扩展运算符将剩余元素分配给变量\n使用 \u0026amp;\u0026amp; 进行短路评估 var isReady = true; function doSomething(){ console.log(\u0026#34;Yay!\u0026#34;); } // LONGER FORM if(isReady){ doSomething(); } // SHORTHAND isReady \u0026amp;\u0026amp; doSomething(); 不必用if语句检查某事是否为真，你可以使用\u0026amp;\u0026amp;运算符\n类固醇的字符串 const age = 41; const sentence = `I\u0026#39;m ${age} years old`; // result: I\u0026#39;m 41 years old 通过将字符串包装在反引号内并${}用于嵌入值，从而在字符串之间插入变量\n从数组中查找特定元素 const fruits = [ { type: \u0026#34;Banana\u0026#34;, color: \u0026#34;Yellow\u0026#34; }, { type: \u0026#34;Apple\u0026#34;, color: \u0026#34;Green\u0026#34; } ]; // LONGER FORM let yellowFruit; for (let i = 0; i \u0026lt; fruits.length; ++i) { if (fruits[i].color === \u0026#34;Yellow\u0026#34;) { yellowFruit = fruits[i]; } } // SHORTHAND yellowFruit = fruits.find((fruit) =\u0026gt; fruit.color === \u0026#34;Yellow\u0026#34;); 使用find()方法查找匹配特定条件的元素\n对象属性赋值 const name = \u0026#34;Luis\u0026#34;, city = \u0026#34;Paris\u0026#34;, age = 43, favoriteFood = \u0026#34;Spaghetti\u0026#34;; // LONGER FORM const person = { name: name, city: city, age: age, favoriteFood: favoriteFood }; // SHORTHAND const person = { name, city, age, favoriteFood }; 你是否希望对象键与值具有相同的名称？你可以省略对象文字来执行此操作\n压缩 For 循环 const numbers = [1, 2, 3, 4, 5]; // LONGER FORM for(let i = 0; i \u0026lt; numbers.length; i++){ console.log(numbers[i]); } // SHORTHAND numbers.forEach(number =\u0026gt; console.log(number)); 使用内置forEach()方法通过一行代码循环遍历数组\n默认功能参数 // LONG FORM function pickUp(fruit) { if(fruit === undefined){ console.log(\u0026#34;I picked up a Banana\u0026#34;); } else { console.log(`I picked up a ${fruit}`); } } // SHORTHAND function pickUp(fruit = \u0026#34;Banana\u0026#34;) { console.log(`I picked up a ${fruit}`) } pickUp(\u0026#34;Mango\u0026#34;); // -\u0026gt; I picked up a Mango pickUp(); // -\u0026gt; I picked up a Banana 可以为函数参数提供默认值\n将对象的值收集到数组中 const info = { name: \u0026#34;Matt\u0026#34;, country: \u0026#34;Finland\u0026#34;, age: 35 }; // LONGER FORM let data = []; for (let key in info) { data.push(info[key]); } // SHORTHAND const data = Object.values(info); Object.values()将对象的所有值收集到一个新数组中\n检查一个项目是否存在于数组中 let numbers = [1, 2, 3]; // LONGER FORM const hasNumber1 = numbers.indexOf(1) \u0026gt; -1 // -\u0026gt; True // SHORTHAND/CLEANER APPROACH const hasNumber1 = numbers.includes(1) // -\u0026gt; True 可以使用 includes() 方法，而不是使用 indexOf() 方法来检查元素是否在数组中\n压缩多个条件 const num = 1; // LONGER FORM if(num == 1 || num == 2 || num == 3){ console.log(\u0026#34;Yay\u0026#34;); } // SHORTHAND if([1,2,3].includes(num)){ console.log(\u0026#34;Yay\u0026#34;); } 避免使用长|| 检查多个条件链，你可以使用你刚刚在上一个技巧中学到的东西——即，使用 includes() 方法\n指数运算符 // LONGER FORM Math.pow(4,2); // 16 Math.pow(2,3); // 8 // SHORTHAND 4**2 // 16 2**3 // 8 Math.floor() 简写 // LONG FORM Math.floor(5.25) // -\u0026gt; 5.0 // SHORTHAND ~~5.25 // -\u0026gt; 5.0 用一行代码分配多个值 let num1, num2; // LONGER FORM num1 = 10; num2 = 100; // SHORTHAND [num1, num2] = [10, 100]; student = { name: \u0026#34;Matt\u0026#34;, age: 29, }; // LONGER FORM let name = student.name; let age = student.age; // SHORTHAND let { name, age } = student; 从url获取参数并转为对象 const getParameters = URL =\u0026gt; JSON.parse(`{\u0026#34;${decodeURI(URL.split(\u0026#34;?\u0026#34;)[1]).replace(/\u0026#34;/g, \u0026#39;\\\\\u0026#34;\u0026#39;).replace(/\u0026amp;/g, \u0026#39;\u0026#34;,\u0026#34;\u0026#39;).replace(/=/g, \u0026#39;\u0026#34;:\u0026#34;\u0026#39;)}\u0026#34;}` ) getParameters(\u0026#34;https://www.google.com.hk/search?q=js+md\u0026amp;newwindow=1\u0026#34;); // {q: \u0026#39;js+md\u0026#39;, newwindow: \u0026#39;1\u0026#39;} 检查对象是否为空 const isEmpty = obj =\u0026gt; Reflect.ownKeys(obj).length === 0 \u0026amp;\u0026amp; obj.constructor === Object; isEmpty({}) // true isEmpty({a:\u0026#34;not empty\u0026#34;}) //false 反转字符串 const reverse = str =\u0026gt; str.split(\u0026#39;\u0026#39;).reverse().join(\u0026#39;\u0026#39;); reverse(\u0026#39;this is reverse\u0026#39;); // esrever si siht 生成随机十六进制 const randomHexColor = () =\u0026gt; `#${Math.floor(Math.random() * 0xffffff).toString(16).padEnd(6, \u0026#34;0\u0026#34;)}` console.log(randomHexColor()); // #a2ce5b 检查当前选项卡是否在后台 const isTabActive = () =\u0026gt; !document.hidden; isTabActive() // true|false 检测元素是否处于焦点 const elementIsInFocus = (el) =\u0026gt; (el === document.activeElement); elementIsInFocus(anyElement) // 元素处于焦点返回true，反之返回false 检查设备类型 const judgeDeviceType = () =\u0026gt; /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|OperaMini/i.test(navigator.userAgent) ? \u0026#39;Mobile\u0026#39; : \u0026#39;PC\u0026#39;; judgeDeviceType() // PC | Mobile 文字复制到剪贴板 const copyText = async (text) =\u0026gt; await navigator.clipboard.writeText(text) copyText(\u0026#39;单行代码 前端世界\u0026#39;) 获取选定的文本 const getSelectedText = () =\u0026gt; window.getSelection().toString(); getSelectedText(); 查询某天是否为工作日 const isWeekday = (date) =\u0026gt; date.getDay() % 6 !== 0; isWeekday(new Date(2022, 03, 11)) 转换华氏/摄氏 // 华氏温度转换为摄氏温度 const fahrenheitToCelsius = (fahrenheit) =\u0026gt; (fahrenheit - 32) * 5/9; fahrenheitToCelsius(50); // 10 // 摄氏温度转华氏温度 const celsiusToFahrenheit = (celsius) =\u0026gt; celsius * 9/5 + 32; celsiusToFahrenheit(100) // 212 两日期之间相差的天数 const dayDiff = (date1, date2) =\u0026gt; Math.ceil(Math.abs(date1.getTime() - date2.getTime()) / 86400000); dayDiff(new Date(\u0026#34;2021-10-21\u0026#34;), new Date(\u0026#34;2022-02-12\u0026#34;)) // Result: 114 将 RGB 转换为十六进制 const rgbToHex = (r, g, b) =\u0026gt; \u0026#34;#\u0026#34; + ((1 \u0026lt;\u0026lt; 24) + (r \u0026lt;\u0026lt; 16) + (g \u0026lt;\u0026lt; 8) + b).toString(16).slice(1); rgbToHex(255, 255, 255); // #ffffff 计算数组平均值 const average = (arr) =\u0026gt; arr.reduce((a, b) =\u0026gt; a + b) / arr.length; average([1,9,18,36]) //16 ","permalink":"https://lesanouo.github.io/blog/posts/snippet/js/","summary":"\u003ch2 id=\"从数组中删除重复项\"\u003e从数组中删除重复项\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kr\"\u003econst\u003c/span\u003e \u003cspan class=\"nx\"\u003enumbers\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e20\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e3\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e3\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e3\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e9\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e9\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kr\"\u003econst\u003c/span\u003e \u003cspan class=\"nx\"\u003euniqueNumbers\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e[...\u003c/span\u003e\u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"nx\"\u003eSet\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003enumbers\u003c/span\u003e\u003cspan class=\"p\"\u003e)];\u003c/span\u003e \u003cspan class=\"c1\"\u003e// -\u0026gt; [1, 20, 3, 9]\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在 JavaScript 中，Set 是一个集合，它允许你仅存储唯一值。这意味着删除任何重复的值\u003c/p\u003e\n\u003cp\u003e展开运算符\u0026hellip;将任何可迭代对象转换为数组\u003c/p\u003e\n\u003ch2 id=\"较短的-if-else-的空合并\"\u003e较短的 If-Else 的空合并\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003elet\u003c/span\u003e \u003cspan class=\"nx\"\u003emaybeSomething\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// LONG FORM\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003emaybeSomething\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"nx\"\u003econsole\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003elog\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003emaybeSomething\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"nx\"\u003econsole\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003elog\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;Nothing found\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// SHORTHAND\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"nx\"\u003econsole\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003elog\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003emaybeSomething\u003c/span\u003e \u003cspan class=\"o\"\u003e??\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;Nothing found\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003enullish合并操作 ??，如果没有定义左侧返回右侧。如果是，则返回左侧\u003c/p\u003e","title":"JavaScript 代码片段"},{"content":"Maven添加profiles profiles 标签 \u0026lt;!-- 环境控制 --\u0026gt; \u0026lt;profiles\u0026gt; \u0026lt;!-- 开发 --\u0026gt; \u0026lt;profile\u0026gt; \u0026lt;id\u0026gt;dev\u0026lt;/id\u0026gt; \u0026lt;activation\u0026gt; \u0026lt;!--默认激活配置--\u0026gt; \u0026lt;activeByDefault\u0026gt;true\u0026lt;/activeByDefault\u0026gt; \u0026lt;/activation\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;!--当前环境--\u0026gt; \u0026lt;profile.name\u0026gt;dev\u0026lt;/profile.name\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;/profile\u0026gt; \u0026lt;!-- 生产 --\u0026gt; \u0026lt;profile\u0026gt; \u0026lt;id\u0026gt;prod\u0026lt;/id\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;!--当前环境--\u0026gt; \u0026lt;profile.name\u0026gt;prod\u0026lt;/profile.name\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;/profile\u0026gt; \u0026lt;/profiles\u0026gt; 打包添加resources \u0026lt;!-- 打包 --\u0026gt; \u0026lt;build\u0026gt; ...... \u0026lt;resources\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;src/main/resources\u0026lt;/directory\u0026gt; \u0026lt;filtering\u0026gt;true\u0026lt;/filtering\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;src/main/java\u0026lt;/directory\u0026gt; \u0026lt;includes\u0026gt; \u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt; \u0026lt;include\u0026gt;**/*.json\u0026lt;/include\u0026gt; \u0026lt;include\u0026gt;**/*.ftl\u0026lt;/include\u0026gt; \u0026lt;/includes\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;/resources\u0026gt; \u0026lt;/build\u0026gt; 创建对应文件 分别创建 application.yml 、 application-dev.yml 、 application-prod.yml 文件，dev、prod中写入需要需要区分环境的配置\napplication.yml选中对应环境配置文件 spring: profiles: active: \u0026#39;@profile.name@\u0026#39; ","permalink":"https://lesanouo.github.io/blog/posts/snippet/springboot/","summary":"\u003ch2 id=\"maven添加profiles\"\u003eMaven添加profiles\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eprofiles 标签\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-xml\" data-lang=\"xml\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c\"\u003e\u0026lt;!-- 环境控制 --\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nt\"\u003e\u0026lt;profiles\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"c\"\u003e\u0026lt;!-- 开发 --\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"nt\"\u003e\u0026lt;profile\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nt\"\u003e\u0026lt;id\u0026gt;\u003c/span\u003edev\u003cspan class=\"nt\"\u003e\u0026lt;/id\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nt\"\u003e\u0026lt;activation\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"c\"\u003e\u0026lt;!--默认激活配置--\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"nt\"\u003e\u0026lt;activeByDefault\u0026gt;\u003c/span\u003etrue\u003cspan class=\"nt\"\u003e\u0026lt;/activeByDefault\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nt\"\u003e\u0026lt;/activation\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nt\"\u003e\u0026lt;properties\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"c\"\u003e\u0026lt;!--当前环境--\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"nt\"\u003e\u0026lt;profile.name\u0026gt;\u003c/span\u003edev\u003cspan class=\"nt\"\u003e\u0026lt;/profile.name\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nt\"\u003e\u0026lt;/properties\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"nt\"\u003e\u0026lt;/profile\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"c\"\u003e\u0026lt;!-- 生产 --\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"nt\"\u003e\u0026lt;profile\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nt\"\u003e\u0026lt;id\u0026gt;\u003c/span\u003eprod\u003cspan class=\"nt\"\u003e\u0026lt;/id\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nt\"\u003e\u0026lt;properties\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"c\"\u003e\u0026lt;!--当前环境--\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"nt\"\u003e\u0026lt;profile.name\u0026gt;\u003c/span\u003eprod\u003cspan class=\"nt\"\u003e\u0026lt;/profile.name\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nt\"\u003e\u0026lt;/properties\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"nt\"\u003e\u0026lt;/profile\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nt\"\u003e\u0026lt;/profiles\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e打包添加resources\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-xml\" data-lang=\"xml\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c\"\u003e\u0026lt;!-- 打包 --\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nt\"\u003e\u0026lt;build\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        ......\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"nt\"\u003e\u0026lt;resources\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nt\"\u003e\u0026lt;resource\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"nt\"\u003e\u0026lt;directory\u0026gt;\u003c/span\u003esrc/main/resources\u003cspan class=\"nt\"\u003e\u0026lt;/directory\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"nt\"\u003e\u0026lt;filtering\u0026gt;\u003c/span\u003etrue\u003cspan class=\"nt\"\u003e\u0026lt;/filtering\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nt\"\u003e\u0026lt;/resource\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nt\"\u003e\u0026lt;resource\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"nt\"\u003e\u0026lt;directory\u0026gt;\u003c/span\u003esrc/main/java\u003cspan class=\"nt\"\u003e\u0026lt;/directory\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"nt\"\u003e\u0026lt;includes\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                    \u003cspan class=\"nt\"\u003e\u0026lt;include\u0026gt;\u003c/span\u003e**/*.xml\u003cspan class=\"nt\"\u003e\u0026lt;/include\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                    \u003cspan class=\"nt\"\u003e\u0026lt;include\u0026gt;\u003c/span\u003e**/*.json\u003cspan class=\"nt\"\u003e\u0026lt;/include\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                    \u003cspan class=\"nt\"\u003e\u0026lt;include\u0026gt;\u003c/span\u003e**/*.ftl\u003cspan class=\"nt\"\u003e\u0026lt;/include\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"nt\"\u003e\u0026lt;/includes\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nt\"\u003e\u0026lt;/resource\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"nt\"\u003e\u0026lt;/resources\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nt\"\u003e\u0026lt;/build\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e创建对应文件\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e分别创建 \u003ccode\u003eapplication.yml\u003c/code\u003e 、 \u003ccode\u003eapplication-dev.yml\u003c/code\u003e 、 \u003ccode\u003eapplication-prod.yml\u003c/code\u003e 文件，dev、prod中写入需要需要区分环境的配置\u003c/p\u003e","title":"SpringBoot 代码片段"},{"content":"前言 在日常开发中，经常需要用到 Java 8 的Lambda表达式，它允许把函数作为一个方法的参数，让我们的代码更优雅、更简洁。本文主要总结收集一些常用的Lambda表达式的使用。\nlist转map List\u0026lt;UserInfo\u0026gt; userInfoList = new ArrayList\u0026lt;\u0026gt;(); userInfoList.add(new UserInfo(1L, \u0026#34;hello\u0026#34;, 18)); userInfoList.add(new UserInfo(2L, \u0026#34;world\u0026#34;, 27)); userInfoList.add(new UserInfo(2L, \u0026#34;!\u0026#34;, 26)); /** * list 转 map * 使用Collectors.toMap的时候，如果有可以重复会报错，所以需要加(k1, k2) -\u0026gt; k1 * (k1, k2) -\u0026gt; k1 表示，如果有重复的key,则保留第一个，舍弃第二个 */ Map\u0026lt;Long, UserInfo\u0026gt; userInfoMap = userInfoList.stream().collect(Collectors.toMap(UserInfo::getUserId, userInfo -\u0026gt; userInfo, (k1, k2) -\u0026gt; k1)); userInfoMap.values().forEach(a-\u0026gt;System.out.println(a.getUserName())); 类似的，还有Collectors.toList()、Collectors.toSet()，表示把对应的流转化为list或者Set。\nfilter()过滤 List\u0026lt;UserInfo\u0026gt; userInfoList = new ArrayList\u0026lt;\u0026gt;(); userInfoList.add(new UserInfo(1L, \u0026#34;hello\u0026#34;, 18)); userInfoList.add(new UserInfo(2L, \u0026#34;world\u0026#34;, 27)); userInfoList.add(new UserInfo(2L, \u0026#34;!\u0026#34;, 26)); /** * filter 过滤，留下超过18岁的用户 */ List\u0026lt;UserInfo\u0026gt; userInfoResultList = userInfoList.stream().filter(user -\u0026gt; user.getAge() \u0026gt; 18).collect(Collectors.toList()); userInfoResultList.forEach(a -\u0026gt; System.out.println(a.getUserName())); foreach遍历 /** * forEach 遍历集合List列表 */ List\u0026lt;String\u0026gt; userNameList = Arrays.asList(\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;, \u0026#34;!\u0026#34;); userNameList.forEach(System.out::println); /** * forEach 遍历集合Map */ HashMap\u0026lt;String, String\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;(); hashMap.put(\u0026#34;key1\u0026#34;, \u0026#34;hello\u0026#34;); hashMap.put(\u0026#34;key2\u0026#34;, \u0026#34;world\u0026#34;); hashMap.put(\u0026#34;key3\u0026#34;, \u0026#34;!\u0026#34;); hashMap.forEach((k, v) -\u0026gt; System.out.println(k + \u0026#34;:\\t\u0026#34; + v)); groupingBy分组 Map\u0026lt;String, List\u0026lt;UserInfo\u0026gt;\u0026gt; result = originUserInfoList.stream() .collect(Collectors.groupingBy(UserInfo::getCity)); sorted+Comparator 排序 /** * sorted + Comparator.comparing 排序列表， */ userInfoList = userInfoList.stream().sorted(Comparator.comparing(UserInfo::getAge)).collect(Collectors.toList()); userInfoList.forEach(a -\u0026gt; System.out.println(a.toString())); /** * 如果想降序排序，则可以使用加reversed() */ userInfoList = userInfoList.stream().sorted(Comparator.comparing(UserInfo::getAge).reversed()).collect(Collectors.toList()); userInfoList.forEach(a -\u0026gt; System.out.println(a.toString())); distinct去重 List\u0026lt;String\u0026gt; list = Arrays.asList(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;F\u0026#34;, \u0026#34;A\u0026#34;, \u0026#34;C\u0026#34;); List\u0026lt;String\u0026gt; temp = list.stream().distinct().collect(Collectors.toList()); temp.forEach(System.out::println); findFirst 返回第一个 List\u0026lt;String\u0026gt; list = Arrays.asList(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;F\u0026#34;, \u0026#34;A\u0026#34;, \u0026#34;C\u0026#34;); list.stream().findFirst().ifPresent(System.out::println); anyMatch是否至少匹配一个元素 Stream\u0026lt;String\u0026gt; stream = Stream.of(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;D\u0026#34;); boolean match = stream.anyMatch(s -\u0026gt; s.contains(\u0026#34;C\u0026#34;)); System.out.println(match); //输出 true allMatch 匹配所有元素 Stream\u0026lt;String\u0026gt; stream = Stream.of(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;D\u0026#34;); boolean match = stream.allMatch(s -\u0026gt; s.contains(\u0026#34;C\u0026#34;)); System.out.println(match); //输出 false map转换 List\u0026lt;String\u0026gt; list = Arrays.asList(\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;); //转化为大写 List\u0026lt;String\u0026gt; upperCaselist = list.stream().map(String::toUpperCase).collect(Collectors.toList()); upperCaselist.forEach(System.out::println); Reduce int sum = Stream.of(1, 2, 3, 4).reduce(0, (a, b) -\u0026gt; a + b); System.out.println(sum); peek 打印个日志 peek()方法是一个中间Stream操作，有时候我们可以使用peek来打印日志。\nList\u0026lt;String\u0026gt; result = Stream.of(\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;, \u0026#34;!\u0026#34;) .filter(a -\u0026gt; a.contains(\u0026#34;hello\u0026#34;)) .peek(a -\u0026gt; System.out.println(\u0026#34;say:\u0026#34; + a)).collect(Collectors.toList()); System.out.println(result); Max，Min最大最小 Optional\u0026lt;UserInfo\u0026gt; maxAgeUserInfoOpt = userInfoList.stream().max(Comparator.comparing(UserInfo::getAge)); maxAgeUserInfoOpt.ifPresent(userInfo -\u0026gt; System.out.println(\u0026#34;max age user:\u0026#34; + userInfo)); Optional\u0026lt;UserInfo\u0026gt; minAgeUserInfoOpt = userInfoList.stream().min(Comparator.comparing(UserInfo::getAge)); minAgeUserInfoOpt.ifPresent(userInfo -\u0026gt; System.out.println(\u0026#34;min age user:\u0026#34; + userInfo)); count统计 long count = userInfoList.stream().filter(user -\u0026gt; user.getAge() \u0026gt; 18).count(); System.out.println(\u0026#34;大于18岁的用户:\u0026#34; + count); 常用函数式接口 其实lambda离不开函数式接口，我们来看下JDK8常用的几个函数式接口：\nFunction\u0026lt;T, R\u0026gt;（转换型）: 接受一个输入参数，返回一个结果 Consumer\u0026lt;T\u0026gt; （消费型）: 接收一个输入参数，并且无返回操作 Predicate\u0026lt;T\u0026gt; （判断型）: 接收一个输入参数，并且返回布尔值结果 Supplier\u0026lt;T\u0026gt; （供给型）: 无参数，返回结果 Function\u0026lt;T, R\u0026gt; Function\u0026lt;T, R\u0026gt;是一个功能转换型的接口，可以把将一种类型的数据转化为另外一种类型的数据\nFunction\u0026lt;String, Integer\u0026gt; function = String::length; Stream\u0026lt;String\u0026gt; stream = Stream.of(\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;, \u0026#34;!\u0026#34;); Stream\u0026lt;Integer\u0026gt; resultStream = stream.map(function); resultStream.forEach(System.out::println); Consumer\u0026lt;T\u0026gt; Consumer\u0026lt;T\u0026gt;是一个消费性接口，通过传入参数，并且无返回的操作\nConsumer\u0026lt;String\u0026gt; comsumer = System.out::println; Stream\u0026lt;String\u0026gt; stream = Stream.of(\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;, \u0026#34;!\u0026#34;); stream.forEach(comsumer); Predicate\u0026lt;T\u0026gt; Predicate\u0026lt;T\u0026gt;是一个判断型接口,并且返回布尔值结果\n//获取每个字符串的长度，并且返回 Predicate\u0026lt;Integer\u0026gt; predicate = a -\u0026gt; a \u0026gt; 18; UserInfo userInfo = new UserInfo(2L, \u0026#34;hello\u0026#34;, 27); System.out.println(predicate.test(userInfo.getAge())); Supplier\u0026lt;T\u0026gt; Supplier\u0026lt;T\u0026gt;是一个供给型接口,无参数，有返回结果\nSupplier\u0026lt;Integer\u0026gt; supplier = () -\u0026gt; Integer.valueOf(\u0026#34;666\u0026#34;); System.out.println(supplier.get()); ","permalink":"https://lesanouo.github.io/blog/posts/code/166999680001/","summary":"\u003ch2 id=\"前言\"\u003e前言\u003c/h2\u003e\n\u003cp\u003e在日常开发中，经常需要用到 \u003ccode\u003eJava 8\u003c/code\u003e 的\u003ccode\u003eLambda\u003c/code\u003e表达式，它允许把函数作为一个方法的参数，让我们的代码更优雅、更简洁。本文主要总结收集一些常用的\u003ccode\u003eLambda\u003c/code\u003e表达式的使用。\u003c/p\u003e","title":"Java中Lambda表达式学习"},{"content":"前言 Function 函数式接口\nSupplier供给型函数 Consumer消费型函数 Runnable无参无返回型函数 Function函数的表现形式为接收一个参数，并返回一个值。Supplier、Consumer和Runnable可以看作Function的一种特殊表现形式 优化代码\n处理抛出异常的if 处理if分支操作 如果存在值执行消费操作，否则执行基于空的操作 在开发过程中经常会使用if...else...进行判断抛出异常、分支处理等操作。这些if...else...充斥在代码中严重影响了代码代码的美观，这时我们可以利用Java 8的Function接口来消灭if...else...。\nFunction 函数式接口 使用注解@FunctionalInterface标识，并且只包含一个抽象方法的接口是函数式接口。函数式接口主要分为Supplier供给型函数、Consumer消费型函数、Runnable无参无返回型函数和Function有参有返回型函数。\nSupplier供给型函数 Supplier的表现形式为不接受参数、只返回数据\nConsumer消费型函数 Consumer消费型函数和Supplier刚好相反。Consumer接收一个参数，没有返回值\nRunnable无参无返回型函数 Runnable的表现形式为即没有参数也没有返回值\nFunction函数 Function函数的表现形式为接收一个参数，并返回一个值。Supplier、Consumer和Runnable可以看作Function的一种特殊表现形式\n代码优化 处理抛出异常的if 定义函数 定义一个抛出异常的形式的函数式接口, 这个接口只有参数没有返回值是个消费型接口\n/** * 抛异常接口 **/ @FunctionalInterface public interface ThrowExceptionFunction { /** * 抛出异常信息 **/ void throwMessage(String message); } 编写判断方法 创建工具类VUtils并创建一个isTure方法，方法的返回值为刚才定义的函数式接口-ThrowExceptionFunction。ThrowExceptionFunction的接口实现逻辑为当参数b为true时抛出异常\n/** * 如果参数为true抛出异常 **/ public static ThrowExceptionFunction isTure(boolean b){ return (errorMessage) -\u0026gt; { if (b){ throw new RuntimeException(errorMessage); } }; } 使用方式 调用工具类参数参数后，调用函数式接口的throwMessage方法传入异常信息\n// 当出入的参数为false时正常执行 VUtils.isTure(false).throwMessage(\u0026#34;error\u0026#34;); // 当出入的参数为true时抛出异常 VUtils.isTure(true).throwMessage(\u0026#34;error\u0026#34;); 处理if分支操作 定义函数式接口 创建一个名为BranchHandle的函数式接口，接口的参数为两个Runnable接口。这两个两个Runnable接口分别代表了为true或false时要进行的操作\n/** * 分支处理接口 **/ @FunctionalInterface public interface BranchHandle { /** * 分支操作 **/ void trueOrFalseHandle(Runnable trueHandle, Runnable falseHandle); } 编写判断方法 创建一个名为isTureOrFalse的方法，方法的返回值为刚才定义的函数式接口-BranchHandle\n/** * 参数为true或false时，分别进行不同的操作 **/ public static BranchHandle isTureOrFalse(boolean b){ return (trueHandle, falseHandle) -\u0026gt; { if (b){ trueHandle.run(); } else { falseHandle.run(); } }; } 使用方式 VUtils.isTureOrFalse(true) .trueOrFalseHandle(()-\u0026gt;{ System.out.println(\u0026#34;true\u0026#34;); // 参数为true时，执行trueHandle }, ()-\u0026gt;{ System.out.println(\u0026#34;false\u0026#34;); // 参数为false时，执行falseHandle }); 参数为false时，执行falseHandle 定义函数 创建一个名为PresentOrElseHandler的函数式接口，接口的参数一个为Consumer接口。一个为Runnable,分别代表值不为空时执行消费操作和值为空时执行的其他操作\n/** * 空值与非空值分支处理 */ public interface PresentOrElseHandler\u0026lt;T extends Object\u0026gt; { /** * 值不为空时执行消费操作 * 值为空时执行其他的操作 **/ void presentOrElseHandle(Consumer\u0026lt;? super T\u0026gt; action, Runnable emptyAction); } 编写判断方法 创建一个名为isBlankOrNoBlank的方法，方法的返回值为刚才定义的函数式接口-PresentOrElseHandler\n/** * 参数为true或false时，分别进行不同的操作 **/ public static PresentOrElseHandler\u0026lt;?\u0026gt; isBlankOrNoBlank(String str){ return (consumer, runnable) -\u0026gt; { if (str == null || str.length() == 0){ runnable.run(); } else { consumer.accept(str); } }; } 使用方式 调用工具类参数参数后，调用函数式接口的presentOrElseHandle方法传入一个Consumer和Runnable\n// 参数不为空时，打印参数 VUtils.isBlankOrNoBlank(\u0026#34;hello\u0026#34;) .presentOrElseHandle(System.out::println,()-\u0026gt;{ System.out.println(\u0026#34;blank\u0026#34;); }); // 参数不为空时 VUtils.isBlankOrNoBlank(\u0026#34;\u0026#34;) .presentOrElseHandle(System.out::println,()-\u0026gt;{ System.out.println(\u0026#34;blank\u0026#34;); }); ","permalink":"https://lesanouo.github.io/blog/posts/code/166991040001/","summary":"\u003ch2 id=\"前言\"\u003e前言\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003eFunction\u003c/code\u003e 函数式接口\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eSupplier\u003c/code\u003e供给型函数\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eConsumer\u003c/code\u003e消费型函数\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eRunnable\u003c/code\u003e无参无返回型函数\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eFunction\u003c/code\u003e函数的表现形式为接收一个参数，并返回一个值。\u003ccode\u003eSupplier\u003c/code\u003e、\u003ccode\u003eConsumer\u003c/code\u003e和\u003ccode\u003eRunnable\u003c/code\u003e可以看作\u003ccode\u003eFunction\u003c/code\u003e的一种特殊表现形式\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e优化代码\u003c/p\u003e","title":"Java中Function接口学习"},{"content":"本片文章记录个人安装CentOS7在台式主机上作为小型服务器\n制作U盘启动盘 1. iso镜像下载 可以通过阿里云镜像站下载iso文件，本人下载的是CentOS-7-x86_64-DVD-2009.iso\n2. 下载启动盘制作软件 可以通过软件UltraISO进行启动盘制作\n打开软件 -\u0026gt; 点击左上角文件 -\u0026gt; 选择打开 -\u0026gt; 打开对应iso 点击菜单栏启动 -\u0026gt; 选择写入硬盘镜像 选择对应U盘 -\u0026gt; 其余参数可默认 安装CentOS7 1. 插入U盘到主机 2. 配置 Bios 制作U盘启动 3. 选择对应U盘后即可开始安装 注意事项 通过UltraISO刻入后安装会报错，无法正常安装 选择Install CentOS 7时按下TAB键，屏幕下方会出现一串文字 vmlinuz initrd=initrd.img inst.stage2=hd:LABEL=CentOS\\x207\\x20x86_64 rd.live.check quiet\n将上述文字改为vmlinuz initrd=initrd.img linux dd quiet然后键入回车查看设备名称\n查看U盘启动盘的名称比如：sda，sdb，sdc。 ps：label一列会显示Centos7等字样的\n重启后到第一步界面按下TAB键\n将vmlinuz initrd=initrd.img inst.stage2=hd:LABEL=CentOS\\x207\\x20x86_64 rd.live.check quiet 改为 vmlinuz initrd=initrd.img inst.stage2=hd:/dev/sda4 quiet ps：sda4就是你看到的启动盘名称\n开始正常CentOS 7安装配置\n","permalink":"https://lesanouo.github.io/blog/posts/code/166982400001/","summary":"\u003cp\u003e本片文章记录个人安装CentOS7在台式主机上作为小型服务器\u003c/p\u003e\n\u003ch2 id=\"制作u盘启动盘\"\u003e制作U盘启动盘\u003c/h2\u003e\n\u003ch3 id=\"1-iso镜像下载\"\u003e1. iso镜像下载\u003c/h3\u003e\n\u003cp\u003e可以通过\u003ca href=\"https://mirrors.aliyun.com/centos/7/isos/x86_64/\"\u003e阿里云镜像站\u003c/a\u003e下载iso文件，本人下载的是\u003ccode\u003eCentOS-7-x86_64-DVD-2009.iso\u003c/code\u003e\u003c/p\u003e\n\u003ch3 id=\"2-下载启动盘制作软件\"\u003e2. 下载启动盘制作软件\u003c/h3\u003e\n\u003cp\u003e可以通过软件\u003ca href=\"https://cn.ultraiso.net/xiazai.html\"\u003eUltraISO\u003c/a\u003e进行启动盘制作\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e打开软件 -\u0026gt; 点击左上角\u003ccode\u003e文件\u003c/code\u003e -\u0026gt; 选择\u003ccode\u003e打开\u003c/code\u003e -\u0026gt; 打开对应iso\u003c/li\u003e\n\u003cli\u003e点击菜单栏\u003ccode\u003e启动\u003c/code\u003e -\u0026gt; 选择\u003ccode\u003e写入硬盘镜像\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e选择对应U盘 -\u0026gt; 其余参数可默认\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"安装centos7\"\u003e安装CentOS7\u003c/h2\u003e\n\u003ch3 id=\"1-插入u盘到主机\"\u003e1. 插入U盘到主机\u003c/h3\u003e\n\u003ch3 id=\"2-配置-bios-制作u盘启动\"\u003e2. 配置 Bios 制作U盘启动\u003c/h3\u003e\n\u003ch3 id=\"3-选择对应u盘后即可开始安装\"\u003e3. 选择对应U盘后即可开始安装\u003c/h3\u003e\n\u003ch3 id=\"注意事项\"\u003e注意事项\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e通过UltraISO刻入后安装会报错，无法正常安装\u003c/li\u003e\n\u003c/ul\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e选择\u003ccode\u003eInstall CentOS 7\u003c/code\u003e时按下TAB键，屏幕下方会出现一串文字\n\u003ccode\u003evmlinuz initrd=initrd.img inst.stage2=hd:LABEL=CentOS\\x207\\x20x86_64 rd.live.check quiet\u003c/code\u003e\u003c/p\u003e","title":"CentOS7系统安装"},{"content":"简介 链式编程可以使得代码可读性高，链式编程的原理就是通过return this返回一个this对象，就是返回本身，达到链式效果。\n实现链式编程 通过return this public class Book { private String bookId; private String title; private String cover; public String getBookId() { return bookId; } public Book setBookId(String bookId) { this.bookId = bookId; // 返回当前对象 return this; } public String getTitle() { return title; } public Book setTitle(String title) { this.title = title; // 返回当前对象 return this; } public String getCover() { return cover; } public Book setCover(String cover) { this.cover = cover; // 返回当前对象 return this; } } 代码比较简单，就是一个图书的模型，将三个字段的Set方法都返回了对象本身。\n链式调用：\nBook book = new Book().setBookId(\u0026#34;b.001\u0026#34;).setTitle(\u0026#34;庆余年\u0026#34;).setCover(\u0026#34;http://localhost/qyn.jpg\u0026#34;); 静态初始化方法of 目前Spring中有很多方法提供了静态of方法，可以更方便的创建对象，结合return this将更为实用的实现链式编程，算是一种比较不错得扩展措施。在这种模式中，大量的使用了of替代了构造函数。\npublic class Pageable { // 页码，从1开始 private long page; // 页大小 private int size; // 结果命中数量 private long count; private Pageable(long page, int size) { this.page = page; this.size = size; } private Pageable(long page, int size, long count) { this(page, size); this.count = count; } // PageRequest时使用 public static Pageable of(long page, int size) { return of(page, size, 0); } // 返回结果时，具有命中数量及返回总页码计算使用 public static Pageable of(long page, int size, long count) { return new Pageable(page, size, count); } // 分页时，获取偏移量 public long getOffset() { return (page - 1) * size; } // 返回总页码 public long getPageCount() { return (long) Math.ceil((double) count / size); } public long getPage() { return this.page; } public int getSize() { return this.size; } public long getCount() { return this.count; } } 上面示例中的分页工具类，只实现了三个成员变量页码、页大小、条目数，并且未实现成员变量的Set方法；构造方法全部为私有，实现了静态的of方法来创建分页对象。在该对象中同时提供了获取分页偏移量的getOffset方法，以及计算出总页码的getPageCount方法。\n该工具一般有两种使用场景:\n数据库查询后，返回数据列表以及分页信息，此时需要页码、页大小、条目数三个信息，使用及实现都比较方便 内存分页时，可以提供一个分页偏移量的计算方法 Pageable pageable = Pageable.of(10, 10, 123); System.out.println(pageable.getOffset()); System.out.println(pageable.getPageCount()); 如果采用FastJson进行序列化，上述设计方式也能够满足返回JSON的需求，FastJson按照Get方法进行生成属性列表。\nSystem.out.println(JSON.toJSONString(Pageable.of(10, 10, 123))); Builder模式 Builder模式也是目前较为常用的一种链式编程方法，目前Spring中有大量的依据此模式进行的编码。以最为常见的ResponseEntity(或者Swagger模块也大量采用了此类方法)类来看，其内部定义了Builder接口，并默认实现了一个DefaultBuild内部类，内部方法采用return this实现链式模式，同时在ResponseEntity中提供了类似的Builder方法，如ok、status等静态方法。\n从这些类的实现原理看，实现Builder模式也比较简单，一方面创建一个内部Builder类，实现相应信息的创建；同时在目标类中，实现一个静态的builder方法，用于创建Builder对象，并启动链式模式；最后再由内部类提供一个终止方法，该终止方法将完成目标类的创建。\npublic class ApiInfo { private String name; private String description; private String url; private Map\u0026lt;String, String\u0026gt; params; public String getName() { return name; } public void setName(String name) { this.name = name; } public String getDescription() { return description; } public void setDescription(String description) { this.description = description; } public String getUrl() { return url; } public void setUrl(String url) { this.url = url; } public Map\u0026lt;String, String\u0026gt; getParams() { return params; } public void setParams(Map\u0026lt;String, String\u0026gt; params) { this.params = params; } @Override public String toString() { return \u0026#34;ApiInfo{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, description=\u0026#39;\u0026#34; + description + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, url=\u0026#39;\u0026#34; + url + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, params=\u0026#34; + params + \u0026#39;}\u0026#39;; } public static ApiBuilder builder() { return new ApiBuilder(); } // 内部Builder类 public static class ApiBuilder { private String name; private String description; private String url; private Map\u0026lt;String, String\u0026gt; params; // name信息设置，链式 public ApiBuilder name(String name) { this.name = name; return this; } // 注释信息设置 public ApiBuilder description(String description) { this.description = description; return this; } public ApiBuilder url(String url) { this.url = url; return this; } // 参数信息设置 public ApiBuilder params(String name, String description) { this.params = Optional.ofNullable(params).orElseGet(() -\u0026gt; Maps.newHashMap()); this.params.put(name, description); return this; } // 创建ApiInfo对象 public ApiInfo build() { ApiInfo apiInfo = new ApiInfo(); apiInfo.setName(this.name); apiInfo.setDescription(this.description); apiInfo.setUrl(this.url); apiInfo.setParams(this.params); return apiInfo; } } } 上述示例采用Builder模式实现了一个Api接口信息的对象设计，主要是能够设置接口名、地址以及相应的参数。内部设计了一个ApiBuilder，可以实现链式属性设置，并最终提供一个build方法用于终止时创建目标实例。\nApiInfo apiInfo = ApiInfo.builder().name(\u0026#34;获取资源信息\u0026#34;) .description(\u0026#34;根据资源ID获取资源信息\u0026#34;) .url(\u0026#34;/resource/:id\u0026#34;) .params(\u0026#34;id\u0026#34;, \u0026#34;资源唯一ID\u0026#34;) .params(\u0026#34;token\u0026#34;, \u0026#34;令牌\u0026#34;) .build(); lombok简化链式编程 链式编程比较简单，一般也就是return、静态of、Builder几种模式，可以直接编码实现，Spring以及一些开源项目Swagger等等都是这么做的。如果我们不是为了做一个通用的开源产品，只是业务性的编码，此时不需要通过大量的编码去实现链式编程，可以采用lombok进行实现，使用也比较简单。\n使用lombok时，可以通过maven引入，也可以通过idea安装插件的方式引入。\nreturn 链式 仍然使用此前的例子Book类，进行改造，采用lombok注解进行编码。\nlombok实现return this链式，只需要在类添加注释@Accessors(chain = true)即可实现\n@Data @Accessors(chain = true) public class Book { private String bookId; private String title; private String cover; public static void main(String[] args) { Book book = new Book().setBookId(\u0026#34;b.001\u0026#34;).setTitle(\u0026#34;庆余年\u0026#34;).setCover(\u0026#34;http://localhost/qyn.jpg\u0026#34;); System.out.println(book); } } 如果在IDE中，查看类接口(ctrl+o)，可以发现属性的Set方法，返回类型为Book，和自己编码的方案一致。\nBook book = new Book().setBookId(\u0026#34;b.001\u0026#34;).setTitle(\u0026#34;庆余年\u0026#34;).setCover(\u0026#34;http://localhost/qyn.jpg\u0026#34;); 静态初始化方法of 对Pageable类进行改造，使用lombok实现of方法。\n静态of方法的添加，需要通过lombok的构造函数注解进行添加，RequiredArgsConstructor可以实现必备参数列表的构造，并通过staticname指定静态方法为of；针对上例中的Pageable对象提供了两种静态构造方法，一种是只需要指定页码和页大小即可，还有一种是全部参数的构造函数，可以计算总页码；RequiredArgsConstructor可以实现必备参数的构造；AllArgsConstructor实现全部参数的构造函数，并指定staticName为of，通过lombok的注解组合，实现Pageable与上例自己编码同等效果。\n@Data @Accessors(chain = true) @RequiredArgsConstructor(staticName = \u0026#34;of\u0026#34;) @AllArgsConstructor(staticName = \u0026#34;of\u0026#34;) public class Pageable { /** * 页码，从1开始 */ @NonNull private long page; /** * 页大小 */ @NonNull private int size; /** * 结果命中数量 */ private long count; /** * 分页时，获取偏移量 */ public long getOffset() { return (page - 1) * size; } /** * 返回总页码 */ public long getPageCount() { return (long) Math.ceil((double) count / size); } } 通过组合注释实现了同样的效果，使用也和原有编码效果等同。\nPageable pageable = Pageable.of(10, 10); System.out.println(pageable.getOffset()); // 全部构造 System.out.println(JSON.toJSONString(Pageable.of(10, 10, 123))); Builder模式 对ApiInfo进行改造，使用lombok实现builder模式。\nlombok实现Builder模式，只要添加@Builder注解即可\n@Data @Builder public class ApiInfo { private String name; private String description; private String url; private Map\u0026lt;String, String\u0026gt; params; } 使用上和之前的例子差不多，不过对于params默认只能是Set的形式。\nApiInfo apiInfo = ApiInfo.builder().name(\u0026#34;获取资源信息\u0026#34;) .description(\u0026#34;根据资源ID获取资源信息\u0026#34;) .url(\u0026#34;/resource/:id\u0026#34;) .params(new HashMap\u0026lt;String, String\u0026gt;() { { put(\u0026#34;id\u0026#34;, \u0026#34;资源唯一ID\u0026#34;); put(\u0026#34;token\u0026#34;, \u0026#34;令牌\u0026#34;); } }) .build(); ","permalink":"https://lesanouo.github.io/blog/posts/code/166973760001/","summary":"\u003ch2 id=\"简介\"\u003e简介\u003c/h2\u003e\n\u003cp\u003e链式编程可以使得代码可读性高，链式编程的原理就是通过\u003ccode\u003ereturn this\u003c/code\u003e返回一个this对象，就是返回本身，达到链式效果。\u003c/p\u003e\n\u003ch2 id=\"实现链式编程\"\u003e实现链式编程\u003c/h2\u003e\n\u003ch3 id=\"通过return-this\"\u003e通过\u003ccode\u003ereturn this\u003c/code\u003e\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kd\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eBook\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003eprivate\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eString\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ebookId\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003eprivate\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eString\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003etitle\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003eprivate\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eString\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ecover\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eString\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003egetBookId\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ebookId\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eBook\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003esetBookId\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eString\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ebookId\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003ebookId\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ebookId\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"c1\"\u003e// 返回当前对象\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eString\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003egetTitle\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003etitle\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eBook\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003esetTitle\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eString\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003etitle\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003etitle\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003etitle\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"c1\"\u003e// 返回当前对象\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eString\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003egetCover\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ecover\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eBook\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003esetCover\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eString\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ecover\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003ecover\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ecover\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"c1\"\u003e// 返回当前对象\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e代码比较简单，就是一个图书的模型，将三个字段的Set方法都返回了对象本身。\u003c/p\u003e","title":"Java中链式编程学习"},{"content":"Nginx配置http代理非常简单，网上教程也很多，但是无法很方便的配置https代理，本片文章将记录搭建可以同时代理http和https的服务器。\n准备工作 首先我们得需要下载Nginx及第三方模块ngx_http_proxy_connect_module\nwget http://nginx.org/download/nginx-1.18.0.tar.gz wget https://github.com/chobits/ngx_http_proxy_connect_module/archive/master.zip 值得注意的是，ngx_http_proxy_connect_module第三方模块与Nginx 有版本对应关系，需要在其官网确定版本对应关系。\n安装程序 将刚刚下好的程序进行解压安装\n#解压Nginx tar -zxvf nginx-1.18.0.tar.gz #解压ngx_http_proxy_connect_module unzip master.zip cd nginx-1.18.0 #打补丁，版本需注意 patch -p1 \u0026lt; /path/to/ngx_http_proxy_connect_module/patch/proxy_connect.patch #执行编译命令 ./configure --prefix=/usr/share/nginx --add-module=/path/to/ngx_http_proxy_connect_module make \u0026amp;\u0026amp; make install 配置 Nginx 正向代理 配置nginx.conf，在http模块添加如下配置即可\nserver {\rresolver 114.114.114.114 ipv6=off; #DNS配置\rresolver_timeout 10s;\rlisten 8888;\rproxy_connect; #启用 CONNECT HTTP方法\rproxy_connect_allow 443 80; #指定代理CONNECT方法可以连接的端口号或范围的列表\rproxy_connect_connect_timeout 20s; #定义客户端与代理服务器建立连接的超时时间\rproxy_connect_read_timeout 20s; #定义客户端从代理服务器读取响应的超时时间\rproxy_connect_send_timeout 20s; #设置客户端将请求传输到代理服务器的超时时间\rlocation / {\rproxy_pass $scheme://$http_host$request_uri;\r}\r} 配置客户端代理服务器 Linux 打开/etc/profile文件，在最下面添加如下配置即可\n#http代理，ip是nginx的ip，端口是nginx配置的监听端口\rexport http_proxy=\u0026#34;http://ip:8888\u0026#34;\r#https代理\rexport https_proxy=\u0026#34;http://ip:8888\u0026#34;\r#不需要代理的ip,访问这些ip，不会走代理\rexport no_proxy=\u0026#34;127.0.0.1, localhost\u0026#34; 为Nginx配置systemctl 创建一个nginx.service 在 /usr/lib/systemd/system/ 目录下面新建一个nginx.service文件，并赋予可执行的权限：\nchmod +x /usr/lib/systemd/system/nginx.service\n编辑service内容 vim /usr/lib/systemd/system/nginx.service\n[Unit] //对服务的说明\rDescription=nginx - high performance web server //描述服务\rAfter=network.target remote-fs.target nss-lookup.target //描述服务类别\r[Service] //服务的一些具体运行参数的设置\rType=forking //后台运行的形式\rPIDFile=/usr/local/nginx/logs/nginx.pid //PID文件的路径\rExecStartPre=/usr/local/nginx/sbin/nginx -t -c /usr/local/nginx/conf/nginx.conf //启动准备\rExecStart=/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf //启动命令\rExecReload=/usr/local/nginx/sbin/nginx -s reload //重启命令\rExecStop=/usr/local/nginx/sbin/nginx -s stop //停止命令\rExecQuit=/usr/local/nginx/sbin/nginx -s quit //快速停止\rPrivateTmp=true //给服务分配临时空间\r[Install]\rWantedBy=multi-user.target //服务用户的模式 启动服务 在启动服务之前，需要先重载systemctl命令 systemctl daemon-reload systemctl start nginx.service ","permalink":"https://lesanouo.github.io/blog/posts/code/166939200012/","summary":"\u003cp\u003e\u003ccode\u003eNginx\u003c/code\u003e配置\u003ccode\u003ehttp\u003c/code\u003e代理非常简单，网上教程也很多，但是无法很方便的配置\u003ccode\u003ehttps\u003c/code\u003e代理，本片文章将记录搭建可以同时代理\u003ccode\u003ehttp\u003c/code\u003e和\u003ccode\u003ehttps\u003c/code\u003e的服务器。\u003c/p\u003e","title":"Nginx配置Http和Https正向代理"},{"content":"Redis 作为21世纪最流行的缓存中间件，它也能够实现接口限流的作用，本片文章主要记录个人实现过程。\n在分布式高并发系统中，常常需要用到 缓存 、降级 、 限流。\n缓存：缓存的目的是提升系统访问速度和增大系统处理容量 降级：降级是当服务出现问题或者影响到核心流程时，需要暂时屏蔽掉，待高峰或者问题解决后再打开 限流：限流的目的是通过对并发访问/请求进行限速，或者对一个时间窗口内的请求进行限速来保护系统，一旦达到限制速率则可以拒绝服务、排队或等待、降级等处理 准备工作 Maven 添加依赖 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-redis\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 方式2需要用到 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-aop\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 安装 Redis 本文就不多赘述这一部分了 QAQ\nSpring Boot 中集成 Redis 1. 在application配置文件中配置Redis # Redis数据库索引（默认为0） spring.redis.database=0 # Redis服务器地址 spring.redis.host=127.0.0.1 # Redis服务器连接端口 spring.redis.port=6379 # Redis服务器连接密码（默认为空） spring.redis.password= # 连接超时时间（毫秒） spring.redis.timeout=1000 # 连接池最大连接数（使用负值表示没有限制） spring.redis.jedis.pool.max-active=20 # 连接池最大阻塞等待时间（使用负值表示没有限制） spring.redis.jedis.pool.max-wait=-1 # 连接池中的最大空闲连接 spring.redis.jedis.pool.max-idle=10 # 连接池中的最小空闲连接 spring.redis.jedis.pool.min-idle=0 2. 配置RedisTemplate @Configuration @EnableCaching public class RedisConfig extends CachingConfigurerSupport { /** * RedisTemplate相关配置 * 使redis支持插入对象 */ @Bean public RedisTemplate\u0026lt;String, Object\u0026gt; redisTemplate(RedisConnectionFactory factory) { RedisTemplate\u0026lt;String, Object\u0026gt; template = new RedisTemplate\u0026lt;\u0026gt;(); // 配置连接工厂 template.setConnectionFactory(factory); // 设置key的序列化器 template.setKeySerializer(new StringRedisSerializer()); // 设置value的序列化器 //使用Jackson 2，将对象序列化为JSON Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class); //Json转对象类，不设置默认的会将Json转成HashMap ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om); template.setValueSerializer(jackson2JsonRedisSerializer); return template; } } 自此，Spring Boot 已完成集成Redis，可以通过依赖注入使用RedisTemplate，如下所示：\n@Autowired private RedisTemplate\u0026lt;String, Object\u0026gt; redisTemplate; 实现限流（方式1） 1. 限流思路 编写自定义注解，为后续过滤接口提供标识 通过IP+方法名作为key，访问次数作为value的方式对某一用户的请求进行标识 每次访问的时候判断key是否存在，count是否超过限制的次数 若访问超出限制，则通过拦截器直接返回错误信息：请求过于频繁 2. 添加自定义注解 AccessLimit @Inherited @Documented @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) public @interface AccessLimit { /** * 请求次数的指定时间范围 : 秒数(redis数据过期时间) */ int second() default 60; /** * 指定second 时间内 : API请求次数 */ int maxCount() default 3; } 3. 编写拦截器 @Slf4j @Component public class AccessLimitInterceptor implements HandlerInterceptor { @Autowired private RedisTemplate\u0026lt;String, Object\u0026gt; redisTemplate; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { // Handler 是否为 HandlerMethod 实例 if (handler instanceof HandlerMethod) { HandlerMethod handlerMethod = (HandlerMethod) handler; // 获取方法 Method method = handlerMethod.getMethod(); // 是否有AccessLimit注解 if (!method.isAnnotationPresent(AccessLimit.class)) { return true; } // 获取注解内容信息 AccessLimit accessLimit = method.getAnnotation(AccessLimit.class); if (accessLimit == null) { return true; } // 获取次数和超时 int seconds = accessLimit.second(); int maxCount = accessLimit.maxCount(); // 存储key String key = IpUtil.getIpAddr(request)+method.getName(); // 从Redis中获取用户已经访问的次数 try { Integer count = (Integer) redisTemplate.opsForValue().get(key); System.out.println(\u0026#34;已经访问的次数:\u0026#34; + count); // Redis不存在用户访问记录 if (null == count || -1 == count) { redisTemplate.opsForValue().set(key, 1, seconds, TimeUnit.SECONDS); return true; } if (count \u0026lt; maxCount) { // 访问次数+1 redisTemplate.opsForValue().increment(key); return true; } if (count \u0026gt;= maxCount) { // 超出访问限制 response.setContentType(\u0026#34;application/json;charset=UTF-8\u0026#34;); OutputStream out = response.getOutputStream(); out.write(\u0026#34;请求过于频繁请稍后再试\u0026#34;.getBytes(\u0026#34;UTF-8\u0026#34;)); out.flush(); out.close(); log.warn(\u0026#34;请求过于频繁请稍后再试\u0026#34;); return false; } }catch (RedisConnectionFailureException e){ log.error(\u0026#34;redis error\u0026#34; + e.getMessage().toString()); return true; } } return true; } } 4. 注册拦截器 @Configuration public class IntercepterConfig implements WebMvcConfigurer { @Autowired private AccessLimitInterceptor accessLimitInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(accessLimitInterceptor) .addPathPatterns(\u0026#34;/**\u0026#34;) // 拦截路径 .excludePathPatterns(\u0026#34;/user/login\u0026#34;); // 不拦截路径 } } 5. 通过AccessLimit注解测试最终效果 @RestController public class TestController { @AccessLimit(second = 60,maxCount = 5) @GetMapping(\u0026#34;test\u0026#34;) public String test(){ return \u0026#34;TEST\u0026#34;; } } 实现限流（方式2） 1. 限流注解 首先需要创建一个限流注解，限流将分为两种情况：\n针对当前接口的全局性限流，例如该接口可以在 1 分钟内访问 100 次。 针对某一个 IP 地址的限流，例如某个 IP 地址可以在 1 分钟内访问 100 次。 针对这两种情况，我们创建一个枚举类：\npublic enum LimitType { /** * 默认策略全局限流 */ DEFAULT, /** * 根据请求者IP进行限流 */ IP } 下一步，创建限流注解：\n@Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface RateLimiter { /** * 限流key前缀 */ String key() default \u0026#34;rate_limit:\u0026#34;; /** * 限流时间,单位秒 */ int time() default 60; /** * 限流次数 */ int count() default 100; /** * 限流类型 */ LimitType limitType() default LimitType.DEFAULT; } 2. 定制 RedisTemplate 在 Spring Boot 中，我们其实更习惯使用 Spring Data Redis 来操作 Redis，不过默认的 RedisTemplate 有一个小坑，就是序列化用的是 JdkSerializationRedisSerializer，不知道小伙伴们有没有注意过，直接用这个序列化工具将来存到 Redis 上的 key 和 value 都会莫名其妙多一些前缀，这就导致你用命令读取的时候可能会出错。\n修改 RedisTemplate 序列化方案，代码如下：\n@Configuration public class RedisConfig { @Bean public RedisTemplate\u0026lt;Object, Object\u0026gt; redisTemplate(RedisConnectionFactory connectionFactory) { RedisTemplate\u0026lt;Object, Object\u0026gt; redisTemplate = new RedisTemplate\u0026lt;\u0026gt;(); redisTemplate.setConnectionFactory(connectionFactory); // 使用Jackson2JsonRedisSerialize 替换默认序列化(默认采用的是JDK序列化) Jackson2JsonRedisSerializer\u0026lt;Object\u0026gt; jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer\u0026lt;\u0026gt;(Object.class); ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om); redisTemplate.setKeySerializer(jackson2JsonRedisSerializer); redisTemplate.setValueSerializer(jackson2JsonRedisSerializer); redisTemplate.setHashKeySerializer(jackson2JsonRedisSerializer); redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer); return redisTemplate; } } 3. 开发 Lua 脚本 Redis 中的一些原子操作我们可以借助 Lua 脚本来实现，想要调用 Lua 脚本，我们有两种不同的思路：\n在 Redis 服务端定义好 Lua 脚本，然后计算出来一个散列值，在 Java 代码中，通过这个散列值锁定要执行哪个 Lua 脚本。 直接在 Java 代码中将 Lua 脚本定义好，然后发送到 Redis 服务端去执行。 Spring Data Redis 中也提供了操作 Lua 脚本的接口，还是比较方便的，所以我们这里就采用第二种方案。\n在 resources 目录下新建 lua 文件夹专门用来存放 lua 脚本，脚本内容如下：\nlocal key = KEYS[1] local count = tonumber(ARGV[1]) local time = tonumber(ARGV[2]) local current = redis.call(\u0026#39;get\u0026#39;, key) if current and tonumber(current) \u0026gt; count then return tonumber(current) end current = redis.call(\u0026#39;incr\u0026#39;, key) if tonumber(current) == 1 then redis.call(\u0026#39;expire\u0026#39;, key, time) end return tonumber(current) KEYS 和 ARGV 都是一会调用时候传进来的参数，tonumber 就是把字符串转为数字，redis.call 就是执行具体的 redis 指令，具体流程是这样：\n首先获取到传进来的 key 以及 限流的 count 和时间 time。 通过 get 获取到这个 key 对应的值，这个值就是当前时间窗内这个接口可以访问多少次。 如果是第一次访问，此时拿到的结果为 nil，否则拿到的结果应该是一个数字，所以接下来就判断， 如果拿到的结果是一个数字，并且这个数字还大于 count，那就说明已经超过流量限制了，那么直接返回查询的结果即可。 如果拿到的结果为 nil，说明是第一次访问，此时就给当前 key 自增 1，然后设置一个过期时间。 最后把自增 1 后的值返回就可以了。 接下来我们在一个 Bean 中来加载这段 Lua 脚本，如下：\n@Bean public DefaultRedisScript\u0026lt;Long\u0026gt; limitScript() { DefaultRedisScript\u0026lt;Long\u0026gt; redisScript = new DefaultRedisScript\u0026lt;\u0026gt;(); redisScript.setScriptSource(new ResourceScriptSource(new ClassPathResource(\u0026#34;lua/limit.lua\u0026#34;))); redisScript.setResultType(Long.class); return redisScript; } 4. 注解解析（通过AspectJ自定义切面） @Aspect @Component public class RateLimiterAspect { private static final Logger log = LoggerFactory.getLogger(RateLimiterAspect.class); @Autowired private RedisTemplate\u0026lt;Object, Object\u0026gt; redisTemplate; @Autowired private RedisScript\u0026lt;Long\u0026gt; limitScript; @Before(\u0026#34;@annotation(rateLimiter)\u0026#34;) public void doBefore(JoinPoint point, RateLimiter rateLimiter) throws Throwable { String key = rateLimiter.key(); int time = rateLimiter.time(); int count = rateLimiter.count(); String combineKey = getCombineKey(rateLimiter, point); List\u0026lt;Object\u0026gt; keys = Collections.singletonList(combineKey); try { Long number = redisTemplate.execute(limitScript, keys, count, time); if (number==null || number.intValue() \u0026gt; count) { throw new ServiceException(\u0026#34;访问过于频繁，请稍候再试\u0026#34;); } log.info(\u0026#34;限制请求\u0026#39;{}\u0026#39;,当前请求\u0026#39;{}\u0026#39;,缓存key\u0026#39;{}\u0026#39;\u0026#34;, count, number.intValue(), key); } catch (ServiceException e) { throw e; } catch (Exception e) { throw new RuntimeException(\u0026#34;服务器限流异常，请稍候再试\u0026#34;); } } public String getCombineKey(RateLimiter rateLimiter, JoinPoint point) { StringBuffer stringBuffer = new StringBuffer(rateLimiter.key()); if (rateLimiter.limitType() == LimitType.IP) { stringBuffer.append(IpUtils.getIpAddr(((ServletRequestAttributes) RequestContextHolder.currentRequestAttributes()).getRequest())).append(\u0026#34;-\u0026#34;); } MethodSignature signature = (MethodSignature) point.getSignature(); Method method = signature.getMethod(); Class\u0026lt;?\u0026gt; targetClass = method.getDeclaringClass(); stringBuffer.append(targetClass.getName()).append(\u0026#34;-\u0026#34;).append(method.getName()); return stringBuffer.toString(); } } 这个切面就是拦截所有加了 @RateLimiter 注解的方法，在前置通知中对注解进行处理。\n首先获取到注解中的 key、time 以及 count 三个参数。 获取一个组合的 key，所谓的组合的 key，就是在注解的 key 属性基础上，再加上方法的完整路径，如果是 IP 模式的话，就再加上 IP 地址。以 IP 模式为例，最终生成的 key 类似这样：rate_limit:127.0.0.1-com.demo.ratelimiter.controller.HelloController-hello（如果不是 IP 模式，那么生成的 key 中就不包含 IP 地址）。 将生成的 key 放到集合中。 通过 redisTemplate.execute 方法取执行一个 Lua 脚本，第一个参数是脚本所封装的对象，第二个参数是 key，对应了脚本中的 KEYS，后面是可变长度的参数，对应了脚本中的 ARGV。 将 Lua 脚本执行的结果与 count 进行比较，如果大于 count，就说明过载了，抛异常就行了。 5. 接口测试 @RestController public class HelloController { @GetMapping(\u0026#34;/hello\u0026#34;) @RateLimiter(time = 5,count = 3,limitType = LimitType.IP) public String hello() { return \u0026#34;hello\u0026gt;\u0026gt;\u0026gt;\u0026#34;+new Date(); } } 每一个 IP 地址，在 5 秒内只能访问 3 次。\n","permalink":"https://lesanouo.github.io/blog/posts/code/166939200011/","summary":"\u003cp\u003eRedis 作为21世纪最流行的缓存中间件，它也能够实现接口限流的作用，本片文章主要记录个人实现过程。\u003c/p\u003e\n\u003cp\u003e在分布式高并发系统中，常常需要用到 \u003ccode\u003e缓存\u003c/code\u003e 、\u003ccode\u003e降级\u003c/code\u003e 、 \u003ccode\u003e限流\u003c/code\u003e。\u003c/p\u003e","title":"SpringBoot+Redis实现接口限流"},{"content":"简介 基于 SpringBoot 平台开发的项目数不胜数，与常规的基于Spring开发的项目最大的不同之处，SpringBoot 里面提供了大量的注解用于快速开发，而且非常简单，基本可以做到开箱即用！\n注解总结 SpringMVC 相关注解 @Controller 通常用于修饰controller层的组件，由控制器负责将用户发来的URL请求转发到对应的服务接口，通常还需要配合注解@RequestMapping使用。\n@RequestMapping 提供路由信息，负责URL到Controller中具体函数的映射，当用于方法上时，可以指定请求协议，比如GET、POST、PUT、DELETE等等。\n@RequestBody 表示请求体的Content-Type必须为application/json格式的数据，接收到数据之后会自动将数据绑定到Java对象上去。\n@ResponseBody 表示该方法的返回结果直接写入HTTP response body中，返回数据的格式为application/json。\n比如，请求参数为json格式，返回参数也为json格式，示例代码如下：\n@Controller @RequestMapping(\u0026#34;api\u0026#34;) public class LoginController { /** * 登录请求，post请求协议，请求参数数据格式为json * @param request */ @RequestMapping(value = \u0026#34;login\u0026#34;, method = RequestMethod.POST) @ResponseBody public ResponseEntity login(@RequestBody UserLoginDTO request){ //...业务处理 return new ResponseEntity(HttpStatus.OK); } } @RestController 和@Controller一样，用于标注控制层组件，不同的地方在于：它是@ResponseBody和@Controller的合集，也就是说，在当@RestController用在类上时，表示当前类里面所有对外暴露的接口方法，返回数据的格式都为application/json。\n@RequestParam 用于接收请求参数为表单类型的数据，通常用在方法的参数前面，示范代码如下：\n@RequestMapping(value = \u0026#34;login\u0026#34;, method = RequestMethod.POST) @ResponseBody public ResponseEntity login(@RequestParam(value = \u0026#34;userName\u0026#34;,required = true) String userName, @RequestParam(value = \u0026#34;userPwd\u0026#34;,required = true) String userPwd){ //...业务处理 return new ResponseEntity(HttpStatus.OK); } @PathVariable 用于获取请求路径中的参数，通常用于restful风格的api上，示范代码如下：\n@RequestMapping(value = \u0026#34;queryProduct/{id}\u0026#34;, method = RequestMethod.POST) @ResponseBody public ResponseEntity queryProduct(@PathVariable(\u0026#34;id\u0026#34;) String id){ //...业务处理 return new ResponseEntity(HttpStatus.OK); } @GetMapping 除了@RequestMapping可以指定请求方式之外，还有一些其他的注解，可以用于标注接口路径请求，比如GetMapping用在方法上时，表示只支持get请求方法，等价于@RequestMapping(value=\u0026quot;/get\u0026quot;,method=RequestMethod.GET)。\n@PostMapping 用在方法上，表示只支持post方式的请求。\n@PutMapping 用在方法上，表示只支持put方式的请求，通常表示更新某些资源的意思。\n@DeleteMapping 用在方法上，表示只支持delete方式的请求，通常表示删除某些资源的意思。\nbean 相关注解 @Service 通常用于修饰service层的组件，声明一个对象，会将类对象实例化并注入到bean容器里面。\n@Component 泛指组件，当组件不好归类的时候，可以使用这个注解进行标注，功能类似于于@Service。\n@Repository 通常用于修饰dao层的组件，@Repository注解属于Spring里面最先引入的一批注解，它用于将数据访问层 (DAO层) 的类标识为Spring Bean，具体只需将该注解标注在DAO类上即可，示例代码如下：\n@Repository public interface RoleRepository extends JpaRepository\u0026lt;Role,Long\u0026gt; { //具体的方法 } 为什么现在使用的很少呢？\n主要是因为当我们配置服务启动自动扫描dao层包时，Spring会自动帮我们创建一个实现类，然后注入到bean容器里面。当某些类无法被扫描到时，我们可以显式的在数据持久类上标注@Repository注解，Spring会自动帮我们声明对象。\n@Bean 相当于 xml 中配置 Bean，意思是产生一个 bean 对象，并交给spring管理，示例代码如下：\n@Configuration public class AppConfig { //相当于 xml 中配置 Bean @Bean public Uploader initFileUploader() { return new FileUploader(); } } @Autowired 自动导入依赖的bean对象，默认时按照byType方式导入对象，而且导入的对象必须存在，当需要导入的对象并不存在时，我们可以通过配置required = false来关闭强制验证。\n@Resource 也是自动导入依赖的bean对象，由JDK提供，默认是按照byName方式导入依赖的对象；而@Autowired默认时按照byType方式导入对象，当然@Resource还可以配置成通过byType方式导入对象。\n/** * 通过名称导入（默认通过名称导入依赖对象） */ @Resource(name = \u0026#34;deptService\u0026#34;) private DeptService deptService; /** * 通过类型导入 */ @Resource(type = RoleRepository.class) private DeptService deptService; @Qualifier 当有多个同一类型的bean时，使用@Autowired导入会报错，提示当前对象并不是唯一，Spring不知道导入哪个依赖，这个时候，我们可以使用@Qualifier进行更细粒度的控制，选择其中一个候选者，一般于@Autowired搭配使用，示例如下：\n@Autowired @Qualifier(\u0026#34;deptService\u0026#34;) private DeptService deptService; @Scope 用于生命一个spring bean的作用域，作用的范围一共有以下几种：\nsingleton：唯一 bean 实例，Spring 中的 bean 默认都是单例的。 prototype：每次请求都会创建一个新的 bean 实例，对象多例。 request：每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。 session：每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。 /** * 单例对象 */ @RestController @Scope(\u0026#34;singleton\u0026#34;) public class HelloController { } 配置相关注解 @Configuration 表示声明一个 Java 形式的配置类，Spring Boot 提倡基于 Java 的配置，相当于你之前在 xml 中配置 bean，比如声明一个配置类AppConfig，然后初始化一个Uploader对象。\n@Configuration public class AppConfig { @Bean public Uploader initOSSUploader() { return new OSSUploader(); } } @EnableAutoConfiguration @EnableAutoConfiguration可以帮助Spring Boot应用将所有符合条件的@Configuration配置类，全部都加载到当前Spring Boot里，并创建对应配置类的Bean，并把该Bean实体交给IoC容器进行管理。\n某些场景下，如果我们想要避开某些配置类的扫描（包括避开一些第三方jar包下面的配置，可以这样处理。\n@Configuration @EnableAutoConfiguration(exclude = { org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration.class}) public class AppConfig { //具有业务方法 } @ComponentScan 标注哪些路径下的类需要被Spring扫描，用于自动发现和装配一些Bean对象，默认配置是扫描当前文件夹下和子目录下的所有类，如果我们想指定扫描某些包路径，可以这样处理。\n@ComponentScan(basePackages = {\u0026#34;com.xxx.a\u0026#34;, \u0026#34;com.xxx.b\u0026#34;, \u0026#34;com.xxx.c\u0026#34;}) @SpringBootApplication 等价于使用@Configuration、@EnableAutoConfiguration、@ComponentScan这三个注解，通常用于全局启动类上，示例如下：\n@SpringBootApplication public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } 把@SpringBootApplication换成@Configuration、@EnableAutoConfiguration、@ComponentScan这三个注解，一样可以启动成功，@SpringBootApplication只是将这三个注解进行了简化！\n@EnableTransactionManagement 表示开启事务支持，等同于 xml 配置方式的\u0026lt;tx:annotation-driven /\u0026gt;\n@Conditional 从 Spring4 开始，可以通过@Conditional注解实现按条件装载bean对象，目前 Spring Boot 源码中大量扩展了@Condition注解，用于实现智能的自动化配置，满足各种使用场景。下面我给大家列举几个常用的注解：\n@ConditionalOnBean：当某个特定的Bean存在时，配置生效 @ConditionalOnMissingBean：当某个特定的Bean不存在时，配置生效 @ConditionalOnClass：当Classpath里存在指定的类，配置生效 @ConditionalOnMissingClass：当Classpath里不存在指定的类，配置生效 @ConditionalOnExpression：当给定的SpEL表达式计算结果为true，配置生效 @ConditionalOnProperty：当指定的配置属性有一个明确的值并匹配，配置生效 具体的应用案例如下：\n@Configuration public class ConditionalConfig { /** * 当AppConfig对象存在时，创建一个A对象 */ @ConditionalOnBean(AppConfig.class) @Bean public A createA(){ return new A(); } /** * 当AppConfig对象不存在时，创建一个B对象 */ @ConditionalOnMissingBean(AppConfig.class) @Bean public B createB(){ return new B(); } /** * 当KafkaTemplate类存在时，创建一个C对象 */ @ConditionalOnClass(KafkaTemplate.class) @Bean public C createC(){ return new C(); } /** * 当KafkaTemplate类不存在时，创建一个D对象 */ @ConditionalOnMissingClass(KafkaTemplate.class) @Bean public D createD(){ return new D(); } /** * 当enableConfig的配置为true，创建一个E对象 */ @ConditionalOnExpression(\u0026#34;${enableConfig:false}\u0026#34;) @Bean public E createE(){ return new E(); } /** * 当filter.loginFilter的配置为true，创建一个F对象 */ @ConditionalOnProperty(prefix = \u0026#34;filter\u0026#34;,name = \u0026#34;loginFilter\u0026#34;,havingValue = \u0026#34;true\u0026#34;) @Bean public F createF(){ return new F(); } } @value 可以在任意 Spring 管理的 Bean 中通过这个注解获取任何来源配置的属性值，比如你在application.properties文件里，定义了一个参数变量！\nconfig.name=zhangsan\n在任意的bean容器里面，可以通过@Value注解注入参数，获取参数变量值。\n@RestController public class HelloController { @Value(\u0026#34;${config.name}\u0026#34;) private String config; @GetMapping(\u0026#34;config\u0026#34;) public String config(){ return JSON.toJSONString(config); } } @ConfigurationProperties 上面@Value在每个类中获取属性配置值的做法，其实是不推荐的。\n一般在企业项目开发中，不会使用那么杂乱无章的写法而且维护也麻烦，通常会一次性读取一个 Java 配置类，然后在需要使用的地方直接引用这个类就可以多次访问了，方便维护，示例如下：\n首先，在application.properties文件里定义好参数变量。\nconfig.name=demo_1 config.value=demo_value_1 然后，创建一个 Java 配置类，将参数变量注入即可！\n@Component @ConfigurationProperties(prefix = \u0026#34;config\u0026#34;) public class Config { public String name; public String value; //...get、set } 最后，在需要使用的地方，通过IOC注入Config对象即可！\n@PropertySource 这个注解是用来读取我们自定义的配置文件的，比如导入test.properties和bussiness.properties两个配置文件，用法如下：\n@SpringBootApplication @PropertySource(value = {\u0026#34;test.properties\u0026#34;,\u0026#34;bussiness.properties\u0026#34;}) public class PropertyApplication { public static void main(String[] args) { SpringApplication.run(PropertyApplication.class, args); } } @ImportResource 用来加载 xml 配置文件，比如导入自定义的aaa.xml文件，用法如下：\n@ImportResource(locations = \u0026#34;classpath:aaa.xml\u0026#34;) @SpringBootApplication public class PropertyApplication { public static void main(String[] args) { SpringApplication.run(PropertyApplication.class, args); } } 异常处理相关注解 @ControllerAdvice 和 @ExceptionHandler 通常组合使用，用于处理全局异常，示例代码如下：\n@ControllerAdvice @Configuration @Slf4j public class GlobalExceptionConfig { private static final Integer GLOBAL_ERROR_CODE = 500; @ExceptionHandler(value = Exception.class) @ResponseBody public void exceptionHandler(HttpServletRequest request, HttpServletResponse response, Exception e) throws Exception { log.error(\u0026#34;【统一异常处理器】\u0026#34;, e); ResultMsg\u0026lt;Object\u0026gt; resultMsg = new ResultMsg\u0026lt;\u0026gt;(); resultMsg.setCode(GLOBAL_ERROR_CODE); if (e instanceof CommonException) { CommonException ex = (CommonException) e; if(ex.getErrCode() != 0) { resultMsg.setCode(ex.getErrCode()); } resultMsg.setMsg(ex.getErrMsg()); }else { resultMsg.setMsg(CommonErrorMsg.SYSTEM_ERROR.getMessage()); } WebUtil.buildPrintWriter(response, resultMsg); } } 测试相关注解 @ActiveProfiles 一般作用于测试类上， 用于声明生效的 Spring 配置文件，比如指定application-dev.properties配置文件。\n@RunWith 和 @SpringBootTest 一般作用于测试类上， 用于单元测试用，示例如下：\n@ActiveProfiles(\u0026#34;dev\u0026#34;) @RunWith(SpringRunner.class) @SpringBootTest public class TestJunit { @Test public void executeTask() { //测试... } } ","permalink":"https://lesanouo.github.io/blog/posts/code/166939200010/","summary":"\u003ch2 id=\"简介\"\u003e简介\u003c/h2\u003e\n\u003cp\u003e基于 SpringBoot 平台开发的项目数不胜数，与常规的基于Spring开发的项目最大的不同之处，SpringBoot 里面提供了大量的注解用于快速开发，而且非常简单，基本可以做到开箱即用！\u003c/p\u003e","title":"SpringBoot常用注解总结"},{"content":"本篇主要介绍的就是 controller 层的一些优雅技巧，一个完整的后端请求由4部分组成：1. 接口地址(也就是URL地址)、2. 请求方式(一般就是get、set，当然还有put、delete)、3. 请求数据(request，有head跟body)、4. 响应数据(response)\n本篇将解决以下3个问题：\n当接收到请求时，如何优雅的校验参数 返回响应数据该如何统一的进行处理 接收到请求，处理业务逻辑时抛出了异常又该如何处理 统一返回格式 封装ResultVo 首先先定义一个状态码的接口，所有状态码都需要实现它，有了标准才好做事 public interface StatusCode { public int getCode(); public String getMsg(); } 与前端规定好自定义状态码 @Getter @AllArgsConstructor @NoArgsConstructor public enum ResultCode implements StatusCode { SUCCESS(1000, \u0026#34;请求成功\u0026#34;), FAILED(1001, \u0026#34;请求失败\u0026#34;), VALIDATE_ERROR(1002, \u0026#34;参数校验失败\u0026#34;), RESPONSE_PACK_ERROR(1003, \u0026#34;response返回包装失败\u0026#34;); private int code; private String msg; } 定义 ResultVo 包装类 @Data public class ResultVo { // 状态码 private int code; // 状态信息 private String msg; // 返回对象 private Object data; // 手动设置返回vo public ResultVo(int code, String msg, Object data) { this.code = code; this.msg = msg; this.data = data; } // 默认返回成功状态码，数据对象 public ResultVo(Object data) { this.code = ResultCode.SUCCESS.getCode(); this.msg = ResultCode.SUCCESS.getMsg(); this.data = data; } // 返回指定状态码，数据对象 public ResultVo(StatusCode statusCode, Object data) { this.code = statusCode.getCode(); this.msg = statusCode.getMsg(); this.data = data; } // 只返回状态码 public ResultVo(StatusCode statusCode) { this.code = statusCode.getCode(); this.msg = statusCode.getMsg(); this.data = null; } } 统一校验 引入依赖 由于新版 Spring Boot 已不内置校验模块，需自己引入相应的包\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-validation\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 通过@Validated实现参数校验 @Data public class AddUserVo { @NotNull(message = \u0026#34;用户名不能为空\u0026#34;) private String userName; @Length(min = 8, message = \u0026#34;密码最少需要8位\u0026#34;) private String password; private Integer age; } @PostMapping(\u0026#34;/addUser\u0026#34;) public AddUserVo addUser(@Validated AddUserVo userVo) { return userVo; } 虽然成功校验了参数，也返回了异常，但是返回的异常不符合预期，与我们之前定义了的统一状态码不一致，所以我们要进行优化一下，每次出现异常的时候，自动把状态码写好。\n优化异常处理 我们可以通过控制台看出，校验参数抛出了什么异常\nResolved [org.springframework.validation.BindException: org.springframework.validation.BeanPropertyBindingResult: 1 errors 我们看到代码抛出了org.springframework.validation.BindException的绑定异常，因此我们的思路就是AOP拦截所有controller，然后异常的时候统一拦截起来，进行封装！\n但是我们可以通过 Spring Boot 提供的@RestControllerAdvice来增强所有@RestController，然后使用@ExceptionHandler注解，就可以拦截到对应的异常。这样开发起来就方便很多。\n这里我们就拦截BindException.class就好了。最后在返回之前，我们对异常信息进行包装一下，包装成ResultVo，当然要跟上ResultCode.VALIDATE_ERROR的异常状态码。\n@RestControllerAdvice public class ControllerExceptionAdvice { @ExceptionHandler({BindException.class}) public ResultVo MethodArgumentNotValidExceptionHandler(BindException e){ // 从异常对象中拿到ObjectError对象 ObjectError objectError = e.getBindingResult().getAllErrors().get(0); return new ResultVo(ResultCode.VALIDATE_ERROR, objectError.getDefaultMessage()); } } 统一响应 统一包装响应 前面写的ResultVo导致每一个接口都需要写new ResultVo(data)，这样开发小哥肯定不乐意了，所以我们要优化封装，让AOP拦截所有Controller，然后再自动包一层ResultVo。\n但是 Spring Boot 中也有现成的供我们使用：\n@RestControllerAdvice public class ControllerResponseAdvice implements ResponseBodyAdvice\u0026lt;Object\u0026gt; { @Override public boolean supports(MethodParameter returnType, Class\u0026lt;? extends HttpMessageConverter\u0026lt;?\u0026gt;\u0026gt; converterType) { // response是ResultVo类型，或者注释了NotControllerResponseAdvice都不进行包装 return !(returnType.getParameterType().isAssignableFrom(ResultVo.class)); } @Override public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType, Class\u0026lt;? extends HttpMessageConverter\u0026lt;?\u0026gt;\u0026gt; selectedConverterType, ServerHttpRequest request, ServerHttpResponse response) { // String类型不能直接包装 if (returnType.getGenericParameterType().equals(String.class)){ ObjectMapper objectMapper = new ObjectMapper(); try { // 将数据包装在ResultVo里后转换为json串进行返回 return objectMapper.writeValueAsString(new ResultVo(body)); } catch (JsonProcessingException e) { throw new RuntimeException(e); } } // 否则直接包装成ResultVo返回 return new ResultVo(body); } } @RestControllerAdvice(basePackages = {\u0026quot;com.example\u0026quot;})自动扫描了所有指定包下的controller，在Response时进行统一处理 重写supports方法，也就是说，当返回类型已经是ResultVo了，那就不需要封装了，当不等与ResultVo时才进行调用beforeBodyWrite方法，跟过滤器的效果是一样的 最后重写我们的封装方法beforeBodyWrite，注意除了String的返回值有点特殊，无法直接封装成json，我们需要进行特殊处理，其他的直接new ResultVo(data);就ok了 NOT统一响应 有的时候，我们的系统不需要包装一层统一响应，比如项目中集成了一个健康检测的功能，这个时候是不需要包装统一响应的，导致最后接口对应不上。\n@GetMapping(\u0026#34;/health\u0026#34;) public String health(Integer id) { return \u0026#34;success\u0026#34;; } 因为百分之99的请求还是需要包装的，只有个别不需要，写在包装的过滤器吧？又不是很好维护，那就加个注解好了。所有不需要包装的就加上这个注解。\n@Target({ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) public @interface NotControllerResponseAdvice { } 然后在我们的增强过滤方法上过滤包含这个注解的方法\n@RestControllerAdvice public class ControllerResponseAdvice implements ResponseBodyAdvice\u0026lt;Object\u0026gt; { @Override public boolean supports(MethodParameter returnType, Class\u0026lt;? extends HttpMessageConverter\u0026lt;?\u0026gt;\u0026gt; converterType) { // response是ResultVo类型，或者注释了NotControllerResponseAdvice都不进行包装 return !(returnType.getParameterType().isAssignableFrom(ResultVo.class) || returnType.hasMethodAnnotation(NotControllerResponseAdvice.class)); } ... 最后就在不需要包装的方法上加上注解\n@GetMapping(\u0026#34;/health\u0026#34;) @NotControllerResponseAdvice public String health(Integer id) { return \u0026#34;success\u0026#34;; } 统一异常 每个系统都会有自己的业务异常，比如库存不能小于0子类的，这种异常并非程序异常，而是业务操作引发的异常，我们也需要进行规范的编排业务异常状态码，并且写一个专门处理的异常类，最后通过刚刚学习过的异常拦截统一进行处理，以及打日志。\n异常状态码枚举，既然是状态码，那就肯定要实现我们的标准接口StatusCode @Getter @NoArgsConstructor @AllArgsConstructor public enum AppCode implements StatusCode { APP_ERROR(2000, \u0026#34;业务异常\u0026#34;); private int code; private String msg; } 异常类 @Getter public class APIException extends RuntimeException { private int code; private String msg; // 手动设置异常 public APIException(StatusCode statusCode, String message) { // message用于用户设置抛出错误详情，例如：当前价格-5，小于0 super(message); // 状态码 this.code = statusCode.getCode(); // 状态码配套的msg this.msg = statusCode.getMsg(); } // 默认异常使用APP_ERROR状态码 public APIException(String message) { super(message); this.code = AppCode.APP_ERROR.getCode(); this.msg = AppCode.APP_ERROR.getMsg(); } } 最后进行统一异常的拦截 @RestControllerAdvice public class ControllerExceptionAdvice { @ExceptionHandler({BindException.class}) public ResultVo MethodArgumentNotValidExceptionHandler(BindException e){ // 从异常对象中拿到ObjectError对象 ObjectError objectError = e.getBindingResult().getAllErrors().get(0); return new ResultVo(ResultCode.VALIDATE_ERROR, objectError.getDefaultMessage()); } @ExceptionHandler(APIException.class) public ResultVo APIExceptionHandler(APIException e) { // log.error(e.getMessage(), e); 由于还没集成日志框架，暂且放着，写上TODO return new ResultVo(e.getCode(), e.getMsg(), e.getMessage()); } } 最后使用，我们的代码只需要这么写 @GetMapping(\u0026#34;/error\u0026#34;) public String error(Integer id) { if (id.equals(0)){ throw new APIException(\u0026#34;用户不存在\u0026#34;); } return \u0026#34;error\u0026#34;; } 就会自动抛出AppCode.APP_ERROR状态码的响应，并且带上异常详细信息用户不存在。\n","permalink":"https://lesanouo.github.io/blog/posts/code/166939200009/","summary":"\u003cp\u003e本篇主要介绍的就是 \u003ccode\u003econtroller\u003c/code\u003e 层的一些优雅技巧，一个完整的后端请求由4部分组成：1. \u003ccode\u003e接口地址\u003c/code\u003e(也就是URL地址)、2. \u003ccode\u003e请求方式\u003c/code\u003e(一般就是get、set，当然还有put、delete)、3. \u003ccode\u003e请求数据\u003c/code\u003e(request，有head跟body)、4. \u003ccode\u003e响应数据\u003c/code\u003e(response)\u003c/p\u003e","title":"SpringBoot优化Controller层代码"},{"content":"多行转成一列（并用\u0026quot;,\u0026ldquo;分割） SELECT NAME, STUFF (( SELECT \u0026#39;,\u0026#39; + VALUE FROM A WHERE NAME = Test.NAME FOR XML PATH ( \u0026#39;\u0026#39; ) ),1,1,\u0026#39;\u0026#39;) VALUE FROM A AS Test GROUP BY NAME; STUFF语句就是为了去掉第一个【逗号】\nSTUFF用法：（从原字符的第二个开始共三个字符替换为后面的字符）\nSELECT STUFF(\u0026#39;abcdef\u0026#39;, 2, 3, \u0026#39;ijklmn\u0026#39;); -- 查询结果：aijklmnef 其余行列转换用法请参考文章：https://www.cnblogs.com/no27/p/6398130.html\n根据符号将一列拆分多行 select name, SUBSTRING(a.comp,number,CHARINDEX(\u0026#39;,\u0026#39;,a.comp+\u0026#39;,\u0026#39;,number)-number) as company, from data_base a,master..spt_values where and number \u0026gt;=1 and number \u0026lt; len(comp) and type=\u0026#39;p\u0026#39; and SUBSTRING(\u0026#39;,\u0026#39;+comp,number,1)=\u0026#39;,\u0026#39; SUBSTRING()从输入字符串中的位置(从1开始计数)开始提取具有指定长度的子字符串 SUBSTRING(input_string, start, length)\nCHARINDEX()函数从指定位置开始搜索字符串内的子字符串 CHARINDEX(substring, string [, start_location])，其中start_location是搜索开始的位置，可选\nmaster..spt_values这个表主要用来保存一些枚举值\n--0~2047 共2048个数字 SELECT number FROM MASTER..spt_values WHERE TYPE = \u0026#39;p\u0026#39; 通过PARSENAME拆分字符串 注意：PARSENAME最多只能拆分成4个字段\nPARSENAME默认是根据\u0026rsquo;.\u0026lsquo;进行拆分的，所以首先要做的是将字段中的其他分隔符（如‘-’）替换成\u0026rsquo;.\u0026rsquo;\nDECLARE @ip NVARCHAR(200) = \u0026#39;192;168;1;2\u0026#39;; SELECT PARSENAME(REPLACE(@ip,\u0026#39;;\u0026#39;,\u0026#39;.\u0026#39;), 1) AS col1, -- 2 PARSENAME(REPLACE(@ip,\u0026#39;;\u0026#39;,\u0026#39;.\u0026#39;), 2) AS col2, -- 1 PARSENAME(REPLACE(@ip,\u0026#39;;\u0026#39;,\u0026#39;.\u0026#39;), 3) AS col3, -- 168 PARSENAME(REPLACE(@ip,\u0026#39;;\u0026#39;,\u0026#39;.\u0026#39;), 4) AS col4; -- 192 SQL Server 字符串拆分函数Split create function split( @string varchar(255),--待分割字符串 @separator varchar(255)--分割符 )returns @array table(item varchar(255) COLLATE Chinese_PRC_CI_AS) -- COLLATE分配排序规则 as begin declare @begin int,@end int,@item varchar(255) set @begin = 1 set @end=charindex(@separator,@string,@begin) while(@end\u0026lt;\u0026gt;0) begin set @item = substring(@string,@begin,@end-@begin) insert into @array(item) values(@item) set @begin = @end+1 set @end=charindex(@separator,@string,@begin) end set @item = substring(@string,@begin,len(@string)+1-@begin) if (len(@item)\u0026gt;0) insert into @array(item) values(substring(@string,@begin,len(@string)+1-@begin)) return end SQL Server CROSS/OUTER APPLY 使用 APPLY 运算符(2005或以上版本)可以为实现查询操作的外部表表达式返回的每个行调用表值函数。表值函数作为右输入，外部表表达式作为左输入。通过对右输入求值来获得左输入每一行的计算结果，生成的行被组合起来作为最终输出。APPLY 运算符生成的列的列表是左输入中的列集，后跟右输入返回的列的列表。\nAPPLY 有两种形式： CROSS APPLY 和 OUTER APPLY。CROSS APPLY 仅返回外部表中通过表值函数生成结果集的行。OUTER APPLY 既返回生成结果集的行，也返回不生成结果集的行，其中表值函数生成的列中的值为 NULL。\n看一下例子：\nselect * from table1 join MyFunction(1) on 1=1 -- MyFunction 的参数是一个常量，可以返回一个表。 -- 但有时候我们希望以 table1 的字段作为参数，传进函数去计算，像： select * from table1 join MyFunction(id) on 1=1 -- 这样是会出错的。这个时候我们就可以用 apply 来实现了。例如： select * from table1 cross apply MyFunction(id) on 1=1 简单的说，apply 允许我们将前面结果集每一行的数据作为参数，传递到后面的表达式，后面的表达式可以是一个表值函数，或者select结果集。\nso，当你在需要将某个字段的值作为参数使用时，或者用join实现起来比较复杂时，就可以考虑apply来实现。\n简单实例：\n获得语文第一名，数学前两名，英语前三名的name，学科，分数，用cross apply实现：\nSELECT b.* FROM ( select Subject=\u0026#39;Chiness\u0026#39;,num=1 union all select \u0026#39;Math\u0026#39;,2 union all select \u0026#39;English\u0026#39;,3 )a cross apply (select top(a.num) * from Students where Subject=a.Subject )b ","permalink":"https://lesanouo.github.io/blog/posts/code/166939200008/","summary":"\u003ch2 id=\"多行转成一列并用分割\"\u003e多行转成一列（并用\u0026quot;,\u0026ldquo;分割）\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sql\" data-lang=\"sql\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eSELECT\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eNAME\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eSTUFF\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e((\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eSELECT\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;,\u0026#39;\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eVALUE\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eFROM\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eA\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eWHERE\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eNAME\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eTest\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eNAME\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eFOR\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eXML\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ePATH\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;\u0026#39;\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eVALUE\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eFROM\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\t\u003c/span\u003e\u003cspan class=\"n\"\u003eA\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eAS\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eTest\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eGROUP\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eBY\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\t\u003c/span\u003e\u003cspan class=\"n\"\u003eNAME\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eSTUFF语句就是为了去掉第一个【逗号】\u003c/p\u003e\n\u003cp\u003eSTUFF用法：（从原字符的第二个开始共三个字符替换为后面的字符）\u003c/p\u003e","title":"SQLServer一些小技巧"},{"content":"本篇文章主要是一些SQL优化的小技巧，为了提升SQL编写规范及性能\n避免使用select * 在实际业务场景中，我们不一定需要查出整张表中的所有数据。如果查出了许多不必要的数据，这样会白白浪费了数据库的资源，如：内存或CPU。此外，多查出来的数据，通过网络IO传输的过程中，也会增加数据传输的时间。\n还有一个最重要的问题是：select * 不会走覆盖索引，会出现大量的回表操作，而从导致查询sql的性能很低。\n所以以后查表时，只查需要用到的字段！\nselect name,age from user where id=1; 用union all代替union union : 可以获取排重后的数据\nunion all : 可以获取所有数据，包含重复的数据\n排重的过程需要遍历、排序和比较，它更耗时，更消耗cpu资源。所以如果能用union all的时候，尽量不用union。\n(select * from user where id=1) union all (select * from user where id=2); 小表驱动大表 小表驱动大表：也就是说用小表的数据集驱动大表的数据集。\n假如有order和user两张表，其中order表有10000条数据，而user表有100条数据。\n这时如果想查一下，所有有效的用户下过的订单列表。\n可以使用in关键字实现：\nselect * from order where user_id in (select id from user where status=1) 也可以使用exists关键字实现：\nselect * from order where exists (select 1 from user where order.user_id = user.id and status=1) 在in与exists中该如何抉择呢？\n因为如果SQL语句中包含了in关键字，则它会优先执行in里面的子查询语句，然后再执行in外面的语句。如果in里面的数据量很少，作为条件查询速度更快。\n而如果sql语句中包含了exists关键字，它优先执行exists左边的语句（即主查询语句）。然后把它作为条件，去跟右边的语句匹配。如果匹配上，则可以查询出数据。如果匹配不上，数据就被过滤掉了。\n这个需求中，order表有10000条数据，而user表有100条数据。order表是大表，user表是小表。如果order表在左边，则用in关键字性能更好。\n总结一下：\nin 适用于左边大表，右边小表。 exists 适用于左边小表，右边大表。 不管是用in，还是exists关键字，其核心思想都是用小表驱动大表。\n批量操作 在需要批量插入数据时，我们不应该使用for循环进行逐条插入数据，因为该操作需要多次请求数据库，才能完成批量数据插入。\n但众所周知，我们在代码中，每次远程请求数据库，是会消耗一定性能的。而如果我们的代码需要请求多次数据库，才能完成本次业务功能，势必会消耗更多的性能。\n这时候我们就需要创建一个批量插入数据的方法：\n-- orderMapper.insertBatch(list): insert into order(id,code,user_id) values(123,\u0026#39;001\u0026#39;,100),(124,\u0026#39;002\u0026#39;,100),(125,\u0026#39;003\u0026#39;,101); 这样只需要远程请求一次数据库，sql性能会得到提升，数据量越多，提升越大。\n但需要注意的是，不建议一次批量操作太多的数据，如果数据太多数据库响应也会很慢。批量操作需要把握一个度，建议每批数据尽量控制在500以内。如果数据多于500，则分多批次处理。\n多用limit 有时候，我们需要查询某些数据中的第一条，比如：查询某个用户下的第一个订单，想看看他第一次的首单时间。\nselect id, create_date from order where user_id=123 order by create_date asc limit 1; 使用 limit 1，只返回该用户下单时间最小的那一条数据即可。\n此外，在删除或者修改数据时，为了防止误操作，导致删除或修改了不相干的数据，也可以在sql语句最后加上limit\nupdate order set status=0,edit_time=now(3) where id\u0026gt;=100 and id\u0026lt;200 limit 100; -- 这样即使误操作，比如把id搞错了，也不会对太多的数据造成影响 增量查询 有时候，我们需要通过远程接口查询数据，然后同步到另外一个数据库。\n如果直接获取所有的数据，然后同步过去。这样虽说非常方便，但是带来了一个非常大的问题，就是如果数据很多的话，查询性能会非常差。\nselect * from user where id\u0026gt;#{lastId} and create_time \u0026gt;= #{lastCreateTime} limit 100; 按id和时间升序，每次只同步一批数据，这一批数据只有100条记录。每次同步完成之后，保存这100条数据中最大的id和时间，给同步下一批数据的时候用。\n通过这种增量查询的方式，能够提升单次查询的效率。\n高效的分页 有时候，列表页在查询数据时，为了避免一次性返回过多的数据影响接口性能，我们一般会对查询接口做分页处理。\n在MySQL中分页一般用limit关键字，如果表中数据量少，用limit关键字做分页，没啥问题。但如果表中数据量很多，用它就会出现性能问题。\n例如：\nselect id,name,age from user limit 1000000,20; -- MySQL会查到1000020条数据，然后丢弃前面的1000000条，只查后面的20条数据，这个是非常浪费资源的 这时候，海量数据该如何分页呢？\nselect id,name,age from user where id \u0026gt; 1000000 limit 20; 先找到上次分页最大的id，然后利用id上的索引查询。不过该方案，要求id是连续的，并且有序的。\n还能使用between优化分页：\nselect id,name,age from user where id between 1000000 and 1000020; -- 需要注意的是between要在唯一索引上分页，不然会出现每页大小不一致的问题 用连接查询代替子查询 MySQL中如果需要从两张以上的表中查询出数据的话，一般有两种实现方式：子查询 和 连接查询。\n子查询的例子如下：\nselect * from order where user_id in (select id from user where status=1) 子查询语句可以通过in关键字实现，一个查询语句的条件落在另一个select语句的查询结果中。程序先运行在嵌套在最内层的语句，再运行外层的语句。\n子查询语句的优点是简单，结构化，如果涉及的表数量不多的话。\n但缺点是MySQL执行子查询时，需要创建临时表，查询完毕后，需要再删除这些临时表，有一些额外的性能消耗。\n这时可以改成连接查询。具体例子如下：\nselect o.* from order o inner join user u on o.user_id = u.id where u.status=1 join的表不宜过多 根据阿里巴巴开发者手册的规定，join表的数量不应该超过 3 个。\n如果join太多，MySQL在选择索引的时候会非常复杂，很容易选错索引。并且如果没有命中中，nested loop join 就是分别从两个表读一行数据进行两两对比，复杂度是 n^2。\n如果实现业务场景中需要查询出另外几张表中的数据，可以在a、b、c表中冗余专门的字段，比如：在表a中冗余d_name字段，保存需要查询出的数据。\n不过有些ERP系统，并发量不大，但业务比较复杂，需要join十几张表才能查询出数据。\n所以join表的数量要根据系统的实际情况决定，不能一概而论，尽量越少越好。\njoin时要注意 在涉及到多张表联合查询的时候，一般会使用join关键字。\n而join使用最多的是left join和inner join。\nleft join：求两个表的交集外加左表剩下的数据。 inner join：求两个表交集的数据。 使用inner join的示例如下：\nselect o.id,o.code,u.name from order o inner join user u on o.user_id = u.id where u.status=1; -- 如果两张表使用inner join关联，MySQL会自动选择两张表中的小表，去驱动大表，所以性能上不会有太大的问题 使用left join的示例如下：\nselect o.id,o.code,u.name from order o left join user u on o.user_id = u.id where u.status=1; -- 如果两张表使用left join关联，MySQL会默认用left join关键字左边的表，去驱动它右边的表。如果左边的表数据很多时，就会出现性能问题 要特别注意的是在用left join关联查询时，左边要用小表，右边可以用大表。如果能用inner join的地方，尽量少用left join\n控制索引的数量 众所周知，索引能够显著的提升查询SQL的性能，但索引数量并非越多越好。\n因为表中新增数据时，需要同时为它创建索引，而索引是需要额外的存储空间的，而且还会有一定的性能消耗。\n阿里巴巴的开发者手册中规定，单表的索引数量应该尽量控制在 5 个以内，并且单个索引中的字段数不超过 5 个。\nMySQL使用的B+树的结构来保存索引的，在insert、update和delete操作时，需要更新B+树索引。如果索引过多，会消耗很多额外的性能。\n那么，问题来了，如果表中的索引太多，超过了5个该怎么办？\n这个问题要辩证的看，如果你的系统并发量不高，表中的数据量也不多，其实超过5个也可以，只要不要超过太多就行。\n但对于一些高并发的系统，请务必遵守单表索引数量不要超过5的限制。\n那么，高并发系统如何优化索引数量？\n能够建联合索引，就别建单个索引，可以删除无用的单个索引。\n将部分查询功能迁移到其他类型的数据库中，比如：Elastic Seach、HBase等，在业务表中只需要建几个关键索引即可。\n选择合理的字段类型 char ：表示固定字符串类型，该类型的字段存储空间的固定的，会浪费存储空间。\nvarchar ：表示变长字符串类型，该类型的字段存储空间会根据实际数据的长度调整，不会浪费存储空间。\n如果是长度固定的字段，比如用户手机号，一般都是11位的，可以定义成char类型，长度是11字节。\n但如果是企业名称字段，假如定义成char类型，就有问题了。\n如果长度定义得太长，比如定义成了200字节，而实际企业长度只有50字节，则会浪费150字节的存储空间。\n如果长度定义得太短，比如定义成了50字节，但实际企业名称有100字节，就会存储不下，而抛出异常。\n所以建议将企业名称改成varchar类型，变长字段存储空间小，可以节省存储空间，而且对于查询来说，在一个相对较小的字段内搜索效率显然要高些。\n我们在选择字段类型时，应该遵循这样的原则：\n能用数字类型，就不用字符串，因为字符的处理往往比数字要慢。 尽可能使用小的类型，比如：用bit存布尔值，用tinyint存枚举值等。 长度固定的字符串字段，用char类型。 长度可变的字符串字段，用varchar类型。 金额字段用decimal，避免精度丢失问题。 提升group by的效率 我们有很多业务场景需要使用group by关键字，它主要的功能是去重和分组。\n通常它会跟having一起配合使用，表示分组后再根据一定的条件过滤数据，使用它就会有一些性能上的隐患。\nselect user_id,user_name from order group by user_id having user_id \u0026lt;= 200; -- 这种写法性能不好，它先把所有的订单根据用户id分组之后，再去过滤用户id大于等于200的用户 分组是一个相对耗时的操作，为什么我们不先缩小数据的范围之后，再分组呢？\nselect user_id,user_name from order where user_id \u0026lt;= 200 group by user_id 使用where条件在分组前，就把多余的数据过滤掉了，这样分组时效率就会更高一些。\n其实这是一种思路，不仅限于group by的优化。我们的sql语句在做一些耗时的操作之前，应尽可能缩小数据范围，这样能提升sql整体的性能\n索引优化 很多时候SQL语句，走了索引，和没有走索引，执行效率差别很大。所以索引优化被作为SQL优化的首选。\n索引优化的第一步是：检查sql语句有没有走索引。\n可以使用explain命令，查看mysql的执行计划。\n例如：\nexplain select * from `order` where code=\u0026#39;002\u0026#39;; 结果： 通过这几列可以判断索引使用情况，执行计划包含列的含义如下图所示： 说实话，sql语句没有走索引，排除没有建索引之外，最大的可能性是索引失效了。\n下面说说索引失效的常见原因： 如果不是上面的这些原因，则需要再进一步排查一下其他原因。\n此外，你有没有遇到过这样一种情况：明明是同一条sql，只有入参不同而已。有的时候走的索引a，有的时候却走的索引b？\n没错，有时候MySQL会选错索引。\n必要时可以使用force index来强制查询sql走某个索引。\n","permalink":"https://lesanouo.github.io/blog/posts/code/166939200007/","summary":"\u003cp\u003e本篇文章主要是一些SQL优化的小技巧，为了提升SQL编写规范及性能\u003c/p\u003e\n\u003ch2 id=\"避免使用select-\"\u003e避免使用select *\u003c/h2\u003e\n\u003cp\u003e在实际业务场景中，我们不一定需要查出整张表中的所有数据。如果查出了许多不必要的数据，这样会白白浪费了数据库的资源，如：内存或CPU。此外，多查出来的数据，通过网络IO传输的过程中，也会增加数据传输的时间。\u003c/p\u003e","title":"SQL优化小技巧"},{"content":"简介 服务端向客户端推送消息，其实除了可以用WebSocket这种耳熟能详的机制外，还有一种服务器发送事件(Server-sent events)，简称SSE。\nSSE它是基于HTTP协议的，我们知道一般意义上的HTTP协议是无法做到服务端主动向客户端推送消息的，但SSE是个例外，它变换了一种思路。\nSSE在服务器和客户端之间打开一个单向通道，服务端响应的不再是一次性的数据包而是text/event-stream类型的数据流信息，在有数据变更时从服务器流式传输到客户端。\n整体的实现思路有点类似于在线视频播放，视频流会连续不断的推送到浏览器，你也可以理解成，客户端在完成一次用时很长（网络不畅）的下载。\nSSE与WebSocket作用相似，都可以建立服务端与浏览器之间的通信，实现服务端向客户端推送消息，但还是有些许不同：\nSSE 是基于HTTP协议的，它们不需要特殊的协议或服务器实现即可工作；WebSocket需单独服务器来处理协议。 SSE 单向通信，只能由服务端向客户端单向通信；webSocket全双工通信，即通信的双方可以同时发送和接受信息。 SSE 实现简单开发成本低，无需引入其他组件；WebSocket传输数据需做二次解析，开发门槛高一些。 SSE 默认支持断线重连；WebSocket则需要自己实现。 SSE 只能传送文本消息，二进制数据需要经过编码后传送；WebSocket默认支持传送二进制数据。 SSE 与 WebSocket 该如何选择？\nSSE好像一直不被大家所熟知，一部分原因是出现了WebSocket，这个提供了更丰富的协议来执行双向、全双工通信。对于游戏、即时通信以及需要双向近乎实时更新的场景，拥有双向通道更具吸引力。\n但是，在某些情况下，不需要从客户端发送数据。而你只需要一些服务器操作的更新。比如：站内信、未读消息数、状态更新、股票行情、监控数量等场景，SEE不管是从实现的难易和成本上都更加有优势。此外，SSE 具有WebSocket在设计上缺乏的多种功能，例如：自动重新连接、事件ID和发送任意事件的能力。\n实践 前端 前端只需进行一次HTTP请求，带上唯一ID，打开事件流，监听服务端推送的事件就可以了\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;http://libs.baidu.com/jquery/2.0.0/jquery.min.js\u0026#34; type=\u0026#34;text/javascript\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li class=\u0026#34;active\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; 未读消息 \u0026lt;span id=\u0026#34;count\u0026#34; class=\u0026#34;\u0026#34;\u0026gt;0\u0026lt;/span\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;div\u0026gt; \u0026lt;input style=\u0026#34;height: 25px; width: 180px;\u0026#34; maxlength=\u0026#34;60\u0026#34; value=\u0026#34;\u0026#34; id=\u0026#34;message\u0026#34; /\u0026gt; \u0026lt;button class=\u0026#34;button\u0026#34; id=\u0026#34;mySendBtn\u0026#34; onclick=\u0026#34;sendMessage()\u0026#34;\u0026gt; 点击发送\u0026lt;/button\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;div id=\u0026#34;arrivedDiv\u0026#34; style=\u0026#34;height:200px; width:300px; overflow:scroll; background:#EEEEEE;\u0026#34;\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; let source = null; let userId = \u0026#34;111\u0026#34;; if (window.EventSource) { // 建立连接 source = new EventSource(\u0026#39;http://localhost:8080/sse/sub/\u0026#39;+userId); setMessageInnerHTML(\u0026#34;连接用户=\u0026#34; + userId); // 连接一旦建立，就会触发open事件，另一种写法：source.onopen = function (event) {} source.addEventListener(\u0026#39;open\u0026#39;, function (e) { setMessageInnerHTML(\u0026#34;建立连接。。。\u0026#34;); }, false); // 客户端收到服务器发来的数据，另一种写法：source.onmessage = function (event) {} source.addEventListener(\u0026#39;message\u0026#39;, function (e) { setMessageInnerHTML(e.data); }); // 如果发生通信错误（比如连接中断），就会触发error事件，另一种写法：source.onerror = function (event) {} source.addEventListener(\u0026#39;error\u0026#39;, function (e) { if (e.readyState === EventSource.CLOSED) { setMessageInnerHTML(\u0026#34;连接关闭\u0026#34;); } else { console.log(e); } }, false); } else { setMessageInnerHTML(\u0026#34;你的浏览器不支持SSE\u0026#34;); } // 监听窗口关闭事件，主动去关闭sse连接，如果服务端设置永不过期，浏览器关闭后手动清理服务端数据 window.onbeforeunload = function () { closeSse(); }; // 关闭Sse连接 function closeSse() { source.close(); const httpRequest = new XMLHttpRequest(); httpRequest.open(\u0026#39;GET\u0026#39;, \u0026#39;http://localhost:8080/sse/close/\u0026#39; + userId, true); httpRequest.send(); console.log(\u0026#34;close\u0026#34;); } // 将消息显示在网页上 function setMessageInnerHTML(innerHTML) { $(\u0026#34;#arrivedDiv\u0026#34;).append(\u0026#34;\u0026lt;br/\u0026gt;\u0026#34;+innerHTML); var count = $(\u0026#34;#count\u0026#34;).text(); count = Number(count) + 1; $(\u0026#34;#count\u0026#34;).text(count); } // 发送信息 function sendMessage() { var content = $(\u0026#34;#message\u0026#34;).val(); $.ajax({ url: \u0026#39;http://localhost:8080/sse/push\u0026#39;, type: \u0026#39;GET\u0026#39;, data: { \u0026#34;id\u0026#34;: userId, \u0026#34;content\u0026#34;: content }, success: function (data) { console.log(data) }, error: function (err) { }, done: function () { } }) } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 后端 基本步骤，创建一个SseEmitter对象放入sseEmitterMap进行管理\n下面是SseEmitterUtils类，里面主要是对SseEmitter的基本操作，以及当前所有的连接管理\n@Slf4j @Component public class SseEmitterUtils { /** * 当前连接数 */ private static AtomicInteger count = new AtomicInteger(0); /** * 使用map对象，便于根据userId来获取对应的SseEmitter，或者放redis里面 */ private static Map\u0026lt;String, SseEmitter\u0026gt; sseEmitterMap = new ConcurrentHashMap\u0026lt;\u0026gt;(); /** * 创建用户连接并返回 SseEmitter */ public static SseEmitter connect(String userId) { if (sseEmitterMap.containsKey(userId)) { return sseEmitterMap.get(userId); } try { /** * 设置超时时间，0表示不过期。默认30秒 */ SseEmitter sseEmitter = new SseEmitter(0L); /** * 注册回调 */ sseEmitter.onCompletion(completionCallBack(userId)); sseEmitter.onError(errorCallBack(userId)); sseEmitter.onTimeout(timeoutCallBack(userId)); sseEmitterMap.put(userId, sseEmitter); /** * 数量+1 */ count.getAndIncrement(); return sseEmitter; } catch (Exception e) { log.error(\u0026#34;创建新的sse连接异常，当前用户：{}\u0026#34;, userId); } return null; } /** * 给指定用户发送消息 */ public static void sendMessage(String userId, String message) { if (sseEmitterMap.containsKey(userId)) { try { sseEmitterMap.get(userId).send(message); } catch (IOException e) { log.error(\u0026#34;用户[{}]推送异常:{}\u0026#34;, userId, e.getMessage()); removeUser(userId); } } } /** * 向同组人发布消息 （要求userId+groupId） */ public static void groupSendMessage(String groupId, String message) { if (MapUtil.isNotEmpty(sseEmitterMap)) { sseEmitterMap.forEach((k, v) -\u0026gt; { try { if (k.startsWith(groupId)) { v.send(message, MediaType.APPLICATION_JSON); } } catch (IOException e) { log.error(\u0026#34;用户[{}]推送异常:{}\u0026#34;, k, e.getMessage()); removeUser(k); } }); } } public static List\u0026lt;String\u0026gt; getIds() { return new ArrayList\u0026lt;\u0026gt;(sseEmitterMap.keySet()); } public static void removeUser(String userId) { sseEmitterMap.remove(userId); // 数量-1 count.getAndDecrement(); log.info(\u0026#34;移除用户：{}\u0026#34;, userId); } private static Runnable completionCallBack(String userId) { return () -\u0026gt; { log.info(\u0026#34;结束连接：{}\u0026#34;, userId); removeUser(userId); }; } private static Runnable timeoutCallBack(String userId) { return () -\u0026gt; { log.info(\u0026#34;连接超时：{}\u0026#34;, userId); removeUser(userId); }; } private static Consumer\u0026lt;Throwable\u0026gt; errorCallBack(String userId) { return throwable -\u0026gt; { log.info(\u0026#34;连接异常：{}\u0026#34;, userId); removeUser(userId); }; } } 最后是Controller，主要是创建连接、发送消息、断开连接对外的接口\n@RestController @CrossOrigin(\u0026#34;*\u0026#34;) @RequestMapping(\u0026#34;/sse\u0026#34;) public class SSEController { /** * 基础接口 */ @GetMapping(\u0026#34;/index\u0026#34;) public String sse(){ return \u0026#34;sse\u0026#34;; } /** * sse 订阅消息 */ @GetMapping(path = \u0026#34;sub/{id}\u0026#34;, produces = {MediaType.TEXT_EVENT_STREAM_VALUE}) public SseEmitter sub(@PathVariable String id) { return SseEmitterUtils.connect(id); } /** * sse 发布消息 */ @GetMapping(\u0026#34;push\u0026#34;) public void push(String id, String content) { SseEmitterUtils.sendMessage(id, content); } /** * sse 断开连接 */ @GetMapping(\u0026#34;breakConnect\u0026#34;) public void breakConnect(String id, HttpServletRequest request, HttpServletResponse response) { request.startAsync(); SseEmitterUtils.removeUser(id); } } ","permalink":"https://lesanouo.github.io/blog/posts/code/166939200006/","summary":"\u003ch2 id=\"简介\"\u003e简介\u003c/h2\u003e\n\u003cp\u003e服务端向客户端推送消息，其实除了可以用\u003ccode\u003eWebSocket\u003c/code\u003e这种耳熟能详的机制外，还有一种服务器发送事件(\u003ccode\u003eServer-sent events\u003c/code\u003e)，简称\u003ccode\u003eSSE\u003c/code\u003e。\u003c/p\u003e","title":"SSE实现服务器推送"},{"content":"在用threejs渲染3D模型时，往往需要选择一个最适合的模型格式，通常都是使用GLB作为Web渲染模型。然而许多工业的模型往往都是以STEP或者IGES作为导出格式，这种格式对于目前主流的3D渲染库支持并不好，所以需要转换模型格式。本篇文章为个人通过查找总结的转换方法，虽然并不是最优解🙃。\n各种3D模型格式 STEP \u0026amp; IGES 简单来说，这两种格式都是CAD的一种文件标准，在工业上使用比较广泛，STEP比IGES出现得更晚一些，由于IGES格式的最新版本是96年发布的，现在多由更高效的STEP等新格式替代，不支持材质。 IGES 可以安装 iges viewer 免费工具查看。\n但是，现行主流的web3d库，比如 three.js、Babylon 均不支持 STEP 和 IGES 模型，需要解决这个问题有两个思路：\n深入了解格式含义，编写代码给对应库提交对应的解析方案（想法很好，但是实践不易） 将格式转换为适合web展示的格式，比如称为3d界JPG的 GLTF 格式（本文就是讲这个的） STL STL格式更多出现在3D打印中，只能用来表示封闭的体或者面，且文件内部都用三角形表示，所以转换精度比较粗的话，看起来效果比较诡异，包括 Ascii 编码和二进制两种编码模式，一般采用二进制，因为体积相对较小，并且与STEP和IGES一样不支持材质 比如同一个模型（STEP大小：4.81M），转换精度不同可能就是如下两种效果 粗精度（Ascii编码：3.7M）；细精度（Ascii编码：63.3M，二进制编码：12.1M）\nGLTF 简单来说，就是最小化的把模型资源整理起来，称为3d模型界的JPG，支持材质贴图等，在各个Web3D库中得到了广泛支持，具体怎么加载这里就不赘述了，网上demo很多\nGithub上的格式介绍和相关技术汇总: https://github.com/mrdoob/three.js/pull/14308\nGLTF的详细介绍中文资料: https://zhuanlan.zhihu.com/p/65265611\n格式转换 整体思路如下：\n使用 pythonocc 将 STEP/IGES/Ascii的STL文件 统一转换为二进制模式的 STL， 再使用 stl2gltf 将STL转换转换为 gltf 格式， 最后使用 gltf-pipeline 将glb文件压缩输出即可 环境安装 pythonocc环境\nPythonocc是python的CAD，安装和使用都很方便\n下载并安装AnaConda：https://www.anaconda.com/distribution/#download-section 创建pythonocc 环境：conda create -n pythonocct -c dlr-sc -c pythonocc pythonocc-core=7.4.0rc1 gltf-pipeline环境\n下载并安装nodejs：https://nodejs.org/zh-cn/ 安装gltf-pipeline：npm install -g gltf-pipeline 实现转换（方法1） pythonocc读取转换STP/IGS/STL 在 Anaconda Prompt 中执行进入环境命令 activate pythonocct\nSTP转换为 STL 文件（StpConverter.py） import os from OCC.Extend.DataExchange import read_iges_file,read_step_file,write_stl_file input_file = \u0026#39;temp2.stp\u0026#39; output_file = \u0026#39;out.stl\u0026#39; if not os.path.exists(input_file): print(\u0026#39;Input file need exists\u0026#39;) exit() shapes=read_step_file(input_file) write_stl_file(shapes, output_file, \u0026#39;binary\u0026#39;, 0.03, 0.5) IGES转换为 STL 文件（IgsConverter.py） import os from OCC.Extend.DataExchange import read_iges_file,read_step_file,write_stl_file input_file = \u0026#39;temp2.stp\u0026#39; output_file = \u0026#39;out.stl\u0026#39; if not os.path.exists(input_file): print(\u0026#39;Input file need exists\u0026#39;) exit() shapes=read_step_file(input_file) write_stl_file(shapes, output_file, \u0026#39;binary\u0026#39;, 0.03, 0.5) stl2gltf（将STL转换为GLTF） 将二进制模式的 STL 文件转换为 GLTF 文件，支持浏览器本地转换、Python脚本以及C++源码\nstl2gltf.py 执行转换命令python stl2gltf.py out.stl out.glb -b 实现转换（方法2） 使用在线转换网址得到GLB文件(3D模型在线转换)\nGLB文件压缩 直接转换出来的 glb 文件可能比较大，对于WEB来说还是太大了，需使用 gltf-pipeline 进行文件压缩\n执行压缩命令gltf-pipeline -i out.glb -o out.glb -b -d glb/gltf格式模型文件压缩–gltf-pipeline相关参数说明 本文参考自：https://www.codeleading.com/article/26425971329/\n","permalink":"https://lesanouo.github.io/blog/posts/code/166939200005/","summary":"\u003cp\u003e在用threejs渲染3D模型时，往往需要选择一个最适合的模型格式，通常都是使用GLB作为Web渲染模型。然而许多工业的模型往往都是以STEP或者IGES作为导出格式，这种格式对于目前主流的3D渲染库支持并不好，所以需要转换模型格式。本篇文章为个人通过查找总结的转换方法，虽然并不是最优解🙃。\u003c/p\u003e","title":"STEP、IGES、STL等3D模型转换为GLB"},{"content":"单线程与多线程可以看作是：\n单线程为在一个单向行驶的道路上，每辆汽车都遵守交通规则 多线程为多条车道，这样在同一时间内，通行的车辆数远远大于单车道 然而扩充了车道后问题就没那么简单了，车道一旦多起来加塞的场景就会越来越多，出现碰撞后也会影响整条马路的通行效率，这样多车道就不一定比单车道更快了\n为了解决汽车频繁变道加塞的问题，可以通过在车道间增加护栏来规范管理\n在程序中处理多线程带来的问题归纳起来就三类：\n线程安全问题 活跃性问题 性能问题 线程安全问题 原子性 有一个非常经典的例子，比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元，两个操作都成功才意味着一次转账最终成功\n试想一下，如果这两个操作不具备原子性，从A的账户扣减了1000元之后，操作突然终止了，账户B没有增加1000元，那问题就大了\n银行转账这个例子有两个步骤，出现了意外后导致转账失败，说明没有原子性\n原子性：即一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行\n原子操作：即不会被线程调度机制打断的操作，没有上下文切换\n在并发编程中很多操作都不是原子操作，出个小题目：\ni = 0; // 操作1 i++; // 操作2 i = j; // 操作3 i = i + 1; // 操作4 上面这四个操作中有哪些是原子操作，哪些不是？不熟悉的人可能认为这些都是原子操作，其实只有操作1是原子操作\n操作1：对基本数据类型变量的赋值是原子操作 操作2：包含三个操作，读取i的值，将i加1，将值赋给i 操作3：读取j的值，将j的值赋给i 操作4：包含三个操作，读取i的值，将i加1，将值赋给i 在单线程环境下上述四个操作都不会出现问题，但是在多线程环境下，如果不通过加锁操作，往往可能得到意料之外的值\n在Java语言中通过可以使用synchronize或者lock来保证原子性\n可见性 可见性：指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值\nclass Test { int i = 50; int j = 0; public void update() { // 线程1执行 i = 100; } public int get() { // 线程2执行 j = i; return j; } } 线程1执行update方法将 i 赋值为100，一般情况下线程1会在自己的工作内存中完成赋值操作，却没有及时将新值刷新到主内存中\n这个时候线程2执行get方法，首先会从主内存中读取i的值，然后加载到自己的工作内存中，这个时候读取到i的值是50，再将50赋值给j，最后返回j的值就是50了。原本期望返回100，结果返回50，这就是可见性问题，线程1对变量i进行了修改，线程2没有立即看到i的新值\n如上图每个线程都有属于自己的工作内存，工作内存和主内存间需要通过store和load等进行交互\n为了解决多线程可见性问题，Java语言提供了 volatile 这个关键字。当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。而普通共享变量不能保证可见性，因为变量被修改后什么时候刷回到主存是不确定的，另外一个线程读的可能就是旧值\n当然Java的锁机制如synchronize和lock也是可以保证可见性的，加锁可以保证在同一时刻只有一个线程在执行同步代码块，释放锁之前会将变量刷回至主存，这样也就保证了可见性\n活跃性问题 上面讲到为了解决 可见性问题，我们可以采取加锁方式解决，但是如果加锁使用不当也容易引入其他问题，比如死锁\n活跃性是指某件正确的事情最终会发生，当某个操作无法继续下去的时候，就会发生活跃性问题\n活跃性问题一般有这样几类：死锁，活锁，饥饿 问题\n死锁 死锁是指多个线程因为环形的等待锁的关系而永远的阻塞下去 活锁 死锁是两个线程都在等待对方释放锁导致阻塞。而活锁的意思是线程没有阻塞，还活着呢。\n当多个线程都在运行并且修改各自的状态，而其他线程彼此依赖这个状态，导致任何一个线程都无法继续执行，只能重复着自身的动作和修改自身的状态，这种场景就是发生了活锁\n如果大家还有疑惑，那我再举一个生活中的例子，大家平时在走路的时候，迎面走来一个人，两个人互相让路，但是又同时走到了一个方向，如果一直这样重复着避让，这俩人就是发生了活锁\n饥饿 如果一个线程无其他异常却迟迟不能继续运行，那基本是处于饥饿状态了\n常见有几种场景:\n高优先级的线程一直在运行消耗CPU，所有的低优先级线程一直处于等待 一些线程被永久堵塞在一个等待进入同步块的状态，而其他线程总是能在它之前持续地对该同步块进行访问 有一个非常经典的饥饿问题就是哲学家用餐问题，如下图所示，有五个哲学家在用餐，每个人必须要同时拿两把叉子才可以开始就餐，如果哲学家1和哲学家3同时开始就餐，那哲学家2、4、5就得饿肚子等待了 性能问题 前面讲到了线程安全和死锁、活锁这些问题会影响多线程执行过程，如果这些都没有发生，多线程并发一定比单线程串行执行快吗，答案是不一定，因为多线程有 创建线程和 线程上下文切换的开销\n创建线程是直接向系统申请资源的，对操作系统来说创建一个线程的代价是十分昂贵的，需要给它分配内存、列入调度等\n线程创建完之后，还会遇到 线程上下文切换 CPU是很宝贵的资源，速度也非常快，为了保证雨露均沾，通常会给不同的线程分配 时间片，当CPU从执行一个线程切换到执行另一个线程时，CPU需要保存当前线程的本地数据、程序指针等状态，并加载下一个要执行的线程的本地数据、程序指针等，这个开关被称为上下文切换\n一般减少上下文切换的方法有：无锁并发编程、CAS 算法、使用协程等\n总结 多线程用好了可以让程序的效率成倍提升，用不好可能比单线程还要慢 ","permalink":"https://lesanouo.github.io/blog/posts/code/166939200004/","summary":"\u003cp\u003e单线程与多线程可以看作是：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e单线程为在一个单向行驶的道路上，每辆汽车都遵守交通规则\u003c/li\u003e\n\u003cli\u003e多线程为多条车道，这样在同一时间内，通行的车辆数远远大于单车道\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e然而扩充了车道后问题就没那么简单了，车道一旦多起来\u003cstrong\u003e加塞\u003c/strong\u003e的场景就会越来越多，出现碰撞后也会影响整条马路的通行效率，这样多车道就不一定比单车道更快了\u003c/p\u003e","title":"多线程下的琐事"},{"content":".net 基础 1、Task和Thread有什么区别\n2、当执行遇到await的时候会执行什么动作\n3、事件和委托之间的区别，Action和func的区别\nhttps://www.cnblogs.com/RaindayXia/p/5261797.html\nhttp://mikeblog.cn/article/details/5236\n4、Dictionary在多线程并发的情况下会出现什么问题，ConcurrentDictionary之间的区别\nhttps://blog.csdn.net/xiaouncle/article/details/122011337\n5、EF 在没有执行前，比如还没有Tolist()等情况下，做了什么事情\n6、使用EF有没有遇到过什么问题？当时我的回答是在多线程的情况下更新实体，更新不了，必须重新取一次，才能更新，也就是跨线程了\n7、IQueryable接口的作用\nhttps://zhuanlan.zhihu.com/p/47776558\nhttps://www.cnblogs.com/zhaopei/p/IQueryable-IQueryProvider.html\n8、说说垃圾回收机制\nhttps://www.jianshu.com/p/cc57aa7f3824\n9、MVC里面注册管道处理模型的步骤，MVC有哪些过滤器，在什么样的场景下适合使用，分别介绍下。过滤器的注册方式\nhttps://blog.csdn.net/qq_36330228/article/details/95766103\nhttps://docs.microsoft.com/zh-cn/aspnet/core/mvc/controllers/filters?view=aspnetcore-6.0\n10、AOP、IOC的作用\nhttps://www.cnblogs.com/wswind/p/aop_in_dotnet.html\nhttps://www.cnblogs.com/jlion/p/12392461.html\n11、设计模式，一般都是问比较常用的，比如单例的三要素、工厂、代理、适配器，最好举几个例子\n12、泛型里面的协变、逆变的作用\nhttps://www.cnblogs.com/wangbaicheng1477865665/p/OutIn.html\n13、C#8.0新增的语法，你知道的有哪些\n.net Core 1、.net Core启动执行顺序\n2、三个依赖注入方式，生命周期、泛型注入、获取实例有哪几种方式\n3、.net Core和 .net framework之间有什么不同\n4、读取配置文件里面的接口IOptionsSnapshot、IOptionsMonitor之间的区别\nhttps://www.cnblogs.com/wenhx/p/ioptions-ioptionsmonitor-and-ioptionssnapshot.html\n5、读取配置文件，怎么保证修改后每次都是读取到最新的\n6、配置环境变量的作用\nhttps://zhuanlan.zhihu.com/p/361004968\n7、JWT和Cookie之间的区别\nhttps://www.cnblogs.com/gj0151/p/15333826.html\n8、什么是跨域、同源，怎么防止跨域请求\n框架 1、Quartz.net创建任务的三大对象，具体说下每个对象是用来做什么的，自己有做过扩展么，说下IJobListener、ITriggerListener接口里面的方法，怎么防止Job在同一时间重复执行\nhttps://www.cnblogs.com/PatrickLiu/p/10193973.html\nhttps://www.coder.work/article/1575162\n2、Abp里面集成了哪些组件，事件总线你是怎么用的，注册实例有哪几种方式，说下Abp的启动流程， 你知道Application层暴露服务是怎么实现的么，需要注意哪些点 ！！！\n3、Autofac和.net Core原生的注入，有什么区别，什么样的场景下适合用Autofac属性注入\nhttps://www.cnblogs.com/liang24/p/14541650.html\n中间件 1、说下Redis里面的五大类型吧，分别适合什么样的场景使用，什么是缓存穿透、缓存雪崩，怎么避免这种情况发生，有搭建过集群么，集群的模式有哪几种，说下持久化RDB和AOF的方式区别、什么是哈希槽\nhttps://developer.aliyun.com/article/712113\nhttps://cloud.tencent.com/developer/article/1769953\n2、介绍下RabbitMQ的四种路由，怎么设置插队，说下消息确认的方式，Tx、Confirm二种事务模式的区别\nhttps://developer.aliyun.com/article/769883\nhttps://cloud.tencent.com/developer/article/1487995\nhttps://writing-bugs.blog.csdn.net/article/details/102935393\n3、说下ElasticSearch的常用的数据类型，keyWord和text的区别，说下分词器的作用\n4、 Apollo有哪些功能，大概的说下\nhttps://www.cnblogs.com/edisonchou/p/netcore_microservice_apollo_foundation.html\n微服务 1、如何设计一个高可用的微服务架构？一开始可以简单的说下，不要说的太细了，如果是问到里面的细节的话，最好仔细的去回答。这个问题是我面试架构师的时候被问到的，所以普通的开发可能不会问。\n2、说说你对DDD了解的一个深度吧，说下领域是怎么划分的，介绍下值对象、聚合、聚合根，实体之间的联系。什么样的情况下聚合根当做一个整体使用，限界上下文的作用，你有没有自己独立搭建过项目，大概说下你是怎么分层的，每一层之间的联系是什么\nhttps://zhuanlan.zhihu.com/p/91525839\nhttps://developer.aliyun.com/article/716908\n3、介绍下Polly里面的策略，失败重试、服务降级、失败降级、超时处理等\nhttps://www.cnblogs.com/willick/p/polly.html\n4、HttpClient创建的三种模式，请求拦截器的作用\n5、gRPC有什么特点，Protocol Buffers序列化的原理\n6、用过identityserver4么，如果说用过，会问你在项目里面是怎么用的，和JWT有什么区别，需要注意哪些点\n7、dockerfile的编写，编写dockerfile常用的指令，分别介绍下\n8、优化镜像有哪几种方式？我当时回答是 From基础镜像找小一点的，尽量使用alpine，或者使用多阶段构建。\n9、 kubernetes和Docker之间的区别？搭建一个高可用的集群，需要用到哪些组件？\n这是我的回答：nginx、Keepalived、HAProxy、Calico、metricsServer、CoreDNS、KubeProxy\n10、什么是Restful？说下你在项目里面是怎么设计Api的。\n数据库 1、 聚集索引和非聚集索引的区别\nhttps://cloud.tencent.com/developer/article/1541265\n2、 说下存储过程吧，你平时用的多么，说下优点与缺点\nhttps://cloud.tencent.com/developer/article/1338545\n3、 说下建表的三大范式\n4、 怎么看执行计划，你平时是怎么优化SQL语句\nhttps://www.cnblogs.com/powercto/p/14382208.html\n5、 事务隔离级别，什么是悲观锁，这个问题出现率比较低\nhttps://developer.aliyun.com/article/743691\n算法 一般的公司很少有算法题，出现比较高的是一些外企、一线互联网公司，像我最近去面的微软、iHerb、lexisnexis，直接在白板、白纸上写，如果写不出，可能下面的面试没法继续聊了， Leetcode上面的简单和中等的题要通过。每天抽时间多刷一刷。这样长期积累对自己的算法功底、代码的健壮性能提高很多。\n下面是今年面试遇到的一些算法题\nN叉树的最大深度 平衡二叉树 爬楼梯 寻找两个正序数组的中位数 两个数组的交集 重新排列字符串 排序链表 排序算法 最近的请求次数 斐波那契数列\n我目前已经积累了较多工作经验 原公司个人成长空间比较局限，工作内容更偏向于重复性的作业无法满足我的个人职业发展需求，所以决定看看其他机会\n","permalink":"https://lesanouo.github.io/blog/posts/code/166939200003/","summary":"\u003ch2 id=\"net-基础\"\u003e.net 基础\u003c/h2\u003e\n\u003cp\u003e1、Task和Thread有什么区别\u003c/p\u003e\n\u003cp\u003e2、当执行遇到await的时候会执行什么动作\u003c/p\u003e\n\u003cp\u003e3、事件和委托之间的区别，Action和func的区别\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://www.cnblogs.com/RaindayXia/p/5261797.html\"\u003ehttps://www.cnblogs.com/RaindayXia/p/5261797.html\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"http://mikeblog.cn/article/details/5236\"\u003ehttp://mikeblog.cn/article/details/5236\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e4、Dictionary在多线程并发的情况下会出现什么问题，ConcurrentDictionary之间的区别\u003c/p\u003e","title":"关于.NET的面试笔记"},{"content":"如电脑设置了网络代理，会导致一些软件工具不能正常工作。查找了网上许多解决方案，总结如下。\nGit 设置全局Config代理 git config --global http.proxy http://server:port git config --global https.proxy http://server:port git config --global http.https://github.com.proxy http://server:port git config --global https.https://github.com.proxy http://server:port 去除代理设置 git config --global --unset http.proxy git config --global --unset https.proxy git config --global --unset http.https://github.com.proxy git config --global --unset https.https://github.com.proxy 当我使用这种方式时没有效果\n使用clone时配置代理 git clone -c http.proxy=\u0026#34;server:port\u0026#34; https://github.com/LesanOuO/lesan-homepage.git NPM 全局设置代理 npm config set proxy http://server:port\n配置https代理（设置了proxy就不需要设置https-proxy） npm config set https-proxy http://server:port\n如果需要代理用户名和密码 npm config set proxy http://username:password@server:port npm confit set https-proxy http://username:password@server:port 取消代理 npm config delete proxy npm config delete https-proxy npm config set proxy null npm config set https-proxy null Maven 需要在 settings.xml中配置 proxies节点\n... \u0026lt;proxies\u0026gt; \u0026lt;proxy\u0026gt; \u0026lt;id\u0026gt;optional\u0026lt;/id\u0026gt; \u0026lt;active\u0026gt;true\u0026lt;/active\u0026gt; \u0026lt;protocol\u0026gt;http\u0026lt;/protocol\u0026gt; \u0026lt;host\u0026gt;127.0.0.1\u0026lt;/host\u0026gt; \u0026lt;port\u0026gt;8888\u0026lt;/port\u0026gt; \u0026lt;/proxy\u0026gt; \u0026lt;/proxies\u0026gt; ... Yum 在文件 /etc/yum.conf 中添加以下设置\nproxy=http://192.168.1.1:8080\rproxy_username=username\rproxy_password=password 也可以通过设置环境变量配置\nexport http_proxy=\u0026#34;http://username:password@192.168.1.1:8080\u0026#34;\rexport https_proxy=\u0026#34;http://username:password@192.168.1.1:8080\u0026#34; 清除环境变量取消代理配置 unset http_proxy\n","permalink":"https://lesanouo.github.io/blog/posts/code/166939200002/","summary":"\u003cp\u003e如电脑设置了网络代理，会导致一些软件工具不能正常工作。查找了网上许多解决方案，总结如下。\u003c/p\u003e\n\u003ch2 id=\"git\"\u003eGit\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e设置全局Config代理\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit config --global http.proxy http://server:port\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit config --global https.proxy http://server:port\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit config --global http.https://github.com.proxy http://server:port\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit config --global https.https://github.com.proxy http://server:port\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e去除代理设置\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit config --global --unset http.proxy\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit config --global --unset https.proxy\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit config --global --unset http.https://github.com.proxy\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit config --global --unset https.https://github.com.proxy\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cblockquote\u003e\n\u003cp\u003e当我使用这种方式时没有效果\u003c/p\u003e","title":"设置网络代理后需要注意"},{"content":"在编写数据库文档时，我们常常需要写表结构文档，这时候就需要一些方法来节约我们写文档的时间。\n我通过网络上的资料，总结了 MySQL 及 SQL Server 的通过SQL语句导出数据库表结构的方法。\nMySQL SELECT COLUMN_NAME 列名, COLUMN_TYPE 数据类型, DATA_TYPE 字段类型, CHARACTER_MAXIMUM_LENGTH 长度, IS_NULLABLE 是否为空, COLUMN_DEFAULT 默认值, COLUMN_COMMENT 备注 FROM INFORMATION_SCHEMA.COLUMNS WHERE table_schema = \u0026#39;数据库名称\u0026#39; -- 数据库名称 AND table_name = \u0026#39;表名\u0026#39; -- 表名 -- 如果不写的话，默认会查询出所有表中的数据，这样可能就分不清到底哪些字段是哪张表中的了，所以还是建议写上要导出的名名称 SQL Server SELECT 表名 = Case When A.colorder=1 Then D.name Else \u0026#39;\u0026#39; End, 表说明 = Case When A.colorder=1 Then isnull(F.value,\u0026#39;\u0026#39;) Else \u0026#39;\u0026#39; End, 字段序号 = A.colorder, 字段名 = A.name, 字段说明 = isnull(G.[value],\u0026#39;\u0026#39;), 标识 = Case When COLUMNPROPERTY( A.id,A.name,\u0026#39;IsIdentity\u0026#39;)=1 Then \u0026#39;√\u0026#39;Else \u0026#39;\u0026#39; End, 主键 = Case When exists(SELECT 1 FROM sysobjects Where xtype=\u0026#39;PK\u0026#39; and parent_obj=A.id and name in ( SELECT name FROM sysindexes WHERE indid in( SELECT indid FROM sysindexkeys WHERE id = A.id AND colid=A.colid))) then \u0026#39;√\u0026#39; else \u0026#39;\u0026#39; end, 类型 = B.name, 占用字节数 = A.Length, 长度 = COLUMNPROPERTY(A.id,A.name,\u0026#39;PRECISION\u0026#39;), 小数位数 = isnull(COLUMNPROPERTY(A.id,A.name,\u0026#39;Scale\u0026#39;),0), 允许空 = Case When A.isnullable=1 Then \u0026#39;√\u0026#39;Else \u0026#39;\u0026#39; End, 默认值 = isnull(E.Text,\u0026#39;\u0026#39;) FROM syscolumns A Left Join systypes B On A.xusertype=B.xusertype Inner Join sysobjects D On A.id=D.id and D.xtype=\u0026#39;U\u0026#39; and D.name\u0026lt;\u0026gt;\u0026#39;dtproperties\u0026#39; Left Join syscomments E on A.cdefault=E.id Left Join sys.extended_properties G on A.id=G.major_id and A.colid=G.minor_id Left Join sys.extended_properties F On D.id=F.major_id and F.minor_id=0 where d.name=\u0026#39;表名\u0026#39; --如果只查询指定表,加上此条件 Order By A.id,A.colorder ","permalink":"https://lesanouo.github.io/blog/posts/code/166939200001/","summary":"\u003cp\u003e在编写数据库文档时，我们常常需要写表结构文档，这时候就需要一些方法来节约我们写文档的时间。\u003c/p\u003e\n\u003cp\u003e我通过网络上的资料，总结了 \u003ccode\u003eMySQL\u003c/code\u003e 及 \u003ccode\u003eSQL Server\u003c/code\u003e 的通过SQL语句导出数据库表结构的方法。\u003c/p\u003e","title":"通过SQL导出数据库表结构"},{"content":"图片文字环绕 .any-shape { width: 300px; float: left; shape-outside: circle(50%); } shape-outside 属性定义了一个可以是非矩形的形状，相邻的内联内容应围绕该形状进行包装。默认情况下，内联内容包围其边距框; shape-outside提供了一种自定义此包装的方法，可以将文本包装在复杂对象周围而不是简单的框中。\n:where() 简化代码 当对多个元素应用相同的样式时，CSS 可能如下：\n.parent div, .parent .title, .parent #article { color: red; } 这样代码看起来可读性不是很好，:where() 伪类这时就派上用场了。:where() 伪类函数接受选择器列表作为它的参数，将会选择所有能被该选择器列表中任何一条规则选中的元素。\n上面的代码使用:where()就可以这么写：\n.parent :where(div, .title, #article) { color: red; } 实现平滑滚动 可以使用CSS的scroll-behavior属性来实现在网页上进行平滑滚动，而无需编写复杂的 JavaScript 或使用插件。可以用于页面锚点之间的滚动或者返回顶部等功能。\nhtml { scroll-behavior: smooth; } 当用户手动导航或者 CSSOM scrolling API 触发滚动操作时，CSS 属性 scroll-behavior 为一个滚动框指定滚动行为，其他任何的滚动，例如那些由于用户行为而产生的滚动，不受这个属性的影响。在根元素中指定这个属性时，它反而适用于视窗。当该属性的值为smooth时就可以实现页面的平滑滚动。\n背景混合模式 在CSS中可以使用 background-blend-mode 来实现元素背景的混合：\n.blend-1 { background-image: url(https://duomly.nyc3.digitaloceanspaces.com/articles/coding/alps-lake.jpg); width: 100vw; height: 500px; background-size: cover; } .blend-2 { background-image: url(https://duomly.nyc3.digitaloceanspaces.com/articles/coding/alps-lake.jpg); width: 100vw; height: 500px; background-color: #20126f; background-size: cover; background-blend-mode: overlay; } 上面的图片是单纯的一张图片背景，下面的图片是背景图片和背景颜色混合而成的。background-blend-mode 属性就用于定义了背景层的混合模式（图片与颜色）。支持的背景混合模式：正常|乘法|屏幕|叠加|变暗|变亮|颜色减淡|饱和度|颜色|亮度；\n图像填充文字效果 要想实现图像填充文字效果，可以设置 background-clip: text 以使文字背景作为整个区域的背景，文字之外的区域将被裁掉。配合透明的文字颜色，就可以实现图像填充文字效果了：\nh1 { background-image: url(\u0026#39;./flower.jpg\u0026#39;); background-clip: text; -webkit-background-clip: text; color: transparent; background-color: white; } 注意，在使用此技术时可以指定一个背景颜色来作为后备值，以防图像因为某种原因而无法加载。\n文字描边效果 在 CSS 中可以使用 text-stroke 属性使文本更易读，它会向文本添加轮廓效果。\nh1 { color: #fff; font-size: 80px; -webkit-text-stroke: 2px crimson; text-stroke: 2px crimson; } 注意，text-stroke 属性值中有两部分，第一部分是文字描边的宽度，第二部分是文字描边的颜色。\n将文本设为大写或小写 大写或小写字母可以不必在 HTML中设置。可以在 CSS 中使用text-transform熟悉来强制任何文本为大写或小写。\n/* 大写 */ .upper { text-transform: uppercase; } /* 小写 */ .lower { text-transform: lowercase; } text-transform 属性专门用于控制文本的大小写，当值为uppercase时会将文本转为大写，当值为capitalize时会将文本转化为小写，当值为capitalize时会将每个单词以大写字母开头。\n暂停/播放伪类 使用 :paused 伪类可以为处于暂停状态的媒体元素设置样式，那自然就还有 :playing 伪类，它可以为处于播放状态的媒体元素设置样式。\nvideo:paused { opacity: 0.6; } 需要注意，目前仅 Safari 支持该伪类:paused\n毛玻璃特效 可以使用 CSS 中的 backdrop-filter 属性来实现毛玻璃特效：\n.login { backdrop-filter: blur(5px); } backdrop-filter 属性可以为一个元素后面区域添加图形效果（如模糊或颜色偏移）。因为它适用于元素背后的所有元素，为了看到效果，必须使元素或其背景至少部分透明。\n自定义光标 我们可以通 CSS 中的cursor属性来自定义光标的样式，只需要指定自定义光标的图片路径即可：\nbody{ cursor: url(\u0026#34;path-to-image.png\u0026#34;), auto; } 文本强调效果 可以使用 text-emphasis 属性将强调标记应用于文本元素。可以指定包括表情符号在内的任何字符串作为强调标记。\nh1 { text-emphasis: \u0026#34;⭐️\u0026#34;; } 注意，text-emphasis 是一个简写属性，用于在一个声明中设置 text-emphasis-style 和 text-emphasis-color。强调装饰符的字号是主文字内容字号的一半，例如假设文字是20px，则上方的强调字符的大小是10px。\n更写书写方向 通常我们常见的网页文字是从左向右布局的，在CSS中可以使用 writing-mode 属性来指定文本在网页上的布局方式，即水平或垂直。该属性有多个属性值：\nhorizontal-tb：水平方向自上而下的书写方式。即 left-right-top-bottom vertical-rl：垂直方向自右而左的书写方式。即 top-bottom-right-left vertical-lr：垂直方向内内容从上到下，水平方向从左到右 sideways-rl：内容垂直方向从上到下排列 sideways-lr：内容垂直方向从下到上排列 h1 { writing-mode: sideways-lr; } 悬停缩放效果 .img-container { height: 250px; width: 250px; overflow: hidden; } .img-container img { height: 100%; width: 100%; object-fit: cover; transition: transform 200m ease-in; } img:hover { transform: scale(1.2); } transform 属性应用于元素的2D或3D转换。这个属性允许将元素旋转，缩放，移动，倾斜等。当值为scale就可以实现元素的 2D 缩放转换。\n裁剪各种形状 可以使用 clip-path 属性来创建各种有趣的视觉效果，例如将元素剪裁成自定义形状，如三角形或六边形。\ndiv { height: 150px; width: 150px; background-color: crimson; } 三角形如下：\nclip-path: polygon(50% 0%, 0% 100%, 100% 100%); 六边形如下：\nclip-path: polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%); 可以使用 clip-path 在线工具在制作各种图形：https://bennettfeely.com/clippy/\n检测属性支持 在 CSS 中可以使用 @support 规则来检测对 CSS 特性的支持：\n@supports (accent-color: #74992e) { blockquote { color: crimson; } } 如果支持该属性将运行内容定义的样式。\n可选项样式 在 CSS 中可以使用 :optional 伪类来设置没有 required 属性的表单字段的样式，例如 input、select 和 textarea。\n*:optional{ background-color: green; } 实现首字下沉 我们可以使用::first-letter来实现文本首字母的下沉：\np.texts:first-letter { font-size: 200%; color: #8A2BE2; } :first-letter选择器用来指定元素第一个字母的样式，它仅适用于在块级元素中。效果如下：\n实现正方形 我们可以通过CSS中的纵横比来实现一个正方形，这样只需要设置一个宽度即可：\n.square { background: #8A2BE2; width: 25rem; aspect-ratio: 1/1; } aspect-ratio 媒体属性可以用来测试视口的宽高比。当然上述例子比较简单，来看看MDN中给出的纵横比的示例：\n/* 最小宽高比 */ @media (min-aspect-ratio: 8/5) { div { background: #9af; /* blue */ } } /* 最大宽高比 */ @media (max-aspect-ratio: 3/2) { div { background: #9ff; /* cyan */ } } /* 明确的宽高比, 放在最下部防止同时满足条件时的覆盖*/ @media (aspect-ratio: 1/1) { div { background: #f9a; /* red */ } } 这里通过媒体查询在页面视口不同纵横比时，显示不同的背景颜色。\n","permalink":"https://lesanouo.github.io/blog/posts/snippet/css/","summary":"\u003ch2 id=\"图片文字环绕\"\u003e图片文字环绕\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-css\" data-lang=\"css\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nc\"\u003eany-shape\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"k\"\u003ewidth\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"mi\"\u003e300\u003c/span\u003e\u003cspan class=\"kt\"\u003epx\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"k\"\u003efloat\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"kc\"\u003eleft\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"k\"\u003eshape-outside\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"nb\"\u003ecircle\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e50\u003c/span\u003e\u003cspan class=\"kt\"\u003e%\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003ccode\u003eshape-outside\u003c/code\u003e 属性定义了一个可以是非矩形的形状，相邻的内联内容应围绕该形状进行包装。默认情况下，内联内容包围其边距框; \u003ccode\u003eshape-outside\u003c/code\u003e提供了一种自定义此包装的方法，可以将文本包装在复杂对象周围而不是简单的框中。\u003c/p\u003e","title":"CSS 代码片段"},{"content":"基本使用 静态文件（常见的有HTML，CSS，图片和JS等资源）可以通过 .NET Core 应用直接提供给客户端。还有一些比较常用的文件（PDF或者一些需要下载的文件）也是需要通过静态文件的方式提供下载的，如果没有搭建文件管理的服务器的话，通过静态文件的方式下载也是不错的选择。\n静态文件一般位于网站根目录的 wwwroot 文件夹下，可以通过相对根的路径来访问文件夹中的文件，如 http://ip:port/filename\n使用静态文件服务前，需要配置中间件，把静态文件中间件加入到管道中。静态文件一般会默认配置，在Configure方法中调用app.UseStaticFiles()。app.UseStaticFiles() 使得web root(默认为wwwroot)下的文件可以被访问。同时可以通过UseStaticFiles方法将其他目录下的内容也可以向外提供：\n// 假如wwwroot外面有一个MyStaticFiles文件夹，要访问文件夹里面的资源 app.UseStaticFiles(new StaticFileOptions() { FileProvider = new PhysicalFileProvider( Path.Combine(Directory.GetCurrentDirectory(), @\u0026#34;MyStaticFiles\u0026#34;)), //用于定位资源的文件系统 RequestPath = new PathString(\u0026#34;/StaticFiles\u0026#34;) //请求地址 }); // 现在可以通过http://ip:port/StaticFiles/filename 来访问文件夹下的内容 静态文件授权 静态文件组件默认不提供授权检查。任何通过静态文件中间件访问的文件都是公开的。要想给文件授权，可以将文件保存在wwwroot之外，并将目录设置为可被静态文件中间件能够访问，同时通过一个controller action来访问文件，在action中授权后返回FileResult。\n目录浏览 目录浏览允许网站用户看到指定目录下的目录和文件列表。基于安全考虑，默认情况下是禁止目录访问功能。在Startup中Configure方法调用UseDirectoryBrowser扩展方法可以开启网络应用目录浏览：\npublic void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory) { app.UseStaticFiles(); app.UseDirectoryBrowser(new DirectoryBrowserOptions() { FileProvider = new PhysicalFileProvider( Path.Combine(Directory.GetCurrentDirectory(),@\u0026#34;wwwroot\\images\u0026#34;)), RequestPath = new PathString(\u0026#34;/MyImages\u0026#34;) //如果不指定RequestPath，会将PhysicalFileProvider中的路径参数作为默认文件夹，替换掉wwwroot }); } 然后在Startup中CongigureServices方法调用AddDirectoryBrowser扩展方法，这样就可以通过访问http://\u0026lt;app\u0026gt;/MyImages浏览wwwroot/images文件夹中的目录，但是不能访问文件：\n要想访问具体文件需要调用UseStaticFiles配置：\npublic void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory) { app.UseStaticFiles(); app.UseStaticFiles(new StaticFileOptions() { FileProvider = new PhysicalFileProvider( Path.Combine(Directory.GetCurrentDirectory(), @\u0026#34;wwwroot\\images\u0026#34;)), //用于定位资源的文件系统 RequestPath = new PathString(\u0026#34;/MyImages\u0026#34;) }); app.UseDirectoryBrowser(new DirectoryBrowserOptions() { FileProvider = new PhysicalFileProvider( Path.Combine(Directory.GetCurrentDirectory(),@\u0026#34;wwwroot\\images\u0026#34;)), RequestPath = new PathString(\u0026#34;/MyImages\u0026#34;) }); } UseFileServer 通过 UseFileServer 集合了UseStaticFiles,UseDefaultFiles,UseDirectoryBrowser。可以实现类似文件服务器的功能\n调用app.UseFileServer(); 可以获得静态文件和默认文件，但不允许直接访问目录。需要调用app.UseFileServer(enableDirectoryBrowsing:true); 才能启用目录浏览功能。\n如果想要访问wwwroot以外的文件，需要配置一个FileServerOptions对象\npublic void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory) { app.UseStaticFiles();//如果不调用，将不会启动默认功能。 app.UseFileServer(new FileServerOptions() { FileProvider = new PhysicalFileProvider( Path.Combine(Directory.GetCurrentDirectory(), @\u0026#34;MyStaticFiles\u0026#34;)), RequestPath = new PathString(\u0026#34;/StaticFiles\u0026#34;), EnableDirectoryBrowsing = true }); } 注意，如果将enableDirectoryBrowsing设置为true，需要在ConfigureServices中调用services.AddDirectoryBrowser();如果默认文件夹下有默认页面，将显示默认页面，而不是目录列表。\nFileExtensionContentTypeProvider FileExtensionContentTypeProvider类包含一个将文件扩展名映射到MIME内容类型的集合。\npublic void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory) { var provider = new FileExtensionContentTypeProvider(); provider.Mappings[\u0026#34;.htm3\u0026#34;] = \u0026#34;text/html\u0026#34;; provider.Mappings[\u0026#34;images\u0026#34;] = \u0026#34;iamge/png\u0026#34;; provider.Mappings.Remove(\u0026#34;.mp4\u0026#34;); app.UseStaticFiles(new StaticFileOptions() { FileProvider = new PhysicalFileProvider( Path.Combine(Directory.GetCurrentDirectory(), @\u0026#34;MyStaticFiles\u0026#34;)), RequestPath = new PathString(\u0026#34;/StaticFiles\u0026#34;), ContentTypeProvider = provider }); } 非标准的内容类型 如果用户请求了一个未知的文件类型，静态文件中间件将会返回HTTP 404响应。如果启用目录浏览，则该文件的链接将会被显示，但URL会返回一个HTTP404错误。\n使用UseStaticFiles方法可以将未知类型作为指定类型处理：\napp.UseStaticFiles(new StaticFileOptions() { ServeUnknownFileTypes = true, DefaultContentType = \u0026#34;application/x-msdownload\u0026#34; }); 对于未识别的，默认为application/x-msdownload，浏览器将会下载这些文件。\n本文参考自：https://www.jb51.net/article/244297.htm\n","permalink":"https://lesanouo.github.io/blog/posts/code/165798720001/","summary":"\u003ch2 id=\"基本使用\"\u003e基本使用\u003c/h2\u003e\n\u003cp\u003e静态文件（常见的有HTML，CSS，图片和JS等资源）可以通过 .NET Core 应用直接提供给客户端。还有一些比较常用的文件（PDF或者一些需要下载的文件）也是需要通过静态文件的方式提供下载的，如果没有搭建文件管理的服务器的话，通过静态文件的方式下载也是不错的选择。\u003c/p\u003e","title":"如何在.NET中开启静态文件访问"},{"content":"在维护服务器时，发现docker所在盘容量已满，导致mongodb插入数据失败从而崩溃。由此记录修改Linux中Dockder位置时遇到的问题\n一些命令 df 命令 df命令来自于英文词组”Disk Free“的缩写，其功能是用于显示系统上磁盘空间的使用量情况。\n常常使用 df -h 以容易阅读的方式显示\nln 命令 Linux ln（英文全拼：link files）命令是一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接。\nLinux文件系统中，有所谓的链接(link)，我们可以将其视为档案的别名，而链接又可分为两种 : 硬链接(hard link)与软链接(symbolic link)，硬链接的意思是一个档案可以有多个名称，而软链接的方式则是产生一个特殊的档案，该档案的内容是指向另一个档案的位置。硬链接是存在同一个文件系统中，而软链接却可以跨越不同的文件系统。\n通常我们都使用 ln -s log2013.log link2013 来创建软链接\nlsof netstat 命令 Linux 查看端口占用情况可以使用 lsof 和 netstat 命令。\n可使用 lsof -i:端口号 netstat -tunlp | grep 端口号\nkill 命令 Linux kill 命令用于删除执行中的程序或工作。\n可使用 kill -9 PID 彻底杀死进程\ntop 命令 Linux top命令用于实时显示 process 的动态。\nfree 命令 Linux free命令用于显示内存状态。\ndu 命令 Linux du （英文全拼：disk usage）命令用于显示目录或文件的大小。\n通常使用 du -h 提高信息的可读性\n修改 Docker 存储位置 通过软链接 // 停止 docker 服务 systemctl stop Docker // 移动整个 /var/lib/docker 目录到目标路径(/data/docker) mv /var/lib/docker /data/docker // 创建软链接 ln -s /root/docker /var/lib/docker // 重启 docker systemctl start docker 修改 docker 配置文件 // 停止 docker 服务 systemctl stop docker // 移动整个 /var/lib/docker 目录到目标路径(/data/docker) mv /var/lib/docker /data/docker // 修改 docker.service 文件 vim /usr/lib/systemd/system/docker.service // 重启 docker 服务 systemctl daemon-reload systemctl start docker // 查看配置是否生效 docker info | grep \u0026#34;Docker Root Dir\u0026#34; 其中 docker.service 修改的内容为：\n在 ExecStart=/usr/bin/dockerd 后面添加参数 --graph /data/docker\n结果如下：\nExecStart=/usr/bin/dockerd --graph /data/docker -H fd:// --containerd=/run/containerd/containerd.sock\rDocker 中 mongodb 出现错误 在更换了 docker 存储位置后， mongodb 启动后就一直报错 Failed to set up listener: SocketException: Permission denied ，原因是以为启动mongo时,无法写入mongo.socket文件到/tmp目录下\n查阅了网络上的多个教程，最终有效的是下面的解决方案：\n将本地的/tmp目录挂在到mongo容器中，如果是已启动的容器，可通过我的 docker为已启动容器添加挂载目录或端口映射 这篇文章进行挂载；如果是新启动的容器，只需要 -v /tmp:/tmp 即可\n","permalink":"https://lesanouo.github.io/blog/posts/code/165669120001/","summary":"\u003cp\u003e在维护服务器时，发现docker所在盘容量已满，导致mongodb插入数据失败从而崩溃。由此记录修改Linux中Dockder位置时遇到的问题\u003c/p\u003e","title":"Linux中修改Docker存储位置"},{"content":"在代码中遇到了网络请求编程时，往往需要异步编程才能给用户带来良好的体验，不会导致程序完全阻塞。\n其中的关键在于：\n异步方法：再执行完成前就立刻返回调用方法，在调用方法执行过程中完成任务 async/await 结构主要分为三个部分： 调用方法：该方法调用异步方法，然后在异步方法回调后继续执行后续程序 异步方法：该方法异步执行程序，在被调用后立即返回到调用方法 await 表达式：用于异步等待，指出需要异步执行的任务，且需要等待其完成。一个方法可以包含多个await 什么是异步 启动程序时，系统会在内存中创建一个新的进程。进程是构成运行程序资源的集合。在进程内部，有称为线程的内核对象，它代表的是真正的执行程序。系统会在 Main 方法的第一行语句就开始线程的执行。\n线程：\n默认情况，一个进程只包含一个线程，从程序的开始到执行结束 线程可以派生自其它线程，所以一个进程可以包含不同状态的多个线程，来执行程序的不同部分 一个进程中的多个线程，将共享该进程的资源 系统为处理器执行所规划的单元是线程，而非进程 下面我们来看一个简单的例子\nclass Program { // 创建计时器 private static readonly Stopwatch Watch = new Stopwatch(); private static void Main(string[] args) { // 启动计时器 Watch.Start(); const string url1 = \u0026#34;http://www.cnblogs.com/\u0026#34;; const string url2 = \u0026#34;http://www.cnblogs.com/liqingwen/\u0026#34;; // 两次调用 CountCharactersAsync 方法（异步下载某网站内容，并统计字符的个数） Task\u0026lt;int\u0026gt; t1 = CountCharactersAsync(1, url1); Task\u0026lt;int\u0026gt; t2 = CountCharactersAsync(2, url2); // 三次调用 ExtraOperation 方法（主要是通过拼接字符串达到耗时操作） for (var i = 0; i \u0026lt; 3; i++) { ExtraOperation(i + 1); } // 控制台输出 Console.WriteLine($\u0026#34;{url1} 的字符个数：{t1.Result}\u0026#34;); Console.WriteLine($\u0026#34;{url2} 的字符个数：{t2.Result}\u0026#34;); Console.Read(); } // 统计字符个数 private static async Task\u0026lt;int\u0026gt; CountCharactersAsync(int id, string address) { var wc = new WebClient(); Console.WriteLine($\u0026#34;开始调用 id = {id}：{Watch.ElapsedMilliseconds} ms\u0026#34;); var result = await wc.DownloadStringTaskAsync(address); Console.WriteLine($\u0026#34;调用完成 id = {id}：{Watch.ElapsedMilliseconds} ms\u0026#34;); return result.Length; } // 额外操作 private static void ExtraOperation(int id) { // 这里是通过拼接字符串进行一些相对耗时的操作，如果对字符串拼接有性能要求的话应该使用 StringBuilder var s = \u0026#34;\u0026#34;; for (var i = 0; i \u0026lt; 6000; i++) { s += i; } Console.WriteLine($\u0026#34;id = {id} 的 ExtraOperation 方法完成：{Watch.ElapsedMilliseconds} ms\u0026#34;); } } 同步情况下的调用顺序为： 异步情况下的调用顺序为： 从上面两种情况可以看出异步编程优势，现在我们来分析一下程序的步骤：\n从 Main 方法执行到 CountCharactersAsync(1, url1) 方法时，该方法会立即返回，然后才会调用它内部的方法开始下载内容。该方法返回的是一个 Task\u0026lt;int\u0026gt; 类型的占位符对象，表示计划进行的工作。这个占位符最终会返回 int 类型的值 这样就可以不必等 CountCharactersAsync(1, url1) 方法执行完成就可以继续进行下一步操作。到执行 CountCharactersAsync(2, url2) 方法时，跟 步骤① 一样返回 Task\u0026lt;int\u0026gt; 对象 然后，Main 方法继续执行三次 ExtraOperation 方法，同时两次 CountCharactersAsync 方法依然在持续工作 t1.Result 和 t2.Result 是指从 CountCharactersAsync 方法调用的 Task\u0026lt;int\u0026gt; 对象取结果，如果还没有结果的话，将阻塞，直有结果返回为止 async/await 结构 async/await 结构主要分为三个部分：\n调用方法：该方法调用异步方法，然后在异步方法回调后继续执行后续程序 异步方法：该方法异步执行程序，在被调用后立即返回到调用方法 await 表达式：用于异步等待，指出需要异步执行的任务，且需要等待其完成。一个方法可以包含多个await 示例结构分析如下： await 都做了些什么 为了了解程序 await 时，C#都做了些什么工作，我们就必须了解以下内容\n方法的状态 首先，方法内所有的本地变量的值都会被记住，包括\n方法的参数 在方法的作用域内定义的任何变量 任何其它变量，比如循环中使用到的计数变量 如果你的方法不是static的，则还要包括this变量。只有记住了this，当方法恢复执行(resume)时，才可以使用当前类的成员变量。 上述的这些都会被存储在.NET垃圾回收堆里的一个对象中。因此，当你使用await时，.NET就会创建这样一个对象，虽然它会占用一些资源，但在大多数情况下并不会导致性能问题。\nC#还要记住在方法内部await执行到了哪里——可以通过使用一个数字来表示当前方法中执行到了哪一个await关键字。\n具体如何使用await表达式？这其实没有限制，例如，await可以被用做一个大表达式的一部分，一个表达式也可能包含多个await.\nint myNum = await AlexsMethodAsync(await myTask, await StuffAsync());\n这样就对.NET运行时提出了额外的需求——当await一个表达式时，需要记住表达式剩余部分的状态。在上面的例子中，当程序执行await StuffAsync()时，await myTask的结果就需要被记录下来。.NET IL会将这类子表达式存储在栈上，因此当使用了await关键字时就需要把这个栈存储下来。\n在这之上，当程序执行到第一个await时，当前方法会返回——除非方法是async void，否则这时就会返回一个Task，因此调用者可以通过某种方式等待任务完成。C# 还必须把操作该返回Task的方法存储下来，这样当我们的方法完成后，前面返回的Task才会变为完成的状态，这样程序才会向上返回一层，回到方法的异步链中去继续执行。我们会在第14章探讨这些额外的机制。\n上下文（Context） C#在使用await时会记录各种各样的上下文，目的是当要继续执行方法时能够恢复这个上下文，这样就尽可能地将await的处理过程变得透明。这些上下文中最重要的就是同步上下文（sychronization context），通过它的帮助可以在指定类型的线程上恢复方法的执行。\n异步方法的结构 关键字：方法头使用 async 修饰。 要求：包含 N（N\u0026gt;0） 个 await 表达式（不存在 await 表达式的话 IDE 会发出警告），表示需要异步执行的任务。 返回类型：只能返回 3 种类型（void、Task 和 Task\u0026lt;T\u0026gt;）。Task 和 Task\u0026lt;T\u0026gt; 标识返回的对象会在将来完成工作，表示调用方法和异步方法可以继续执行。 参数：数量不限，但不能使用 out 和 ref 关键字。 命名约定：方法后缀名应以 Async 结尾。 其它：匿名方法和 Lambda 表达式也可以作为异步对象；async 是一个上下文关键字；关键字 async 必须在返回类型前。 本文参考自：\nhttps://www.cnblogs.com/tuyile006/p/12605523.html\nhttps://www.cnblogs.com/tuyile006/p/12605523.html\n","permalink":"https://lesanouo.github.io/blog/posts/code/165617280001/","summary":"\u003cp\u003e在代码中遇到了网络请求编程时，往往需要异步编程才能给用户带来良好的体验，不会导致程序完全阻塞。\u003c/p\u003e\n\u003cp\u003e其中的关键在于：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e异步方法：再执行完成前就立刻返回调用方法，在调用方法执行过程中完成任务\u003c/li\u003e\n\u003cli\u003easync/await 结构主要分为三个部分：\n\u003col\u003e\n\u003cli\u003e调用方法：该方法调用异步方法，然后在异步方法回调后继续执行后续程序\u003c/li\u003e\n\u003cli\u003e异步方法：该方法异步执行程序，在被调用后立即返回到调用方法\u003c/li\u003e\n\u003cli\u003eawait 表达式：用于异步等待，指出需要异步执行的任务，且需要等待其完成。一个方法可以包含多个await\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"什么是异步\"\u003e什么是异步\u003c/h2\u003e\n\u003cp\u003e启动程序时，系统会在内存中创建一个新的进程。进程是构成运行程序资源的集合。在进程内部，有称为线程的内核对象，它代表的是真正的执行程序。系统会在 Main 方法的第一行语句就开始线程的执行。\u003c/p\u003e","title":"C#中async和await异步编程"},{"content":"什么是 Thread 当我们提及多线程的时候会想到 Thread 和 Threadpool，这都是异步操作，Threadpool 其实就是 Thread 的集合，具有很多优势，不过在任务多的时候全局队列会存在竞争而消耗资源。Thread 默认为前台线程，主程序必须等线程跑完才会关闭，而 Threadpool 相反。\n总结：Threadpool 确实比 Thread 性能优，但是两者都没有很好的api区控制，如果线程执行无响应就只能等待结束，从而诞生了 Task 任务。\n什么是 Task Task 简单地看就是任务，那和 Thread 有什么区别呢？Task 的背后的实现也是使用了线程池线程，但它的性能优于ThreadPoll,因为它使用的不是线程池的全局队列，而是使用的本地队列，使线程之间的资源竞争减少。同时 Task 提供了丰富的API来管理线程、控制。但是相对前面的两种耗内存，Task 依赖于CPU对于多核的CPU性能远超前两者，单核的CPU三者的性能没什么差别。Task 有Wait、ContinueWith、Cancel等操作，有返回值。\nTask 与 Thread 的区别 Thread 类主要用于实现线程的创建以及执行。\nTask 类表示以异步方式执行的单个操作。\n1. Task 是基于 Thread 的，是比较高层级的封装，Task 最终还是需要 Thread 来执行 2. Task 默认使用后台线程执行，Thread 默认使用前台线程 public static void Main(string[] args) { Thread thread = new Thread(obj =\u0026gt; { Thread.Sleep(3000); }); thread.Start(); } 上面代码，主程序在3秒后结束。\npublic static void Main(string[] args) { Task\u0026lt;int\u0026gt; task = new Task\u0026lt;int\u0026gt;(() =\u0026gt; { Thread,Sleep(3000); return 1; }); task.Start(); } 而这段代码，会瞬间结束。\n3. Task 可以有返回值，Thread 没有返回值 虽然 Thread 可以通过 Start 方法参数来进行返回值处理，但十分不便。\npublic static void Main(string[] args) { Task task = new Task(LongRunningTask); task.Start(); Console.WriteLine(task.Result); } private static int LongRunningTask() { Thread.Sleep(3000); return 1; } 4. Task 可以执行后续操作，Thread 不能执行后续操作 static void Main(string[] args) { Task task = new Task(LongRunningTask); task.Start(); Task childTask = task.ContinueWith(SquareOfNumber); Console.WriteLine(\u0026#34;Sqaure of number is :\u0026#34;+ childTask.Result); Console.WriteLine(\u0026#34;The number is :\u0026#34; + task.Result); } private static int LongRunningTask() { Thread.Sleep(3000); return 2; } private static int SquareOfNumber(Task obj) { return obj.Result * obj.Result; } 5. Task 可取消任务执行，Thread 不行 static void Main(string[] args) { using (var cts = new CancellationTokenSource()) { Task task = new Task(() =\u0026gt; { LongRunningTask(cts.Token); }); task.Start(); Console.WriteLine(\u0026#34;Operation Performing...\u0026#34;); if(Console.ReadKey().Key == ConsoleKey.C) { Console.WriteLine(\u0026#34;Cancelling..\u0026#34;); cts.Cancel(); } Console.Read(); } } private static void LongRunningTask(CancellationToken token) { for (int i = 0; i \u0026lt; 10000000; i++) { if(token.IsCancellationRequested) { break; } else { Console.WriteLine(i); } } } 6. 异常传播 Thread 在父方法上获取不到异常，而 Task 可以\n","permalink":"https://lesanouo.github.io/blog/posts/code/165617280002/","summary":"\u003ch2 id=\"什么是-thread\"\u003e什么是 Thread\u003c/h2\u003e\n\u003cp\u003e当我们提及多线程的时候会想到 Thread 和 Threadpool，这都是异步操作，Threadpool 其实就是 Thread 的集合，具有很多优势，不过在任务多的时候全局队列会存在竞争而消耗资源。Thread 默认为前台线程，主程序必须等线程跑完才会关闭，而 Threadpool 相反。\u003c/p\u003e","title":"在.NET中Task与Thread区别"},{"content":"SignalR 简介 ASP.NET SignalR 是一个供 ASP.NET 开发人员使用的库，它简化了向应用程序添加实时 Web 功能的过程。实时 Web 功能是让服务器代码在内容可用时立即将内容推送到连接的客户端的能力，而不是让服务器等待客户端请求新数据。\n官方网址\n实现步骤 1. 引入SignalR官方库 npm install @microsoft/signalr 2. 创建一个signalR.js文件 const signalR = require(\u0026#34;@microsoft/signalr\u0026#34;) export default { SR: {}, //初始化连接 initSR: function(domain) { let that = this; domain = domain === \u0026#34;localhost\u0026#34; ? \u0026#34;内网IP\u0026#34; : domain; let url = `http://${domain}:8000/chatHub`; that.SR = new signalR.HubConnectionBuilder() .withUrl(url) .configureLogging(signalR.LogLevel.Information) .build(); async function start() { try { await that.SR.start(); console.log(\u0026#34;signaR连接成功\u0026#34;); } catch (err) { console.log(\u0026#34;err\u0026#34;, err); setTimeout(start, 5000); } } that.SR.onclose(async() =\u0026gt; { await start(); }); start(); }, syncPage: function(func) { this.SR.on(\u0026#34;ReceiveMessageFromGroup\u0026#34;, function(group, message) { func(); }); }, addToGroup: function(group) { this.SR.invoke(\u0026#34;AddToGroup\u0026#34;, group).catch(function(err) { return console.error(err.toString()); }); }, removeFromGroup: function(group) { this.SR.off(\u0026#34;ReceiveMessageFromGroup\u0026#34;) this.SR.invoke(\u0026#34;RemoveFromGroup\u0026#34;, group).catch(function(err) { return console.error(err.toString()); }); }, // 停止连接 stopSR: function() { let that = this; async function stop() { try { await that.SR.stop(); console.log(\u0026#34;signaR退出成功\u0026#34;); } catch (err) {} } stop(); }, }; 3. 在main.js中引入并全局挂载 import signalr from \u0026#34;signaR的路径\u0026#34;; Vue.prototype.signalr = signalr; 4. 初始化连接 可在登录后进行初始化this.signalr.initSR(document.Domain); 由于页面刷新后，全局挂载的signalR会消失，所以需要在App.vue中再初始化一遍 mounted() {this.signalr.initSR(document.Domain);}, 5. 页面中使用 this.signalr.SR.on(\u0026#39;方法\u0026#39;, function (data) { // 接收后要做的事 console.log(\u0026#39;方法\u0026#39;, data) }) 特别提醒！！！ 当页面切换时，需要销毁注册的方法，不然会导致重复注册方法，会产生多次调用注册的方法，需要再离开页面时清空方法。\ndestroyed() { // 我使用的方法 this.signalr.SR.off(\u0026#34;方法\u0026#34;) // 网上的方法，但是我使用无效 this.signalr.SR.methods.方法 = [] } 本文参考自： https://www.jianshu.com/p/5dc07c81f94d\n","permalink":"https://lesanouo.github.io/blog/posts/code/165591360001/","summary":"\u003ch2 id=\"signalr-简介\"\u003eSignalR 简介\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eASP.NET\u003c/code\u003e SignalR 是一个供 \u003ccode\u003eASP.NET\u003c/code\u003e 开发人员使用的库，它简化了向应用程序添加实时 Web 功能的过程。实时 Web 功能是让服务器代码在内容可用时立即将内容推送到连接的客户端的能力，而不是让服务器等待客户端请求新数据。\u003c/p\u003e","title":"Vue中全局封装SignalR"},{"content":"docker logs 是我们经常用来查看容器运行日志的命令，但是在长时间容器运行后，会产生大量的日志，会发现越来越慢，所以我们需要清理日志。\nDocker 清理日志 通过命令 docker inspect --format='{{.LogPath}}' \u0026lt;容器ID\u0026gt; 查看容器的日志路径\n通过命令 echo \u0026gt; \u0026lt;日志路径\u0026gt; 或者 cat /dev/null \u0026gt; \u0026lt;日志路径\u0026gt; 清空容器的日志\nDocker 限制日志大小 新建或修改 /etc/docker/daemon.json 文件, 内容如下：\n{ \u0026#34;log-driver\u0026#34;: \u0026#34;json-file\u0026#34;, \u0026#34;log-opts\u0026#34;: { \u0026#34;max-size\u0026#34;: \u0026#34;500m\u0026#34;, // 日志文件最大大小 \u0026#34;max-file\u0026#34;: \u0026#34;3\u0026#34; // 日志文件最大数量 } } 然后重启docker的守护线程\nsystemctl daemon-reload systemctl restart docker ","permalink":"https://lesanouo.github.io/blog/posts/code/165548160001/","summary":"\u003cp\u003e\u003ccode\u003edocker logs\u003c/code\u003e 是我们经常用来查看容器运行日志的命令，但是在长时间容器运行后，会产生大量的日志，会发现越来越慢，所以我们需要清理日志。\u003c/p\u003e\n\u003ch2 id=\"docker-清理日志\"\u003eDocker 清理日志\u003c/h2\u003e\n\u003cp\u003e通过命令 \u003ccode\u003edocker inspect --format='{{.LogPath}}' \u0026lt;容器ID\u0026gt;\u003c/code\u003e 查看容器的日志路径\u003c/p\u003e","title":"Docker清理和限制容器日志大小"},{"content":"foreach foreach元素的属性主要有item，index，collection，open，separator，close。\nitem：集合中元素迭代时的别名 index：集合中元素迭代时的索引 open：常用语where语句中，表示以什么开始，比如以\u0026rsquo;(\u0026lsquo;开始 separator：表示在每次进行迭代时的分隔符 close 常用语where语句中，表示以什么结束 在使用foreach的时候最关键的也是最容易出错的就是collection属性，该属性是必须指定的，但是在不同情况下，该属性的值是不一样的，主要有一下3种情况：\n如果传入的是单参数且参数类型是一个List的时候，collection属性值为list 如果传入的是单参数且参数类型是一个array数组的时候，collection的属性值为array 如果传入的参数是多个的时候，我们就需要把它们封装成一个Map了，当然单参数也可以封装成map，实际上如果你在传入参数的时候，在MyBatis里面也是会把它封装成一个Map的，map的key就是参数名，所以这个时候collection属性值就是传入的List或array对象在自己封装的map里面的key //mapper中我们要为这个方法传递的是一个容器,将容器中的元素一个一个的\r//拼接到xml的方法中就要使用这个forEach这个标签了\rpublic List\u0026lt;Entity\u0026gt; queryById(List\u0026lt;String\u0026gt; userids);\r//对应的xml中如下\r\u0026lt;select id=\u0026#34;queryById\u0026#34; resultMap=\u0026#34;BaseReslutMap\u0026#34; \u0026gt;\rselect * FROM entity\rwhere id in\r\u0026lt;foreach collection=\u0026#34;userids\u0026#34; item=\u0026#34;userid\u0026#34; index=\u0026#34;index\u0026#34; open=\u0026#34;(\u0026#34; separator=\u0026#34;,\u0026#34; close=\u0026#34;)\u0026#34;\u0026gt;\r#{userid}\r\u0026lt;/foreach\u0026gt;\r\u0026lt;/select\u0026gt; concat //比如说我们想要进行条件查询,但是几个条件不是每次都要使用,那么我们就可以 //通过判断是否拼接到sql中 \u0026lt;select id=\u0026#34;queryById\u0026#34; resultMap=\u0026#34;BascResultMap\u0026#34; parameterType=\u0026#34;entity\u0026#34;\u0026gt; SELECT * from entity \u0026lt;where\u0026gt; \u0026lt;if test=\u0026#34;name!=null\u0026#34;\u0026gt; name like concat(\u0026#39;%\u0026#39;,concat(#{name},\u0026#39;%\u0026#39;)) \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; choose (when,otherwise) choose标签是按顺序判断其内部when标签中的test条件出否成立，如果有一个成立，则 choose 结束。当 choose 中所有 when 的条件都不满则时，则执行 otherwise 中的sql。类似于Java 的 switch 语句，choose 为 switch，when 为 case，otherwise 则为 default。\n例如下面例子，同样把所有可以限制的条件都写上，方面使用。choose会从上到下选择一个when标签的test为true的sql执行。安全考虑，我们使用where将choose包起来，放置关键字多于错误。\n\u0026lt;!-- choose(判断参数) - 按顺序将实体类 User 第一个不为空的属性作为：where条件 --\u0026gt; \u0026lt;select id=\u0026#34;getUserList_choose\u0026#34; resultMap=\u0026#34;resultMap_user\u0026#34; parameterType=\u0026#34;com.yiibai.pojo.User\u0026#34;\u0026gt; SELECT * FROM User u \u0026lt;where\u0026gt; \u0026lt;choose\u0026gt; \u0026lt;when test=\u0026#34;username !=null \u0026#34;\u0026gt; u.username LIKE CONCAT(CONCAT(\u0026#39;%\u0026#39;, #{username, jdbcType=VARCHAR}),\u0026#39;%\u0026#39;) \u0026lt;/when \u0026gt; \u0026lt;when test=\u0026#34;sex != null and sex != \u0026#39;\u0026#39; \u0026#34;\u0026gt; AND u.sex = #{sex, jdbcType=INTEGER} \u0026lt;/when \u0026gt; \u0026lt;when test=\u0026#34;birthday != null \u0026#34;\u0026gt; AND u.birthday = #{birthday, jdbcType=DATE} \u0026lt;/when \u0026gt; \u0026lt;otherwise\u0026gt; \u0026lt;/otherwise\u0026gt; \u0026lt;/choose\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; selectKey 在insert语句中，在Oracle经常使用序列、在MySQL中使用函数来自动生成插入表的主键，而且需要方法能返回这个生成主键。使用myBatis的selectKey标签可以实现这个效果。\n下面例子，使用mysql数据库自定义函数nextval(\u0026lsquo;student\u0026rsquo;)，用来生成一个key，并把他设置到传入的实体类中的studentId属性上。所以在执行完此方法后，边可以通过这个实体类获取生成的key。\n\u0026lt;!-- 插入学生 自动主键--\u0026gt; \u0026lt;insert id=\u0026#34;createStudentAutoKey\u0026#34; parameterType=\u0026#34;liming.student.manager.data.model.StudentEntity\u0026#34; keyProperty=\u0026#34;studentId\u0026#34;\u0026gt; \u0026lt;selectKey keyProperty=\u0026#34;studentId\u0026#34; resultType=\u0026#34;String\u0026#34; order=\u0026#34;BEFORE\u0026#34;\u0026gt; select nextval(\u0026#39;student\u0026#39;) \u0026lt;/selectKey\u0026gt; INSERT INTO STUDENT_TBL(STUDENT_ID, STUDENT_NAME, STUDENT_SEX, STUDENT_BIRTHDAY, STUDENT_PHOTO, CLASS_ID, PLACE_ID) VALUES (#{studentId}, #{studentName}, #{studentSex}, #{studentBirthday}, #{studentPhoto, javaType=byte[], jdbcType=BLOB, typeHandler=org.apache.ibatis.type.BlobTypeHandler}, #{classId}, #{placeId}) \u0026lt;/insert\u0026gt; 调用接口方法，和获取自动生成key\nStudentEntity entity = new StudentEntity(); entity.setStudentName(\u0026#34;黎明你好\u0026#34;); entity.setStudentSex(1); entity.setStudentBirthday(DateUtil.parse(\u0026#34;1985-05-28\u0026#34;)); entity.setClassId(\u0026#34;20000001\u0026#34;); entity.setPlaceId(\u0026#34;70000001\u0026#34;); this.dynamicSqlMapper.createStudentAutoKey(entity); System.out.println(\u0026#34;新增学生ID: \u0026#34; + entity.getStudentId()); if if标签可用在许多类型的sql语句中，我们以查询为例。首先看一个很普通的查询：\n\u0026lt;!-- 查询学生list，like姓名 --\u0026gt; \u0026lt;select id=\u0026#34;getStudentListLikeName\u0026#34; parameterType=\u0026#34;StudentEntity\u0026#34; resultMap=\u0026#34;studentResultMap\u0026#34;\u0026gt; SELECT * from STUDENT_TBL ST WHERE ST.STUDENT_NAME LIKE CONCAT(CONCAT(\u0026#39;%\u0026#39;, #{studentName}),\u0026#39;%\u0026#39;) \u0026lt;/select\u0026gt; 但是此时如果studentName为null，此语句很可能报错或查询结果为空。此时我们使用if动态sql语句先进行判断，如果值为null或等于空字符串，我们就不进行此条件的判断，增加灵活性。\n参数为实体类StudentEntity。将实体类中所有的属性均进行判断，如果不为空则执行判断条件。\n\u0026lt;!-- 2 if(判断参数) - 将实体类不为空的属性作为where条件 --\u0026gt; \u0026lt;select id=\u0026#34;getStudentList_if\u0026#34; resultMap=\u0026#34;resultMap_studentEntity\u0026#34; parameterType=\u0026#34;liming.student.manager.data.model.StudentEntity\u0026#34;\u0026gt; SELECT ST.STUDENT_ID, ST.STUDENT_NAME, ST.STUDENT_SEX, ST.STUDENT_BIRTHDAY, ST.STUDENT_PHOTO, ST.CLASS_ID, ST.PLACE_ID FROM STUDENT_TBL ST WHERE \u0026lt;if test=\u0026#34;studentName !=null \u0026#34;\u0026gt; ST.STUDENT_NAME LIKE CONCAT(CONCAT(\u0026#39;%\u0026#39;, #{studentName, jdbcType=VARCHAR}),\u0026#39;%\u0026#39;) \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;studentSex != null and studentSex != \u0026#39;\u0026#39; \u0026#34;\u0026gt; AND ST.STUDENT_SEX = #{studentSex, jdbcType=INTEGER} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;studentBirthday != null \u0026#34;\u0026gt; AND ST.STUDENT_BIRTHDAY = #{studentBirthday, jdbcType=DATE} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;classId != null and classId!= \u0026#39;\u0026#39; \u0026#34;\u0026gt; AND ST.CLASS_ID = #{classId, jdbcType=VARCHAR} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;classEntity != null and classEntity.classId !=null and classEntity.classId !=\u0026#39; \u0026#39; \u0026#34;\u0026gt; AND ST.CLASS_ID = #{classEntity.classId, jdbcType=VARCHAR} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;placeId != null and placeId != \u0026#39;\u0026#39; \u0026#34;\u0026gt; AND ST.PLACE_ID = #{placeId, jdbcType=VARCHAR} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;placeEntity != null and placeEntity.placeId != null and placeEntity.placeId != \u0026#39;\u0026#39; \u0026#34;\u0026gt; AND ST.PLACE_ID = #{placeEntity.placeId, jdbcType=VARCHAR} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;studentId != null and studentId != \u0026#39;\u0026#39; \u0026#34;\u0026gt; AND ST.STUDENT_ID = #{studentId, jdbcType=VARCHAR} \u0026lt;/if\u0026gt; \u0026lt;/select\u0026gt; 使用时比较灵活， new一个这样的实体类，我们需要限制那个条件，只需要附上相应的值就会where这个条件，相反不去赋值就可以不在where中判断。\npublic void select_test_2_1() { StudentEntity entity = new StudentEntity(); entity.setStudentName(\u0026#34;\u0026#34;); entity.setStudentSex(1); entity.setStudentBirthday(DateUtil.parse(\u0026#34;1985-05-28\u0026#34;)); entity.setClassId(\u0026#34;20000001\u0026#34;); //entity.setPlaceId(\u0026#34;70000001\u0026#34;); List\u0026lt;StudentEntity\u0026gt; list = this.dynamicSqlMapper.getStudentList_if(entity); for (StudentEntity e : list) { System.out.println(e.toString()); } } if + where 当where中的条件使用的if标签较多时，这样的组合可能会导致错误。我们以在3.1中的查询语句为例子，当java代码按如下方法调用时：\n@Test public void select_test_2_1() { StudentEntity entity = new StudentEntity(); entity.setStudentName(null); entity.setStudentSex(1); List\u0026lt;StudentEntity\u0026gt; list = this.dynamicSqlMapper.getStudentList_if(entity); for (StudentEntity e : list) { System.out.println(e.toString()); } } 如果上面例子，参数studentName为null，将不会进行STUDENT_NAME列的判断，则会直接导“WHERE AND”关键字多余的错误SQL。\n这时我们可以使用where动态语句来解决。这个“where”标签会知道如果它包含的标签中有返回值的话，它就插入一个‘where’。此外，如果标签返回的内容是以AND 或OR 开头的，则它会剔除掉。\n上面例子修改为：\n\u0026lt;!-- 3 select - where/if(判断参数) - 将实体类不为空的属性作为where条件 --\u0026gt; \u0026lt;select id=\u0026#34;getStudentList_whereIf\u0026#34; resultMap=\u0026#34;resultMap_studentEntity\u0026#34; parameterType=\u0026#34;liming.student.manager.data.model.StudentEntity\u0026#34;\u0026gt; SELECT ST.STUDENT_ID, ST.STUDENT_NAME, ST.STUDENT_SEX, ST.STUDENT_BIRTHDAY, ST.STUDENT_PHOTO, ST.CLASS_ID, ST.PLACE_ID FROM STUDENT_TBL ST \u0026lt;where\u0026gt; \u0026lt;if test=\u0026#34;studentName !=null \u0026#34;\u0026gt; ST.STUDENT_NAME LIKE CONCAT(CONCAT(\u0026#39;%\u0026#39;, #{studentName, jdbcType=VARCHAR}),\u0026#39;%\u0026#39;) \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;studentSex != null and studentSex != \u0026#39;\u0026#39; \u0026#34;\u0026gt; AND ST.STUDENT_SEX = #{studentSex, jdbcType=INTEGER} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;studentBirthday != null \u0026#34;\u0026gt; AND ST.STUDENT_BIRTHDAY = #{studentBirthday, jdbcType=DATE} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;classId != null and classId!= \u0026#39;\u0026#39; \u0026#34;\u0026gt; AND ST.CLASS_ID = #{classId, jdbcType=VARCHAR} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;classEntity != null and classEntity.classId !=null and classEntity.classId !=\u0026#39; \u0026#39; \u0026#34;\u0026gt; AND ST.CLASS_ID = #{classEntity.classId, jdbcType=VARCHAR} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;placeId != null and placeId != \u0026#39;\u0026#39; \u0026#34;\u0026gt; AND ST.PLACE_ID = #{placeId, jdbcType=VARCHAR} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;placeEntity != null and placeEntity.placeId != null and placeEntity.placeId != \u0026#39;\u0026#39; \u0026#34;\u0026gt; AND ST.PLACE_ID = #{placeEntity.placeId, jdbcType=VARCHAR} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;studentId != null and studentId != \u0026#39;\u0026#39; \u0026#34;\u0026gt; AND ST.STUDENT_ID = #{studentId, jdbcType=VARCHAR} \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; if + set 当update语句中没有使用if标签时，如果有一个参数为null，都会导致错误。\n当在update语句中使用if标签时，如果前面的if没有执行，则或导致逗号多余错误。使用set标签可以将动态的配置SET 关键字，和剔除追加到条件末尾的任何不相关的逗号。使用if+set标签修改后，如果某项为null则不进行更新，而是保持数据库原值。\n如下示例：\n\u0026lt;!-- 4 if/set(判断参数) - 将实体类不为空的属性更新 --\u0026gt; \u0026lt;update id=\u0026#34;updateStudent_if_set\u0026#34; parameterType=\u0026#34;liming.student.manager.data.model.StudentEntity\u0026#34;\u0026gt; UPDATE STUDENT_TBL \u0026lt;set\u0026gt; \u0026lt;if test=\u0026#34;studentName != null and studentName != \u0026#39;\u0026#39; \u0026#34;\u0026gt; STUDENT_TBL.STUDENT_NAME = #{studentName}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;studentSex != null and studentSex != \u0026#39;\u0026#39; \u0026#34;\u0026gt; STUDENT_TBL.STUDENT_SEX = #{studentSex}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;studentBirthday != null \u0026#34;\u0026gt; STUDENT_TBL.STUDENT_BIRTHDAY = #{studentBirthday}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;studentPhoto != null \u0026#34;\u0026gt; STUDENT_TBL.STUDENT_PHOTO = #{studentPhoto, javaType=byte[], jdbcType=BLOB, typeHandler=org.apache.ibatis.type.BlobTypeHandler}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;classId != \u0026#39;\u0026#39; \u0026#34;\u0026gt; STUDENT_TBL.CLASS_ID = #{classId} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;placeId != \u0026#39;\u0026#39; \u0026#34;\u0026gt; STUDENT_TBL.PLACE_ID = #{placeId} \u0026lt;/if\u0026gt; \u0026lt;/set\u0026gt; WHERE STUDENT_TBL.STUDENT_ID = #{studentId}; \u0026lt;/update\u0026gt; if + trim trim是更灵活的去处多余关键字的标签，他可以实践where和set的效果。\ntrim代替where\n\u0026lt;!-- 5.1if/trim代替where(判断参数) -将实体类不为空的属性作为where条件--\u0026gt; \u0026lt;select id=\u0026#34;getStudentList_if_trim\u0026#34; resultMap=\u0026#34;resultMap_studentEntity\u0026#34;\u0026gt; SELECT ST.STUDENT_ID, ST.STUDENT_NAME, ST.STUDENT_SEX, ST.STUDENT_BIRTHDAY, ST.STUDENT_PHOTO, ST.CLASS_ID, ST.PLACE_ID FROM STUDENT_TBL ST \u0026lt;trim prefix=\u0026#34;WHERE\u0026#34; prefixOverrides=\u0026#34;AND|OR\u0026#34;\u0026gt; \u0026lt;if test=\u0026#34;studentName !=null \u0026#34;\u0026gt; ST.STUDENT_NAME LIKE CONCAT(CONCAT(\u0026#39;%\u0026#39;, #{studentName, jdbcType=VARCHAR}),\u0026#39;%\u0026#39;) \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;studentSex != null and studentSex != \u0026#39;\u0026#39; \u0026#34;\u0026gt; AND ST.STUDENT_SEX = #{studentSex, jdbcType=INTEGER} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;studentBirthday != null \u0026#34;\u0026gt; AND ST.STUDENT_BIRTHDAY = #{studentBirthday, jdbcType=DATE} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;classId != null and classId!= \u0026#39;\u0026#39; \u0026#34;\u0026gt; AND ST.CLASS_ID = #{classId, jdbcType=VARCHAR} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;classEntity != null and classEntity.classId !=null and classEntity.classId !=\u0026#39; \u0026#39; \u0026#34;\u0026gt; AND ST.CLASS_ID = #{classEntity.classId, jdbcType=VARCHAR} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;placeId != null and placeId != \u0026#39;\u0026#39; \u0026#34;\u0026gt; AND ST.PLACE_ID = #{placeId, jdbcType=VARCHAR} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;placeEntity != null and placeEntity.placeId != null and placeEntity.placeId != \u0026#39;\u0026#39; \u0026#34;\u0026gt; AND ST.PLACE_ID = #{placeEntity.placeId, jdbcType=VARCHAR} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;studentId != null and studentId != \u0026#39;\u0026#39; \u0026#34;\u0026gt; AND ST.STUDENT_ID = #{studentId, jdbcType=VARCHAR} \u0026lt;/if\u0026gt; \u0026lt;/trim\u0026gt; \u0026lt;/select\u0026gt; trim代替set\n\u0026lt;!-- 5.2 if/trim代替set(判断参数) - 将实体类不为空的属性更新 --\u0026gt; \u0026lt;update id=\u0026#34;updateStudent_if_trim\u0026#34; parameterType=\u0026#34;liming.student.manager.data.model.StudentEntity\u0026#34;\u0026gt; UPDATE STUDENT_TBL \u0026lt;trim prefix=\u0026#34;SET\u0026#34; suffixOverrides=\u0026#34;,\u0026#34;\u0026gt; \u0026lt;if test=\u0026#34;studentName != null and studentName != \u0026#39;\u0026#39; \u0026#34;\u0026gt; STUDENT_TBL.STUDENT_NAME = #{studentName}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;studentSex != null and studentSex != \u0026#39;\u0026#39; \u0026#34;\u0026gt; STUDENT_TBL.STUDENT_SEX = #{studentSex}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;studentBirthday != null \u0026#34;\u0026gt; STUDENT_TBL.STUDENT_BIRTHDAY = #{studentBirthday}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;studentPhoto != null \u0026#34;\u0026gt; STUDENT_TBL.STUDENT_PHOTO = #{studentPhoto, javaType=byte[], jdbcType=BLOB, typeHandler=org.apache.ibatis.type.BlobTypeHandler}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;classId != \u0026#39;\u0026#39; \u0026#34;\u0026gt; STUDENT_TBL.CLASS_ID = #{classId}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;placeId != \u0026#39;\u0026#39; \u0026#34;\u0026gt; STUDENT_TBL.PLACE_ID = #{placeId} \u0026lt;/if\u0026gt; \u0026lt;/trim\u0026gt; WHERE STUDENT_TBL.STUDENT_ID = #{studentId} \u0026lt;/update\u0026gt; sql sql片段标签\u0026lt;sql\u0026gt;：通过该标签可定义能复用的sql语句片段，在执行sql语句标签中直接引用即可。这样既可以提高编码效率，还能有效简化代码，提高可读性\n需要配置的属性：id=\u0026quot;\u0026quot; \u0026raquo;\u0026gt;表示需要改sql语句片段的唯一标识\n引用：通过\u0026lt;include refid=\u0026quot;\u0026quot; /\u0026gt;标签引用，refid=\u0026quot;\u0026quot; 中的值指向需要引用的\u0026lt;sql\u0026gt;中的id=“”属性\n\u0026lt;!--定义sql片段--\u0026gt; \u0026lt;sql id=\u0026#34;orderAndItem\u0026#34;\u0026gt; o.order_id,o.cid,o.address,o.create_date,o.orderitem_id,i.orderitem_id,i.product_id,i.count \u0026lt;/sql\u0026gt; \u0026lt;select id=\u0026#34;findOrderAndItemsByOid\u0026#34; parameterType=\u0026#34;java.lang.String\u0026#34; resultMap=\u0026#34;BaseResultMap\u0026#34;\u0026gt; select \u0026lt;!--引用sql片段--\u0026gt; \u0026lt;include refid=\u0026#34;orderAndItem\u0026#34; /\u0026gt; from ordertable o join orderitem i on o.orderitem_id = i.orderitem_id where o.order_id = #{orderId} \u0026lt;/select\u0026gt; ","permalink":"https://lesanouo.github.io/blog/posts/snippet/mybatis/","summary":"\u003ch2 id=\"foreach\"\u003eforeach\u003c/h2\u003e\n\u003cp\u003eforeach元素的属性主要有item，index，collection，open，separator，close。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eitem：集合中元素迭代时的别名\u003c/li\u003e\n\u003cli\u003eindex：集合中元素迭代时的索引\u003c/li\u003e\n\u003cli\u003eopen：常用语where语句中，表示以什么开始，比如以\u0026rsquo;(\u0026lsquo;开始\u003c/li\u003e\n\u003cli\u003eseparator：表示在每次进行迭代时的分隔符\u003c/li\u003e\n\u003cli\u003eclose 常用语where语句中，表示以什么结束\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e在使用foreach的时候最关键的也是最容易出错的就是collection属性，该属性是必须指定的，但是在不同情况下，该属性的值是不一样的，主要有一下3种情况：\u003c/p\u003e","title":"Mybatis 代码片段"},{"content":"行转列 使用PIVOT实现 SELECT * FROM student PIVOT ( SUM(score) FOR subject IN (语文, 数学, 英语) ) 分组后使用case进行条件判断处理 当然我们也可以用 CASE WHEN 得到同样的结果，就是写起来麻烦一点。\nSELECT name, MAX( CASE WHEN subject=\u0026#39;语文\u0026#39; THEN score ELSE 0 END) AS \u0026#34;语文\u0026#34;, MAX( CASE WHEN subject=\u0026#39;数学\u0026#39; THEN score ELSE 0 END) AS \u0026#34;数学\u0026#34;, MAX( CASE WHEN subject=\u0026#39;英语\u0026#39; THEN score ELSE 0 END) AS \u0026#34;英语\u0026#34; FROM student GROUP BY name 使用 CASE WHEN 可以得到和 PIVOT 同样的结果，没有 PIVOT 简单直观。\n列转行 使用UNPIVOT实现 SELECT * FROM student1 UNPIVOT ( score FOR subject IN (\u0026#34;语文\u0026#34;,\u0026#34;数学\u0026#34;,\u0026#34;英语\u0026#34;) ) 分组后使用case进行条件判断处理 我们也可以使用下面方法得到同样结果\nSELECT NAME, \u0026#39;语文\u0026#39; AS subject , MAX(\u0026#34;语文\u0026#34;) AS score FROM student1 GROUP BY NAME UNION SELECT NAME, \u0026#39;数学\u0026#39; AS subject , MAX(\u0026#34;数学\u0026#34;) AS score FROM student1 GROUP BY NAME UNION SELECT NAME, \u0026#39;英语\u0026#39; AS subject , MAX(\u0026#34;英语\u0026#34;) AS score FROM student1 GROUP BY NAME UNION \u0026amp; UNION ALL UNION 操作符用于合并两个或多个 SELECT 语句的结果集。\n请注意，UNION 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同。\nSQL UNION 语法\nSELECT column_name(s) FROM table_name1 UNION SELECT column_name(s) FROM table_name2 **注释：**默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。\nSQL UNION ALL 语法\nSELECT column_name(s) FROM table_name1 UNION ALL SELECT column_name(s) FROM table_name2 另外，UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名。\n","permalink":"https://lesanouo.github.io/blog/posts/snippet/sql/","summary":"\u003ch2 id=\"行转列\"\u003e行转列\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e使用PIVOT实现\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sql\" data-lang=\"sql\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eSELECT\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eFROM\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003estudent\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003ePIVOT\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"k\"\u003eSUM\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003escore\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eFOR\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003esubject\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eIN\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"err\"\u003e语文\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"err\"\u003e数学\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"err\"\u003e英语\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e分组后使用case进行条件判断处理\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e当然我们也可以用 CASE WHEN 得到同样的结果，就是写起来麻烦一点。\u003c/p\u003e","title":"SQL 代码片段"},{"content":"简介 使用正则表达式来处理搜索文本，能够提高灵活性。 通过使用正则表达式，可以做到：\n测试字符串内的模式，例如，可以匹配字符串是否满足电话号码或信用卡号码的模式，进行数据验证 替换文本，使用正则表达式来识别文档中的特定文本，完全删除该文本或用其他文本替换它 基于模式匹配从字符串中提取子字符串，可以查找文档内或输入域内特定的文本 基本语法 修饰符 修饰符 含义 描述 i ignore - 不区分大小写 将匹配设置为不区分大小写，搜索时不区分大小写:A和a没有区别 g global - 全局匹配 查找所有的匹配项 m multi line - 多行匹配 使边界字符 ^ 和 $ 匹配每一行的开头和结尾，记住是多行，而不是整个字符串的开头和结尾 s 特殊字符圆点 . 中包含换行符 \\n 默认情况下的圆点 . 是匹配除换行符 \\n 之外的任何字符，加上 s 修饰符之后, . 中包含换行符 \\n 元字符 普通字符 字符 描述 [ABC] 匹配 [\u0026hellip;] 中的所有字符 [^ABC] 匹配除了 [\u0026hellip;] 中字符的所有字符 [A-Z] [A-Z] 表示一个区间，匹配所有大写字母，[a-z] 表示所有小写字母 . 匹配除换行符（\\n、\\r）之外的任何单个字符，相等于 [^\\n\\r] [\\s\\S] 匹配所有。\\s 是匹配所有空白符，包括换行，\\S 非空白符，不包括换行 \\w 匹配字母、数字、下划线。等价于 [A-Za-z0-9_] \\W 匹配非字母、数字、下划线。等价于 \u0026lsquo;[^A-Za-z0-9_]\u0026rsquo; \\d 匹配一个数字字符。等价于 [0-9] \\D 匹配一个非数字字符。等价于 [^0-9] \\xn 匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，\u0026rsquo;\\x41\u0026rsquo; 匹配 \u0026ldquo;A\u0026rdquo; \\num 匹配 num，其中 num 是一个正整数 非打印字符 字符 描述 \\cx 匹配由x指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符 \\f 匹配一个换页符 \\n 匹配一个换行符 \\r 匹配一个回车符 \\s 匹配任何空白字符，包括空格、制表符、换页符等等 \\S 匹配任何非空白字符 \\t 匹配一个制表符 \\v 匹配一个垂直制表符 特殊字符 字符 描述 $ 匹配输入字符串的结尾位置 () 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用 * 匹配前面的子表达式零次或多次 + 匹配前面的子表达式一次或多次 . 匹配除换行符 \\n 之外的任何单字符 [ 标记一个中括号表达式的开始 ? 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符(尽可能少的匹配所搜索的字符串) \\ 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符 ^ 匹配输入字符串的开始位置；不接受该方括号表达式中的字符集合 { 标记限定符表达式的开始 | 指明两项之间的一个选择 限定符 字符 描述 * 匹配前面的子表达式零次或多次 + 匹配前面的子表达式一次或多次 ? 匹配前面的子表达式零次或一次 {n} n 是一个非负整数。匹配确定的 n 次 {n,} n 是一个非负整数。至少匹配n 次 {n,m} m 和 n 均为非负整数，其中n \u0026lt;= m。最少匹配 n 次且最多匹配 m 次 定位符 字符 描述 ^ 匹配输入字符串开始的位置 $ 匹配输入字符串结尾的位置 \\b 匹配一个单词边界，即字与空格间的位置 \\B 非单词边界匹配 ?: ?= ?! ?\u0026lt;= ?\u0026gt;! 字符 描述 (?:pattern) 匹配 pattern 但不获取匹配结果 (?=pattern) 正向肯定预查 (?!pattern) 正向否定预查 (?\u0026lt;=pattern) 反向肯定预查 (?\u0026lt;!pattern) 反向否定预查 其他 字符 描述 \\d 匹配 pattern 但不获取匹配结果 \\D 正向肯定预查 (?!pattern) 正向否定预查 (?\u0026lt;=pattern) 反向肯定预查 (?\u0026lt;!pattern) 反向否定预查 运算符优先级 相同优先级的从左到右进行运算，不同优先级的运算先高后低。下表从最高到最低说明了各种正则表达式运算符的优先级顺序：\n运算符 描述 \\ 转义符 (), (?: ), (?=), [] 圆括号和方括号 *, +, ?, {n}, {n,}, {n,m} 限定符 ^, $, \\任何元字符、任何字符 定位点和序列 | 替换，\u0026ldquo;或\u0026quot;操作 示例 通过 /\\b[\\w.%+-]+@[\\w.-]+\\.[a-zA-Z]{2,6}\\b/g 匹配邮箱地址\n","permalink":"https://lesanouo.github.io/blog/posts/code/165530880001/","summary":"\u003ch2 id=\"简介\"\u003e简介\u003c/h2\u003e\n\u003cp\u003e使用正则表达式来处理搜索文本，能够提高灵活性。\n通过使用正则表达式，可以做到：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e测试字符串内的模式，例如，可以匹配字符串是否满足电话号码或信用卡号码的模式，进行数据验证\u003c/li\u003e\n\u003cli\u003e替换文本，使用正则表达式来识别文档中的特定文本，完全删除该文本或用其他文本替换它\u003c/li\u003e\n\u003cli\u003e基于模式匹配从字符串中提取子字符串，可以查找文档内或输入域内特定的文本\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"基本语法\"\u003e基本语法\u003c/h2\u003e\n\u003ch3 id=\"修饰符\"\u003e修饰符\u003c/h3\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth style=\"text-align: center\"\u003e修饰符\u003c/th\u003e\n          \u003cth style=\"text-align: center\"\u003e含义\u003c/th\u003e\n          \u003cth style=\"text-align: left\"\u003e描述\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003ei\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003eignore - 不区分大小写\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e将匹配设置为不区分大小写，搜索时不区分大小写:A和a没有区别\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003eg\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003eglobal - 全局匹配\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e查找所有的匹配项\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003em\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003emulti line - 多行匹配\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e使边界字符 ^ 和 $ 匹配每一行的开头和结尾，记住是多行，而不是整个字符串的开头和结尾\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003es\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e特殊字符圆点 . 中包含换行符 \\n\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e默认情况下的圆点 . 是匹配除换行符 \\n 之外的任何字符，加上 s 修饰符之后, . 中包含换行符 \\n\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch3 id=\"元字符\"\u003e元字符\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e普通字符\u003c/li\u003e\n\u003c/ol\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth style=\"text-align: center\"\u003e字符\u003c/th\u003e\n          \u003cth style=\"text-align: left\"\u003e描述\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e[ABC]\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e匹配 [\u0026hellip;] 中的所有字符\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e[^ABC]\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e匹配除了 [\u0026hellip;] 中字符的所有字符\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e[A-Z]\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e[A-Z] 表示一个区间，匹配所有大写字母，[a-z] 表示所有小写字母\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e.\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e匹配除换行符（\\n、\\r）之外的任何单个字符，相等于 [^\\n\\r]\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e[\\s\\S]\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e匹配所有。\\s 是匹配所有空白符，包括换行，\\S 非空白符，不包括换行\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\\w\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e匹配字母、数字、下划线。等价于 [A-Za-z0-9_]\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\\W\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e匹配非字母、数字、下划线。等价于 \u0026lsquo;[^A-Za-z0-9_]\u0026rsquo;\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\\d\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e匹配一个数字字符。等价于 [0-9]\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\\D\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e匹配一个非数字字符。等价于 [^0-9]\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\\xn\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，\u0026rsquo;\\x41\u0026rsquo; 匹配 \u0026ldquo;A\u0026rdquo;\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\\num\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e匹配 num，其中 num 是一个正整数\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003col\u003e\n\u003cli\u003e非打印字符\u003c/li\u003e\n\u003c/ol\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth style=\"text-align: center\"\u003e字符\u003c/th\u003e\n          \u003cth style=\"text-align: left\"\u003e描述\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\\cx\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e匹配由x指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\\f\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e匹配一个换页符\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\\n\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e匹配一个换行符\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\\r\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e匹配一个回车符\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\\s\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e匹配任何空白字符，包括空格、制表符、换页符等等\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\\S\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e匹配任何非空白字符\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\\t\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e匹配一个制表符\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\\v\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e匹配一个垂直制表符\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e特殊字符\u003c/li\u003e\n\u003c/ol\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth style=\"text-align: center\"\u003e字符\u003c/th\u003e\n          \u003cth style=\"text-align: left\"\u003e描述\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e$\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e匹配输入字符串的结尾位置\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e()\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e*\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e匹配前面的子表达式零次或多次\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e+\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e匹配前面的子表达式一次或多次\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e.\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e匹配除换行符 \\n 之外的任何单字符\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e[\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e标记一个中括号表达式的开始\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e?\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e匹配前面的子表达式零次或一次，或指明一个非贪婪限定符(尽可能少的匹配所搜索的字符串)\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\\\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e^\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e匹配输入字符串的开始位置；不接受该方括号表达式中的字符集合\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e{\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e标记限定符表达式的开始\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e|\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e指明两项之间的一个选择\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003e限定符\u003c/li\u003e\n\u003c/ol\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth style=\"text-align: center\"\u003e字符\u003c/th\u003e\n          \u003cth style=\"text-align: left\"\u003e描述\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e*\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e匹配前面的子表达式零次或多次\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e+\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e匹配前面的子表达式一次或多次\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e?\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e匹配前面的子表达式零次或一次\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e{n}\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003en 是一个非负整数。匹配确定的 n 次\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e{n,}\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003en 是一个非负整数。至少匹配n 次\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e{n,m}\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003em 和 n 均为非负整数，其中n \u0026lt;= m。最少匹配 n 次且最多匹配 m 次\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003col start=\"5\"\u003e\n\u003cli\u003e定位符\u003c/li\u003e\n\u003c/ol\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth style=\"text-align: center\"\u003e字符\u003c/th\u003e\n          \u003cth style=\"text-align: left\"\u003e描述\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e^\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e匹配输入字符串开始的位置\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e$\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e匹配输入字符串结尾的位置\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\\b\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e匹配一个单词边界，即字与空格间的位置\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\\B\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e非单词边界匹配\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003col start=\"6\"\u003e\n\u003cli\u003e?: ?= ?! ?\u0026lt;= ?\u0026gt;!\u003c/li\u003e\n\u003c/ol\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth style=\"text-align: center\"\u003e字符\u003c/th\u003e\n          \u003cth style=\"text-align: left\"\u003e描述\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e(?:pattern)\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e匹配 pattern 但不获取匹配结果\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e(?=pattern)\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e正向肯定预查\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e(?!pattern)\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e正向否定预查\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e(?\u0026lt;=pattern)\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e反向肯定预查\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e(?\u0026lt;!pattern)\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e反向否定预查\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003col start=\"7\"\u003e\n\u003cli\u003e其他\u003c/li\u003e\n\u003c/ol\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth style=\"text-align: center\"\u003e字符\u003c/th\u003e\n          \u003cth style=\"text-align: left\"\u003e描述\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\\d\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e匹配 pattern 但不获取匹配结果\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\\D\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e正向肯定预查\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e(?!pattern)\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e正向否定预查\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e(?\u0026lt;=pattern)\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e反向肯定预查\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e(?\u0026lt;!pattern)\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e反向否定预查\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch3 id=\"运算符优先级\"\u003e运算符优先级\u003c/h3\u003e\n\u003cp\u003e相同优先级的从左到右进行运算，不同优先级的运算先高后低。下表从最高到最低说明了各种正则表达式运算符的优先级顺序：\u003c/p\u003e","title":"正则表达式总结"},{"content":"在使用docker时，常常需要对已启动的容器进行相应的配置修改，其中最常见的就是挂载目录或端口映射。其实配置也并不是非常复杂，可以通过修改docker中的json配置文件即可。\n以下为详细修改步骤\n1. 先查看需要修改的容器的id号 首先通过 docker ps -a 查看 CONTAINER ID\n再通过 docker inspect \u0026lt;container_id\u0026gt; 查看 Id （一般在最开始的位置）\n2. 关闭docker服务 在做相应配置前，一定要先停止docker服务，否则会修改不成功。\nsystemctl stop docker 3. 前往docker配置文件目录 通过以下命令即可进入到配置文件目录：\ncd /var/lib/docker/containers/\u0026lt;container_id\u0026gt; 4. 修改hostconfig.json文件 通过 vim hostconfig.json 即可修改配置文件。\nvim中可以通过 /字符串 快速定位字符串位置\n修改以下内容配置端口映射 { ... \u0026#34;PortBindings\u0026#34;: { \u0026#34;80/tcp\u0026#34;: [ { \u0026#34;HostIp\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;HostPort\u0026#34;: \u0026#34;8080\u0026#34; } ] } ... } 修改以下内容配置挂载目录 { ... \u0026#34;Binds\u0026#34;: [ \u0026#34;/home/docker/www:/var/www\u0026#34; ] ... // 其中 `/home/docker/www` 为宿主机目录，`/var/www` 为容器目录 } 4. 修改config.v2.json文件 通过 vim config.v2.json 即可修改配置文件。\n修改以下内容配置端口映射 { ... \u0026#34;ExposedPorts\u0026#34;: { \u0026#34;80/tcp\u0026#34;: {}, } ... } 修改以下内容配置挂载目录 { ... \u0026#34;MountPoints\u0026#34;: { \u0026#34;/var/www\u0026#34;: { \u0026#34;Source\u0026#34;: \u0026#34;/home/docker/www\u0026#34;, \u0026#34;Destination\u0026#34;: \u0026#34;/var/www\u0026#34;, \u0026#34;RW\u0026#34;: true, \u0026#34;Name\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;Driver\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;Type\u0026#34;: \u0026#34;bind\u0026#34;, \u0026#34;Propagation\u0026#34;: \u0026#34;rprivate\u0026#34;, \u0026#34;Spec\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;bind\u0026#34;, \u0026#34;Source\u0026#34;: \u0026#34;/home/docker/www\u0026#34;, \u0026#34;Target\u0026#34;: \u0026#34;/var/www\u0026#34;, } \u0026#34;SkipMountpointCreation\u0026#34;: false, } } ... // 其中 `/home/docker/www` 为宿主机目录，`/var/www` 为容器目录 } 5. 重启docker服务 `systemctl start docker` ","permalink":"https://lesanouo.github.io/blog/posts/code/165513600001/","summary":"\u003cp\u003e在使用docker时，常常需要对已启动的容器进行相应的配置修改，其中最常见的就是挂载目录或端口映射。其实配置也并不是非常复杂，可以通过修改docker中的json配置文件即可。\u003c/p\u003e","title":"Docker为已启动容器添加挂载目录或端口映射"},{"content":"索引 MySQL 索引 MySQL 的索引有两种分类方式：逻辑分类和物理分类\n逻辑分类 主键索引：一张表只能有一个主键索引，不允许重复、不允许为 NULL 唯一索引：数据列不允许重复，允许为 NULL 值，一张表可有多个唯一索引，索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一 普通索引：一张表可以创建多个普通索引，一个普通索引可以包含多个字段，允许数据重复，允许 NULL 值插入 全文索引：它查找的是文本中的关键词，主要用于全文检索 单例索引：一个索引只包含一个列，一个表可以有多个单例索引 组合索引：一个组合索引包含两个或两个以上的列。查询的时候遵循 mysql 组合索引的 “最左前缀”原则，即使用 where 时条件要按照建立索引的时候字段的排列方式放置索引才会生效 物理分类 聚簇索引：不是单独的一种索引类型，而是一种数据存储方式。这种存储方式是依靠B+树来实现的，根据表的主键构造一棵B+树且B+树叶子节点存放的都是表的行记录数据时，方可称该主键索引为聚簇索引。聚簇索引也可理解为将数据存储与索引放到了一块，找到索引也就找到了数据。 非聚簇索引：数据和索引是分开的，B+树叶子节点存放的不是数据表的行记录 EXPLAIN 使用格式：EXPLAIN SQL...;\n返回结果包含：\nid:选择标识符 select_type:表示查询的类型。 table:输出结果集的表 partitions:匹配的分区 type:表示表的连接类型 possible_keys:表示查询时，可能使用的索引 key:表示实际使用的索引 key_len:索引字段的长度 ref:列与索引的比较 rows:扫描出的行数(估算的行数) filtered:按表条件过滤的行百分比 Extra:执行情况的描述和说明 SQL Server 索引 唯一索引（UNIQUE）：唯一索引不允许两行具有相同的索引值 主键索引：为表定义一个主键将自动创建主键索引，主键索引是唯一索引的特殊类型。主键索引要求主键中的每个值是唯一的，并且不能为空 聚集索引(Clustered)：表中各行的物理顺序与键值的逻辑（索引）顺序相同，每个表最多只能有一个，设置某列为主键，该列就默认为聚集索引 非聚集索引(NonClustered)：非聚集索引指定表的逻辑顺序。数据存储在一个位置，索引存储在另一个位置，索引中包含指向数据存储位置的指针。可以有多个，小于249个 SQL 优化 总结SQL优化中，就三点:\n最大化利用索引； 尽可能避免全表扫描； 减少无效数据的查询； 避免不走索引的场景 1. 尽量避免在字段开头模糊查询，会导致数据库引擎放弃索引进行全表扫码 例如： SELECT * FROM user WHERE name LIKE '%李%'\n优化方式：尽量在字段后面使用模糊查询，例如： SELECT * FROM user WHERE name LIKE '李%'\n如果需要在前面使用模糊查询，可以使用以下方式：\n使用MySQL内置函数INSTR(str, substr)，返回匹配子串的位置,类似Java中的str.indexOf(substr) 使用FullText全文索引，用match against检索 数据量较大的情况，使用ElasticSearch、solr，亿级数据量检索速度秒级 当数据量较少时（几千条），直接用LIKE '%李%' 2. 尽量避免使用in和not in，会导致全表扫描 SELECT * FROM table WHERE id IN (2,3)\n优化方式：如果是连续数值，可以使用between代替，例如: SELECT * FROM table WHERE id BETWEEN 2 AND 3\n如果是子查询，可以使用EXISTS或NOT EXISTS代替，例如: SELECT * FROM table WHERE EXISTS (SELECT id FROM table2 WHERE table.id = table2.id)\n3. 尽量避免使用OR，会导致全表扫描 SELECT * FROM table WHERE id = 1 OR id = 2\n优化方式：可以使用Union，例如: SELECT * FROM table WHERE id = 1 UNION SELECT * FROM table WHERE id = 2\n4. 尽量避免null值的判断 SELECT * FROM table WHERE id IS NULL\n优化方式：可以给字段添加默认值，对默认值进行判断，例如： SELECT * FROM table WHERE id = 默认值\n5. 尽量避免在where条件中等号左侧进行表达式、函数操作 可以将表达式、函数操作移动到等号右侧，例如：\n-- 全表扫码 SELECT * FROM table WHERE score/10 = 9 -- 走索引 SELECT * FROM table WHERE score = 10 * 9 6. 当数据量大时，避免使用where 1=1的条件 通常为了方便拼接查询条件，会使用它来作为条件\n优化方式：用代码拼接sql时进行判断，没where条件就去掉where，有where条件就加and\n7. 查询条件不能用\u0026lt;\u0026gt;或者!= 使用索引列作为条件进行查询时，需要避免使用\u0026lt;\u0026gt;或者!=等判断条件。如确实业务需要，使用到不等于符号，需要在重新评估索引建立，避免在此字段上建立索引，改由查询条件中其他索引字段代替\n8. where条件仅包含复合索引非前置列 如下：复合（联合）索引包含key_part1，key_part2，key_part3三列，但SQL语句没有包含索引前置列\u0026quot;key_part1\u0026quot;，按照MySQL联合索引的最左匹配原则，不会走联合索引 select col1 from table where key_part2=1 and key_part3=2\n9. 隐式类型转换造成不使用索引 如下SQL语句由于索引对列类型为varchar，但给定的值为数值，涉及隐式类型转换，造成不能正确走索引 select col1 from table where col_varchar=123; 10. order by 条件要与where中条件一致，否则order by不会利用索引进行排序 -- 不走age索引 SELECT * FROM t order by age; -- 走age索引 SELECT * FROM t where age \u0026gt; 0 order by age; 当order by 中的字段出现在where条件中时，才会利用索引而不再二次排序，更准确的说，order by 中的字段在执行计划中利用了索引时，不用排序操作\n这个结论不仅对order by有效，对其他需要排序的操作也有效。比如group by 、union 、distinct等\n11. 正确使用hint优化语句 MySQL中可以使用hint指定优化器在执行时选择或忽略特定的索引。一般而言，处于版本变更带来的表结构索引变化，更建议避免使用hint，而是通过Analyze table多收集统计信息。但在特定场合下，指定hint可以排除其他索引干扰而指定更优的执行计划。\nUSE INDEX 在你查询语句中表名的后面，添加 USE INDEX 来提供希望 MySQL 去参考的索引列表，就可以让 MySQL 不再考虑其他可用的索引。例子: SELECT col1 FROM table USE INDEX (mod_time, name)\u0026hellip; IGNORE INDEX 如果只是单纯的想让 MySQL 忽略一个或者多个索引，可以使用 IGNORE INDEX 作为 Hint。例子: SELECT col1 FROM table IGNORE INDEX (priority) \u0026hellip; FORCE INDEX 为强制 MySQL 使用一个特定的索引，可在查询中使用FORCE INDEX 作为Hint。例子: SELECT col1 FROM table FORCE INDEX (mod_time) \u0026hellip; 在查询的时候，数据库系统会自动分析查询语句，并选择一个最合适的索引。但是很多时候，数据库系统的查询优化器并不一定总是能使用最优索引。如果我们知道如何选择索引，可以使用FORCE INDEX强制查询使用指定的索引。\n例如：SELECT * FROM students FORCE INDEX (idx_class_id) WHERE class_id = 1 ORDER BY id DESC;\nSELECT语句其他优化 1. 避免出现select * 首先，select * 操作在任何类型数据库中都不是一个好的SQL编写习惯。\n使用select * 取出全部列，会让优化器无法完成索引覆盖扫描这类优化，会影响优化器对执行计划的选择，也会增加网络带宽消耗，更会带来额外的I/O,内存和CPU消耗。\n建议提出业务实际需要的列数，将指定列名以取代select *。\n2. 避免出现不确定结果的函数 特定针对主从复制这类业务场景。由于原理上从库复制的是主库执行的语句，使用如now()、rand()、sysdate()、current_user()等不确定结果的函数很容易导致主库与从库相应的数据不一致。另外不确定值的函数,产生的SQL语句无法利用query cache。\n3.多表关联查询时，小表在前，大表在后。 在MySQL中，执行 from 后的表关联查询是从左往右执行的（Oracle相反），第一张表会涉及到全表扫描，所以将小表放在前面，先扫小表，扫描快效率较高，在扫描后面的大表，或许只扫描大表的前100行就符合返回条件并return了。\n例如：表1有50条数据，表2有30亿条数据；如果全表扫描表2，你品，那就先去吃个饭再说吧是吧。\n4. 使用表的别名 当在SQL语句中连接多个表时，请使用表的别名并把别名前缀于每个列名上。这样就可以减少解析的时间并减少哪些友列名歧义引起的语法错误。\n5. 用where字句替换HAVING字句 避免使用HAVING字句，因为HAVING只会在检索出所有记录之后才对结果集进行过滤，而where则是在聚合前刷选记录，如果能通过where字句限制记录的数目，那就能减少这方面的开销。HAVING中的条件一般用于聚合函数的过滤，除此之外，应该将条件写在where字句中。\nwhere和having的区别：where后面不能使用组函数\n6.调整Where字句中的连接顺序 MySQL采用从左往右，自上而下的顺序解析where子句。根据这个原理，应将过滤数据多的条件往前放，最快速度缩小结果集。\n增删改 DML 语句优化 1. 大批量插入数据 如果同时执行大量的插入，建议使用多个值的INSERT语句(方法二)。这比使用分开INSERT语句快（方法一），一般情况下批量插入效率有几倍的差别。\n方法一：\ninsert into T values(1,2); insert into T values(1,3); insert into T values(1,4); 方法二：\nInsert into T values(1,2),(1,3),(1,4); 选择后一种方法的原因有三。\n减少SQL语句解析的操作，MySQL没有类似Oracle的share pool，采用方法二，只需要解析一次就能进行数据的插入操作； 在特定场景可以减少对DB连接次数 SQL语句较短，可以减少网络传输的IO。 2. 适当使用commit 适当使用commit可以释放事务占用的资源而减少消耗，commit后能释放的资源如下：\n事务占用的undo数据块； 事务在redo log中记录的数据块； 释放事务施加的，减少锁争用影响性能。特别是在需要使用delete删除大量数据的时候，必须分解删除量并定期commit。 3. 避免重复查询更新的数据 针对业务中经常出现的更新行同时又希望获得改行信息的需求，MySQL并不支持PostgreSQL那样的UPDATE RETURNING语法，在MySQL中可以通过变量实现。\n例如，更新一行记录的时间戳，同时希望查询当前记录中存放的时间戳是什么，简单方法实现：\nUpdate t1 set time=now() where col1=1; Select time from t1 where id =1; 使用变量，可以重写为以下方式：\nUpdate t1 set time=now () where col1=1 and @now: = now (); Select @now; 前后二者都需要两次网络来回，但使用变量避免了再次访问数据表，特别是当t1表数据量较大时，后者比前者快很多。\n4.查询优先还是更新（insert、update、delete）优先 MySQL 还允许改变语句调度的优先级，它可以使来自多个客户端的查询更好地协作，这样单个客户端就不会由于锁定而等待很长时间。改变优先级还可以确保特定类型的查询被处理得更快。我们首先应该确定应用的类型，判断应用是以查询为主还是以更新为主的，是确保查询效率还是确保更新的效率，决定是查询优先还是更新优先。下面我们提到的改变调度策略的方法主要是针对只存在表锁的存储引擎，比如 MyISAM 、MEMROY、MERGE，对于Innodb 存储引擎，语句的执行是由获得行锁的顺序决定的。MySQL 的默认的调度策略可用总结如下：\n1）写入操作优先于读取操作。\n2）对某张数据表的写入操作某一时刻只能发生一次，写入请求按照它们到达的次序来处理。\n3）对某张数据表的多个读取操作可以同时地进行。MySQL 提供了几个语句调节符，允许你修改它的调度策略：\nLOW_PRIORITY关键字应用于DELETE、INSERT、LOAD DATA、REPLACE和UPDATE； HIGH_PRIORITY关键字应用于SELECT和INSERT语句； DELAYED关键字应用于INSERT和REPLACE语句。 如果写入操作是一个 LOW_PRIORITY（低优先级）请求，那么系统就不会认为它的优先级高于读取操作。在这种情况下，如果写入者在等待的时候，第二个读取者到达了，那么就允许第二个读取者插到写入者之前。只有在没有其它的读取者的时候，才允许写入者开始操作。这种调度修改可能存在 LOW_PRIORITY写入操作永远被阻塞的情况。\nSELECT 查询的HIGH_PRIORITY（高优先级）关键字也类似。它允许SELECT 插入正在等待的写入操作之前，即使在正常情况下写入操作的优先级更高。另外一种影响是，高优先级的 SELECT 在正常的 SELECT 语句之前执行，因为这些语句会被写入操作阻塞。如果希望所有支持LOW_PRIORITY 选项的语句都默认地按照低优先级来处理，那么 请使用\u0026ndash;low-priority-updates 选项来启动服务器。通过使用 INSERTHIGH_PRIORITY 来把 INSERT 语句提高到正常的写入优先级，可以消除该选项对单个INSERT语句的影响。\n查询条件优化 1. 对于复杂的查询，可以使用中间临时表暂存数据 2. 优化group by语句 默认情况下，MySQL 会对GROUP BY分组的所有值进行排序，如 “GROUP BY col1，col2，\u0026hellip;.;” 查询的方法如同在查询中指定 “ORDER BY col1，col2，\u0026hellip;;” 如果显式包括一个包含相同的列的 ORDER BY子句，MySQL 可以毫不减速地对它进行优化，尽管仍然进行排序。\n因此，如果查询包括 GROUP BY 但你并不想对分组的值进行排序，你可以指定 ORDER BY NULL禁止排序。例如：\nSELECT col1, col2, COUNT(*) FROM table GROUP BY col1, col2 ORDER BY NULL\n3. 优化join语句 MySQL中可以通过子查询来使用 SELECT 语句来创建一个单列的查询结果，然后把这个结果作为过滤条件用在另一个查询中。使用子查询可以一次性的完成很多逻辑上需要多个步骤才能完成的 SQL 操作，同时也可以避免事务或者表锁死，并且写起来也很容易。但是，有些情况下，子查询可以被更有效率的连接(JOIN)..替代。\n例子：假设要将所有没有订单记录的用户取出来，可以用下面这个查询完成： SELECT col1 FROM customerinfo WHERE CustomerID NOT in (SELECT CustomerID FROM salesinfo )\n如果使用连接(JOIN).. 来完成这个查询工作，速度将会有所提升。尤其是当 salesinfo表中对 CustomerID 建有索引的话，性能将会更好，查询如下：\nSELECT col1 FROM customerinfo LEFT JOIN salesinfoON customerinfo.CustomerID=salesinfo.CustomerID WHERE salesinfo.CustomerID IS NULL 4. 优化union查询 MySQL通过创建并填充临时表的方式来执行union查询。除非确实要消除重复的行，否则建议使用union all。原因在于如果没有all这个关键词，MySQL会给临时表加上distinct选项，这会导致对整个临时表的数据做唯一性校验，这样做的消耗相当高。\n高效：\nSELECT COL1, COL2, COL3 FROM TABLE WHERE COL1 = 10 UNION ALL SELECT COL1, COL2, COL3 FROM TABLE WHERE COL3= \u0026#39;TEST\u0026#39;; 低效：\nSELECT COL1, COL2, COL3 FROM TABLE WHERE COL1 = 10 UNION SELECT COL1, COL2, COL3 FROM TABLE WHERE COL3= \u0026#39;TEST\u0026#39;; 5. 拆分复杂SQL为多个小SQL，避免大事务 简单的SQL容易使用到MySQL的QUERY CACHE； 减少锁表时间特别是使用MyISAM存储引擎的表； 可以使用多核CPU。 6. 使用truncate代替delete 当删除全表中记录时，使用delete语句的操作会被记录到undo块中，删除记录也记录binlog，当确认需要删除全表时，会产生很大量的binlog并占用大量的undo数据块，此时既没有很好的效率也占用了大量的资源。\n使用truncate替代，不会记录可恢复的信息，数据不能被恢复。也因此使用truncate操作有其极少的资源占用与极快的时间。另外，使用truncate可以回收表的水位，使自增字段值归零。\n7. 使用合理的分页方式以提高分页效率 使用合理的分页方式以提高分页效率 针对展现等分页需求，合适的分页方式能够提高分页的效率。\n案例1：\nselect * from t where thread_id = 10000 and deleted = 0 order by gmt_create asc limit 0, 15; 上述例子通过一次性根据过滤条件取出所有字段进行排序返回。数据访问开销=索引IO+索引全部记录结果对应的表数据IO。因此，该种写法越翻到后面执行效率越差，时间越长，尤其表数据量很大的时候。\n适用场景：当中间结果集很小（10000行以下）或者查询条件复杂（指涉及多个不同查询字段或者多表连接）时适用。\n案例2：\nselect t.* from (select id from t where thread_id = 10000 and deleted = 0 order by gmt_create asc limit 0, 15) a, t where a.id = t.id; 上述例子必须满足t表主键是id列，且有覆盖索引secondary key:(thread_id, deleted, gmt_create)。通过先根据过滤条件利用覆盖索引取出主键id进行排序，再进行join操作取出其他字段。数据访问开销=索引IO+索引分页后结果（例子中是15行）对应的表数据IO。因此，该写法每次翻页消耗的资源和时间都基本相同，就像翻第一页一样。\n适用场景：当查询和排序字段（即where子句和order by子句涉及的字段）有对应覆盖索引时，且中间结果集很大的情况时适用。\n建表优化 在表中建立索引，优先考虑where、order by使用到的字段 尽量使用数字型字段（如性别，男：1 女：2），若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会 逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了 查询数据量大的表会造成查询缓慢。主要的原因是扫描行数过多。这个时候可以通过程序，分段分页进行查询，循环遍历，将结果合并处理进行展示。要查询100000到100050的数据: SELECT * FROM (SELECT ROW_NUMBER() OVER(ORDER BY ID ASC) AS rowid,*\rFROM infoTab)t WHERE t.rowid \u0026gt; 100000 AND t.rowid \u0026lt;= 100050 用varchar/nvarchar 代替 char/nchar 尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。 不要以为 NULL 不需要空间，比如：char(100) 型，在字段建立时，空间就固定了， 不管是否插入值（NULL也包含在内），都是占用 100个字符的空间的，如果是varchar这样的变长字段， null 不占用空间。 ","permalink":"https://lesanouo.github.io/blog/posts/code/165504960001/","summary":"\u003ch1 id=\"索引\"\u003e索引\u003c/h1\u003e\n\u003ch2 id=\"mysql-索引\"\u003eMySQL 索引\u003c/h2\u003e\n\u003cp\u003eMySQL 的索引有两种分类方式：逻辑分类和物理分类\u003c/p\u003e\n\u003ch3 id=\"逻辑分类\"\u003e逻辑分类\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e主键索引：一张表只能有一个主键索引，不允许重复、不允许为 NULL\u003c/li\u003e\n\u003cli\u003e唯一索引：数据列不允许重复，允许为 NULL 值，一张表可有多个唯一索引，索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一\u003c/li\u003e\n\u003cli\u003e普通索引：一张表可以创建多个普通索引，一个普通索引可以包含多个字段，允许数据重复，允许 NULL 值插入\u003c/li\u003e\n\u003cli\u003e全文索引：它查找的是文本中的关键词，主要用于全文检索\u003c/li\u003e\n\u003cli\u003e单例索引：一个索引只包含一个列，一个表可以有多个单例索引\u003c/li\u003e\n\u003cli\u003e组合索引：一个组合索引包含两个或两个以上的列。查询的时候遵循 mysql 组合索引的 “最左前缀”原则，即使用 where 时条件要按照建立索引的时候字段的排列方式放置索引才会生效\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"物理分类\"\u003e物理分类\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e聚簇索引：不是单独的一种索引类型，而是一种数据存储方式。这种存储方式是依靠B+树来实现的，根据表的主键构造一棵B+树且B+树叶子节点存放的都是表的行记录数据时，方可称该主键索引为聚簇索引。聚簇索引也可理解为将数据存储与索引放到了一块，找到索引也就找到了数据。\u003c/li\u003e\n\u003cli\u003e非聚簇索引：数据和索引是分开的，B+树叶子节点存放的不是数据表的行记录\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"explain\"\u003eEXPLAIN\u003c/h3\u003e\n\u003cp\u003e使用格式：\u003ccode\u003eEXPLAIN SQL...\u003c/code\u003e;\u003c/p\u003e","title":"数据库优化Tips"},{"content":"简介 在大型企业中，服务器网络一般都会有各种各样的限制，常见的就会有堡垒机或者运维网关，以达到操作审计等目的。但对于开发者来讲，这些限制大大降低了效率，所以我们需要一个方便的方式来解决这个问题。\n本篇文章主要通过为Linux增加SSH端口的方式来解决这个问题，通过增加SSH访问端口来绕开22端口的限制。\n实现 SSH配置文件 通过 vi /etc/ssh/sshd_config 来配置SSH端口，在Port 22后添加一行Port XX即可\n配置SELinux 通过 semanage port -l | grep ssh 可以看到：\nssh_port_t tcp 22 可以看到并没有我们添加的端口\n可以执行semanage port -a -tssh_port_t -p tcp XX来添加\n再次检查：\nssh_port_t tcp XX, 22 重启SSH systemctl restart sshd.service 通过telnet可以验证 telnet IP地址 XX 通过以上操作后，就可以通过新开放的端口来实现对SSH服务的访问了\n","permalink":"https://lesanouo.github.io/blog/posts/code/165306240001/","summary":"\u003ch2 id=\"简介\"\u003e简介\u003c/h2\u003e\n\u003cp\u003e在大型企业中，服务器网络一般都会有各种各样的限制，常见的就会有堡垒机或者运维网关，以达到操作审计等目的。但对于开发者来讲，这些限制大大降低了效率，所以我们需要一个方便的方式来解决这个问题。\u003c/p\u003e","title":"Linux增加SSH端口"},{"content":"Redis简介 Redis 是完全开源的，遵守 BSD 协议，是一个高性能的 key-value 数据库。\nRedis 与其他 key - value 缓存产品有以下三个特点：\nRedis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。 Redis支持数据的备份，即master-slave模式的数据备份。 Redis数据结构 String（字符串） string 是 redis 最基本的类型，你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。\nstring 类型是二进制安全的。意思是 redis 的 string 可以包含任何数据。比如jpg图片或者序列化的对象。\nstring 类型是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB。\n127.0.0.1:6379\u0026gt; set name Lesan OK 127.0.0.1:6379\u0026gt; get name \u0026#34;Lesan\u0026#34; Hash（哈希） Redis hash 是一个键值(key=\u0026gt;value)对集合。\nRedis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。\n127.0.0.1:6379\u0026gt; hmset lesan field1 \u0026#34;Hello\u0026#34; field2 \u0026#34;World\u0026#34; OK 127.0.0.1:6379\u0026gt; hget lesan field1 \u0026#34;Hello\u0026#34; 127.0.0.1:6379\u0026gt; hget lesan field2 \u0026#34;World\u0026#34; List（列表） Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。\n127.0.0.1:6379\u0026gt; del lesan (integer) 1 127.0.0.1:6379\u0026gt; lpush lesan redis (integer) 1 127.0.0.1:6379\u0026gt; lpush lesan mongodb (integer) 2 127.0.0.1:6379\u0026gt; lpush lesan mysql (integer) 3 127.0.0.1:6379\u0026gt; lrange lesan 0 10 1) \u0026#34;mysql\u0026#34; 2) \u0026#34;mongodb\u0026#34; 3) \u0026#34;redis\u0026#34; Set（集合） Redis 的 Set 是 string 类型的无序集合。\n集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。\n127.0.0.1:6379\u0026gt; sadd lesan redis (integer) 1 127.0.0.1:6379\u0026gt; sadd lesan redis (integer) 0 127.0.0.1:6379\u0026gt; sadd lesan mongodb (integer) 1 127.0.0.1:6379\u0026gt; sadd lesan mysql (integer) 1 127.0.0.1:6379\u0026gt; smembers lesan 1) \u0026#34;redis\u0026#34; 2) \u0026#34;mysql\u0026#34; 3) \u0026#34;mongodb\u0026#34; zset（有序集合） Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。 不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。\nzset的成员是唯一的,但分数(score)却可以重复。\n127.0.0.1:6379\u0026gt; zadd lesan 0 redis (integer) 1 127.0.0.1:6379\u0026gt; zadd lesan 0 mongodb (integer) 1 127.0.0.1:6379\u0026gt; zadd lesan 0 mysql (integer) 1 127.0.0.1:6379\u0026gt; zadd lesan 0 mysql (integer) 0 127.0.0.1:6379\u0026gt; zrangebyscore lesan 0 100 1) \u0026#34;mongodb\u0026#34; 2) \u0026#34;mysql\u0026#34; 3) \u0026#34;redis\u0026#34; Stream Redis Stream 主要用于消息队列（MQ，Message Queue），Redis 本身是有一个 Redis 发布订阅 (pub/sub) 来实现消息队列的功能，但它有个缺点就是消息无法持久化，如果出现网络断开、Redis 宕机等，消息就会被丢弃。\n而 Redis Stream 提供了消息的持久化和主备复制功能，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能保证消息不丢失。\nRedis 命令 key Redis 键命令用于管理 redis 的键。\nDEL KEY_NAME 用于删除已存在的键。不存在的 key 会被忽略 DUMP KEY_NAME 用于序列化给定 key ，并返回被序列化的值 EXISTS KEY_NAME 用于检查给定 key 是否存在 Expire KEY_NAME TIME_IN_SECONDS 用于设置 key 的过期时间，key 过期后将不再可用。单位以秒计 Expireat KEY_NAME TIME_IN_UNIX_TIMESTAMP 用于以 UNIX 时间戳(unix timestamp)格式设置 key 的过期时间。key 过期后将不再可用 PEXPIRE key milliseconds 以毫秒为单位设置 key 的生存时间 PEXPIREAT KEY_NAME TIME_IN_MILLISECONDS_IN_UNIX_TIMESTAMP 设置 key 过期时间的时间戳(unix timestamp) 以毫秒计 KEYS PATTERN 用于查找所有符合给定模式 pattern 的 key MOVE KEY_NAME DESTINATION_DATABASE 用于将当前数据库的 key 移动到给定的数据库 db 当中 PERSIST KEY_NAME 用于移除给定 key 的过期时间，使得 key 永不过期 PTTL KEY_NAME 以毫秒为单位返回 key 的剩余过期时间 TTL KEY_NAME 以秒为单位返回 key 的剩余过期时间 RANDOMKEY 从当前数据库中随机返回一个 key RENAME OLD_KEY_NAME NEW_KEY_NAME 用于修改 key 的名称 RENAMENX OLD_KEY_NAME NEW_KEY_NAME 用于在新的 key 不存在时修改 key 的名称 SCAN cursor [MATCH pattern] [COUNT count] 用于迭代数据库中的数据库键 TYPE KEY_NAME 用于返回 key 所储存的值的类型 更多命令请参考菜鸟教程\nRedis 应用场景 缓存 作为Key-Value形态的内存数据库，Redis 最先会被想到的应用场景便是作为数据缓存。而使用 Redis 缓存数据非常简单，只需要通过string类型将序列化后的对象存起来即可，不过也有一些需要注意的地方：\n必须保证不同对象的 key 不会重复，并且使 key 尽量短，一般使用类名（表名）加主键拼接而成。 选择一个优秀的序列化方式也很重要，目的是提高序列化的效率和减少内存占用。 缓存内容与数据库的一致性，这里一般有两种做法： 只在数据库查询后将对象放入缓存，如果对象发生了修改或删除操作，直接清除对应缓存（或设为过期）。 在数据库新增和查询后将对象放入缓存，修改后更新缓存，删除后清除对应缓存（或设为过期）。 数据共享分布式 String 类型，因为 Redis 是分布式的独立服务，可以在多个应用之间共享 例如：分布式Session\n分布式锁 在分布式环境下，单体锁已不在适用，Redis中string的set命令增加了一些参数：\nEX：设置键的过期时间（单位为秒）\nPX：设置键的过期时间（单位为毫秒）\nNX：只在键不存在时，才对键进行设置操作。 SET key value NX 效果等同于 SETNX key value 。\nXX：只在键已经存在时，才对键进行设置操作。\n由于这个操作是原子性的，可以简单地以此实现一个分布式的锁，例如：\nset lock_key locked NX EX 1 如果这个操作返回false，说明 key 的添加不成功，也就是当前有人在占用这把锁。而如果返回true，则说明得了锁，便可以继续进行操作，并且在操作后通过del命令释放掉锁。并且即使程序因为某些原因并没有释放锁，由于设置了过期时间，该锁也会在 1 秒后自动释放，不会影响到其他程序的运行。\n推荐使用 redisson 第三方库实现分布式锁\n全局ID int类型，incrby，利用原子性\nincrby userid 1000 分库分表的场景，一次性拿一段\n计数器 int类型，incr方法\n例如：文章的阅读量、微博点赞数、允许一定的延迟，先写入Redis再定时同步到数据库\n计数功能应该是最适合 Redis 的使用场景之一了，因为它高频率读写的特征可以完全发挥 Redis 作为内存数据库的高效。在 Redis 的数据结构中，string、hash和sorted set都提供了incr方法用于原子性的自增操作，下面举例说明一下它们各自的使用场景：\n如果应用需要显示每天的注册用户数，便可以使用string作为计数器，设定一个名为REGISTERED_COUNT_TODAY的 key，并在初始化时给它设置一个到凌晨 0 点的过期时间，每当用户注册成功后便使用incr命令使该 key 增长 1，同时当每天凌晨 0 点后，这个计数器都会因为 key 过期使值清零。 每条微博都有点赞数、评论数、转发数和浏览数四条属性，这时用hash进行计数会更好，将该计数器的 key 设为weibo:weibo_id，hash的 field 为like_number、comment_number、forward_number和view_number，在对应操作后通过hincrby使hash 中的 field 自增。 如果应用有一个发帖排行榜的功能，便选择sorted set吧，将集合的 key 设为POST_RANK。当用户发帖后，使用zincrby将该用户 id 的 score 增长 1。sorted set会重新进行排序，用户所在排行榜的位置也就会得到实时的更新。 限流 int类型，incr方法\n以访问者的ip和其他信息作为key，访问一次增加一次计数，超过次数则返回false\n位统计 String类型的bitcount，字符是以8位二进制存储的\nset k1 a\rsetbit k1 6 1\rsetbit k1 7 0\rget k1 其中6 7 代表的a的二进制位的修改 a-\u0026gt;01100001 b-\u0026gt;01100010 因为bit非常节省空间，可以用来做大数据量的统计\n时间轴 list作为双向链表，不光可以作为队列使用。如果将它用作栈便可以成为一个公用的时间轴。当用户发完微博后，都通过lpush将它存放在一个 key 为LATEST_WEIBO的list中，之后便可以通过lrange取出当前最新的微博。\n消息队列 Redis 中list的数据结构实现是双向链表，所以可以非常便捷的应用于消息队列（生产者 / 消费者模型）。消息的生产者只需要通过lpush将消息放入 list，消费者便可以通过rpop取出该消息，并且可以保证消息的有序性。如果需要实现带有优先级的消息队列也可以选择sorted set。而pub/sub功能也可以用作发布者 / 订阅者模型的消息。无论使用何种方式，由于 Redis 拥有持久化功能，也不需要担心由于服务器故障导致消息丢失的情况。\nList提供了两个阻塞的弹出操作：blpop/brpop，可以设置超时时间\nblpop：blpop key1 timeout 移除并获取列表的第一个元素，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 brpop：brpop key1 timeout 移除并获取列表的最后一个元素，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 上面的操作。其实就是java的阻塞队列。学习的东西越多。学习成本越低\n队列：先进先除：rpush blpop，左头右尾，右边进入队列，左边出队列 栈：先进后出：rpush brpop 抽奖 利用set结构的无序性,通过 Spop（ Redis Spop 命令用于移除集合中的指定 key 的一个或多个随机元素，移除后会返回移除的元素 ） 随机获得值\n点赞、签到、打卡 假如微博ID是t1001，用户ID是u3001\n用 like:t1001 来维护 t1001 这条微博的所有点赞用户\n点赞了这条微博：sadd like:t1001 u3001 取消点赞：srem like:t1001 u3001 是否点赞：sismember like:t1001 u3001 点赞的所有用户：smembers like:t1001 点赞数：scard like:t1001 是不是比数据库简单多了。\n好友关系、用户关注、推荐模型 这个场景最开始是是一篇介绍微博 Redis 应用的 PPT 中看到的，其中提到微博的 Redis 主要是用在在计数和好友关系两方面上，当时对好友关系方面的用法不太了解，后来看到《Redis 设计与实现》中介绍到作者最开始去使用 Redis 便是希望能通过set解决传统数据库无法快速计算集合中交集这个功能。后来联想到微博当前的业务场景，确实能够以这种方式实现，所以姑且猜测一下：\n对于一个用户 A，将它的关注和粉丝的用户 id 都存放在两个 set 中：\nA:follow：存放 A 所有关注的用户 id A:follower：存放 A 所有粉丝的用户 id 那么通过sinter命令便可以根据A:follow和A:follower的交集得到与 A 互相关注的用户。当 A 进入另一个用户 B 的主页后，A:follow和B:follow的交集便是 A 和 B 的共同专注，A:follow和B:follower的交集便是 A 关注的人也关注了 B；通过sdiff命令便可得到差集，就可以得到用户间可能认识的人\n排行榜 使用sorted set(有序set)和一个计算热度的算法便可以轻松打造一个热度排行榜，zrevrangebyscore可以得到以分数倒序排列的序列，zrank可以得到一个成员在该排行榜的位置（是分数正序排列时的位置，如果要获取倒序排列时的位置需要用zcard-zrank）。\nid 为 6001 的新闻点击数加1：zincrby hotNews:20190926 1 n6001\n获取今天点击最多的15条：zrevrange hotNews:20190926 0 15 withscores\n更多应用案例可以查看本篇文章、或本篇文章\nRedis集群部署 主从复制 部署简单，分为一主一从，或一主N从。数据分布是在所有节点通过replication复制全量的数据。如果主节点挂掉，需要手动把其中的一个从节点设置为主节点\n实践：\n只需要在从库中执行slaveof ip port\n哨兵模式 稍微比第一种复杂点，引入哨兵，此集群的原理还是主从复制。但是此集群中必须至少3个sentinel节点，来对一主两从的节点进行监控。因为sentinel里面存在一个Leader选举机制。必须是单数。此时sentinel(哨兵)其实就是一个Redis的特殊实例。此时的三个sentinel实例又组成了一个集群，两两互相监控，且这三个sentinel实例又分别都监控了所有的Redis节点。当一个主节点（Master）挂掉时，此集群方式会通过配置自动由对应的从节点（slave）变为主节点。如果一个主节点下有N个从节点，则进行选举机制来确定哪一个从节点变为主节点。此时所有节点的数据也都是全量的\n分片模式 此集群是Redis从3.0版本开始支持，自带的一种集群方式。它的原理使用了分布的思想，其数据会均分到所有的主节点上。且有一个虚拟槽的概念。此部署方式，当数据量过大时，会让服务器均摊压力。在各个主节点上分配的数据都不是全量的。是分片存储的。目前此种部署方式在生产环境的较多\n参考自： https://blog.csdn.net/u014659211/article/details/119805443 https://blog.csdn.net/qq_42815754/article/details/82912130\n","permalink":"https://lesanouo.github.io/blog/posts/code/165297600001/","summary":"\u003ch2 id=\"redis简介\"\u003eRedis简介\u003c/h2\u003e\n\u003cp\u003eRedis 是完全开源的，遵守 BSD 协议，是一个高性能的 key-value 数据库。\u003c/p\u003e\n\u003cp\u003eRedis 与其他 key - value 缓存产品有以下三个特点：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eRedis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。\u003c/li\u003e\n\u003cli\u003eRedis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。\u003c/li\u003e\n\u003cli\u003eRedis支持数据的备份，即master-slave模式的数据备份。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"redis数据结构\"\u003eRedis数据结构\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003eString（字符串）\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003estring 是 redis 最基本的类型，你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。\u003c/p\u003e","title":"Redis笔记"},{"content":"生产者消费者问题（Producer-consumer problem），也称有限缓冲问题（Bounded-buffer problem），是一个多线程同步问题的经典案例。生产者生成一定量的数据放到缓冲区中，然后重复此过程；与此同时，消费者也在缓冲区消耗这些数据。生产者和消费者之间必须保持同步，要保证生产者不会在缓冲区满时放入数据，消费者也不会在缓冲区空时消耗数据。不够完善的解决方法容易出现死锁的情况，此时进程都在等待唤醒。\n下图为生产者和消费者的示意图： 解决思想 保证同一资源被多个线程并发访问时的完整性。常用的同步方法是采用信号或加锁机制，保证资源在任意时刻至多被一个线程访问\nJava实现的几种方式 wait() / notify() 方法 await() / signal() 方法(可重入锁ReentrantLock) BlockingQueue 阻塞队列方法 信号量方法 管道方法 代码实现 wait() / notify() 方法 首先，先介绍一下 Thread.sleep()和 Object.wait()、Object.notify()的区别。\nsleep()是Thread类的方法；而 wait()，notify()，notifyAll()是Object类中定义的方法；尽管这两个方法都会影响线程的执行行为，但是本质上是有区别的 Thread.sleep()不会导致锁行为的改变，如果当前线程是拥有锁的，那么 Thread.sleep()不会让线程释放锁。如果能够帮助你记忆的话，可以简单认为和锁相关的方法都定义在Object类中，因此调用 Thread.sleep()是不会影响锁的相关行为 Thread.sleep和 Object.wait都会暂停当前的线程，对于CPU资源来说，不管是哪种方式暂停的线程，都表示它暂时不再需要CPU的执行时间。OS会将执行时间分配给其它线程。区别是调用wait后，需要别的线程执行notify/notifyAll才能够重新获得CPU执行时间 Thread.sleep()让线程从 【running】 -\u0026gt; 【阻塞态】 时间结束/interrupt -\u0026gt; 【runnable】;Object.wait()让线程从 【running】 -\u0026gt; 【等待队列】notify -\u0026gt; 【锁池】 -\u0026gt; 【runnable】 wait()和notify()方法的实现，缓冲区满和为空时都调用wait()方法等待，当生产者生产了一个数据或者消费者消费了一个数据之后会通过notify()唤醒所有线程。\nimport java.util.*; public class Test { // 缓冲区最大容量 private static final int MAX_SIZE = 100; // 计数 private static int count = 0; // 缓冲区 private static LinkedList\u0026lt;Integer\u0026gt; list = new LinkedList\u0026lt;Integer\u0026gt;(); public static void main(String[] args) { Thread producer = new Thread(new Producer()); Thread consumer = new Thread(new Consumer()); producer.start(); consumer.start(); } // 生产者 public static class Producer implements Runnable { @Override public void run() { while (true) { // 为list上锁 synchronized (list) { // 缓冲区满时，等待 while (list.size() == MAX_SIZE) { try { System.out.println(\u0026#34;list is full, Producer waiting\u0026#34;); list.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } // 生产数据 count++; System.out.println(\u0026#34;Producer produce \u0026#34; + count); list.add(count); // 唤醒消费者 list.notifyAll(); // 等待一段时间再生产 try { Thread.sleep(new Random().nextInt(1000)); } catch (InterruptedException e) { e.printStackTrace(); } } // 当生产100个数就结束 if (count == 100) { break; } } } } // 消费者 public static class Consumer implements Runnable { @Override public void run() { while (true) { // 为list上锁 synchronized (list) { // 缓冲区空时，等待 while (list.isEmpty()) { try { System.out.println(\u0026#34;list is empty, Consumer waiting\u0026#34;); list.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } // 消费数据 int temp = list.poll(); System.out.println(\u0026#34;Consumer consume \u0026#34; + temp); // 唤醒生产者 list.notifyAll(); } // 当消费100个数就结束 if (count == 100 \u0026amp;\u0026amp; list.isEmpty()) { break; } } } } } 执行结果如下： 注意：\nnotifyAll()方法可使所有正在等待队列中等待同一共享资源的“全部”线程从等待状态退出，进入可运行状态。此时，优先级最高的那个线程最先执行，但也有可能是随机执行的，这要取决于JVM虚拟机的实现。即最终也只有一个线程能被运行，上述线程优先级都相同，每次运行的线程都不确定是哪个，后来给线程设置优先级后也跟预期不一样，还是要看JVM的具体实现吧。\nawait() / signal() 方法(可重入锁ReentrantLock) 在JDK5.0之后，Java提供了更加健壮的线程处理机制，包括同步、锁定、线程池等，它们可以实现更细粒度的线程控制。用ReentrantLock和Condition可以实现等待/通知模型，具有更大的灵活性。通过在Lock对象上调用newCondition()方法，将条件变量和一个锁对象进行绑定，进而控制并发程序访问竞争资源的安全。\nCondition接口的await()和signal()就是其中用来做同步的两种方法，它们的功能基本上和Object的wait()/ nofity()相同，完全可以取代它们，但是它们和新引入的锁定机制Lock直接挂钩，具有更大的灵活性。通过在Lock对象上调用newCondition()方法，将条件变量和一个锁对象进行绑定，进而控制并发程序访问竞争资源的安全。\nimport java.util.*; import java.util.concurrent.locks.*; public class Test1 { private static final int MAX_SIZE = 100; private static int count = 0; private static LinkedList\u0026lt;Integer\u0026gt; list = new LinkedList\u0026lt;Integer\u0026gt;(); // 创建锁及其条件 private static final Lock lock = new ReentrantLock(); private static final Condition fullCondition = lock.newCondition(); private static final Condition emptyCondition = lock.newCondition(); public static void main(String[] args) { Thread producer = new Thread(new Producer()); Thread consumer = new Thread(new Consumer()); producer.start(); consumer.start(); } public static class Producer implements Runnable { @Override public void run() { while (true) { // 上锁 lock.lock(); try { // 缓冲区满时，等待 while (list.size() == MAX_SIZE) { try { System.out.println(\u0026#34;list is full, Producer waiting\u0026#34;); fullCondition.await(); } catch (InterruptedException e) { e.printStackTrace(); } } // 生产数据 count++; System.out.println(\u0026#34;Producer produce \u0026#34; + count); list.add(count); // 唤醒消费者 emptyCondition.signalAll(); } finally { lock.unlock(); } try { Thread.sleep(new Random().nextInt(1000)); } catch (InterruptedException e) { e.printStackTrace(); } if (count == 100) { break; } } } } public static class Consumer implements Runnable { @Override public void run() { while (true) { // 上锁 lock.lock(); try { // 缓冲区空时，等待 while (list.isEmpty()) { try { System.out.println(\u0026#34;list is empty, Consumer waiting\u0026#34;); emptyCondition.await(); } catch (InterruptedException e) { e.printStackTrace(); } } // 消费数据 int temp = list.poll(); System.out.println(\u0026#34;Consumer consume \u0026#34; + temp); // 唤醒生产者 fullCondition.signalAll(); } finally { lock.unlock(); } if (count == 100 \u0026amp;\u0026amp; list.isEmpty()) { break; } } } } } 运行结果如下：（与第一种方法类似） BlockingQueue 阻塞队列方法 JDK 1.5 以后新增的 java.util.concurrent包新增了 BlockingQueue 接口。并提供了如下几种阻塞队列实现：\njava.util.concurrent.ArrayBlockingQueue java.util.concurrent.LinkedBlockingQueue java.util.concurrent.SynchronousQueue java.util.concurrent.PriorityBlockingQueue 实现生产者-消费者模型使用 ArrayBlockingQueue或者 LinkedBlockingQueue即可。\n我们这里使用LinkedBlockingQueue，它是一个已经在内部实现了同步的队列，实现方式采用的是我们第2种await()/ signal()方法。它可以在生成对象时指定容量大小。它用于阻塞操作的是put()和take()方法。\nput()方法：类似于我们上面的生产者线程，容量达到最大时，自动阻塞。 take()方法：类似于我们上面的消费者线程，容量为0时，自动阻塞。\nimport java.util.*; import java.util.concurrent.LinkedBlockingQueue; public class Test2 { private static final int MAX_SIZE = 100; private static int count = 0; // 创建阻塞队列 private static LinkedBlockingQueue\u0026lt;Integer\u0026gt; blockingQueue = new LinkedBlockingQueue\u0026lt;Integer\u0026gt;(MAX_SIZE); public static void main(String[] args) { Thread producer = new Thread(new Producer()); Thread consumer = new Thread(new Consumer()); producer.start(); consumer.start(); } public static class Producer implements Runnable { @Override public void run() { while (true) { try { count++; // 生产数据到阻塞队列 blockingQueue.put(count); System.out.println(\u0026#34;Producer produce \u0026#34; + count); } catch (InterruptedException e) { e.printStackTrace(); } try { Thread.sleep(new Random().nextInt(1000)); } catch (InterruptedException e) { e.printStackTrace(); } if (count == 100) { break; } } } } public static class Consumer implements Runnable { @Override public void run() { while (true) { try { // 从阻塞队列消费数据 int value = blockingQueue.take(); System.out.println(\u0026#34;Consumer consume \u0026#34; + value); } catch (InterruptedException e) { e.printStackTrace(); } if (count == 100 \u0026amp;\u0026amp; blockingQueue.isEmpty()) { break; } } } } } 信号量方法 Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源，在操作系统中是一个非常重要的问题，可以用来解决哲学家就餐问题。Java中的Semaphore维护了一个许可集，一开始先设定这个许可集的数量，可以使用acquire()方法获得一个许可，当许可不足时会被阻塞，release()添加一个许可。\nSemaphore可以用来构建一些对象池，资源池之类的，比如数据库连接池，我们也可以创建计数为1的Semaphore，将其作为一种类似互斥锁的机制，这也叫二元信号量，表示两种互斥状态。\n在下列代码中，还加入了另外一个mutex信号量，维护生产者消费者之间的同步关系，保证生产者和消费者之间的交替进行\nimport java.util.*; import java.util.concurrent.Semaphore; public class Test3 { private static final int MAX_SIZE = 100; private static int count = 0; private static LinkedList\u0026lt;Integer\u0026gt; list = new LinkedList\u0026lt;Integer\u0026gt;(); // 创建信号量 final static Semaphore notFull = new Semaphore(MAX_SIZE); final static Semaphore notEmpty = new Semaphore(0); final static Semaphore mutex = new Semaphore(1); public static void main(String[] args) { Thread producer = new Thread(new Producer()); Thread consumer = new Thread(new Consumer()); producer.start(); consumer.start(); } public static class Producer implements Runnable { @Override public void run() { while (true) { try { // 获取许可 notFull.acquire(); mutex.acquire(); // 生产数据 count++; list.add(count); System.out.println(\u0026#34;Producer produce \u0026#34; + count); } catch (InterruptedException e) { e.printStackTrace(); } finally { // 释放许可 mutex.release(); notEmpty.release(); } try { Thread.sleep(new Random().nextInt(1000)); } catch (InterruptedException e) { e.printStackTrace(); } if (count == 100) { break; } } } } public static class Consumer implements Runnable { @Override public void run() { while (true) { try { // 获取许可 notEmpty.acquire(); mutex.acquire(); // 消费数据 int value = list.poll(); System.out.println(\u0026#34;Consumer consume \u0026#34; + value); } catch (InterruptedException e) { e.printStackTrace(); } finally { // 释放许可 mutex.release(); notFull.release(); } if (count == 100 \u0026amp;\u0026amp; list.isEmpty()) { break; } } } } } 管道方法 在java的io包下，PipedOutputStream和PipedInputStream分别是管道输出流和管道输入流。\n它们的作用是让多线程可以通过管道进行线程间的通讯。在使用管道通信时，必须将PipedOutputStream和PipedInputStream配套使用。\n使用方法：先创建一个管道输入流和管道输出流，然后将输入流和输出流进行连接，用生产者线程往管道输出流中写入数据，消费者在管道输入流中读取数据，这样就可以实现了不同线程间的相互通讯。\n但是这种方式在生产者和生产者、消费者和消费者之间不能保证同步，也就是说在一个生产者和一个消费者的情况下是可以生产者和消费者之间交替运行的，多个生成者和多个消费者者之间则不行。\n这种方式只适用于两个线程之间通信，不适合多个线程之间通信。\nimport java.io.IOException; import java.io.PipedInputStream; import java.io.PipedOutputStream; import java.util.*; public class Test4 { // 控制生产和消费个100次 private static int countP = 0; private static int countS = 0; // 创建管道输入流和管道输出流 final static PipedInputStream pis = new PipedInputStream(); final static PipedOutputStream pos = new PipedOutputStream(); // 将输入流和输出流进行连接 static { try { pis.connect(pos); } catch (IOException e) { e.printStackTrace(); } } public static void main(String[] args) { Thread producer = new Thread(new Producer()); Thread consumer = new Thread(new Consumer()); producer.start(); consumer.start(); } public static class Producer implements Runnable { @Override public void run() { try { while (true) { // 写入数据 countP++; pos.write(countP); pos.flush(); System.out.println(\u0026#34;Producer produce \u0026#34; + countP); Thread.sleep(new Random().nextInt(1000)); if (countP == 100) { break; } } } catch (Exception e) { e.printStackTrace(); } finally { try { // 关闭输出流 pos.close(); } catch (IOException e) { e.printStackTrace(); } } } } public static class Consumer implements Runnable { @Override public void run() { try { while (true) { // 读取数据 countS++; int value = pis.read(); System.out.println(\u0026#34;Consumer consume \u0026#34; + value); if (countS == 100) { break; } } } catch (IOException e) { e.printStackTrace(); } finally { try { // 关闭输入流 pis.close(); } catch (IOException e) { e.printStackTrace(); } } } } } ","permalink":"https://lesanouo.github.io/blog/posts/code/165193920001/","summary":"\u003cp\u003e生产者消费者问题（Producer-consumer problem），也称有限缓冲问题（Bounded-buffer problem），是一个多线程同步问题的经典案例。生产者生成一定量的数据放到缓冲区中，然后重复此过程；与此同时，消费者也在缓冲区消耗这些数据。生产者和消费者之间必须保持同步，要保证生产者不会在缓冲区满时放入数据，消费者也不会在缓冲区空时消耗数据。不够完善的解决方法容易出现死锁的情况，此时进程都在等待唤醒。\u003c/p\u003e","title":"生产者与消费者问题"},{"content":"本篇笔记主要记录我在学习Java的stream流中记录的笔记\nstream是什么 流是从支持数据处理操作的源生成的元素序列，源可以是数组、文件、集合、函数。流不是集合元素，它不是数据结构并不保存数据，它的主要目的在于计算\n生成stream的方法 生成流的方式主要有五种\n通过集合生成，应用中最常用的一种 List\u0026lt;Integer\u0026gt; integerList = Arrays.asList(1, 2, 3, 4, 5, 6); Stream\u0026lt;Integer\u0026gt; stream = integerList.stream(); 通过数组生成 int[] intArr = {1, 2, 3, 4, 5, 6}; IntStream stream = Arrays.stream(intArr); 通过Arrays.stream方法生成流，并且该方法生成的流是数值流【即IntStream】而不是 Stream。补充一点使用数值流可以避免计算过程中拆箱装箱，提高性能。Stream API提供了mapToInt、mapToDouble、mapToLong三种方式将对象流【即Stream 】转换成对应的数值流，同时提供了boxed方法将数值流转换为对象流\n通过值生成 // 通过Stream的of方法生成流，通过Stream的empty方法可以生成一个空流 Stream\u0026lt;Integer\u0026gt; stream = Stream.of(1, 2, 3, 4, 5, 6); 通过文件生成 // 通过Files.line方法得到一个流，并且得到的每个流是给定文件中的一行 Stream\u0026lt;String\u0026gt; lines = Files.lines(Paths.get(\u0026#34;data.txt\u0026#34;), Charset.defaultCharset()); 通过函数生成 // 1.iterator // terate方法接受两个参数，第一个为初始化值，第二个为进行的函数操作，因为iterator生成的流为无限流，通过limit方法对流进行了截断，只生成5个偶数 Stream\u0026lt;Integer\u0026gt; stream = Stream.iterate(0, n -\u0026gt; n + 2).limit(5); // 2.generator // generate方法接受一个参数，方法参数类型为Supplier ，由它为流提供值。generate生成的流也是无限流，因此通过limit对流进行了截断 Stream\u0026lt;Double\u0026gt; stream = Stream.generate(Math::random).limit(5); stream的操作类型 中间操作 一个流可以后面跟随零个或多个中间操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的，仅仅调用到这类方法，并没有真正开始流的遍历，真正的遍历需等到终端操作时，常见的中间操作有下面即将介绍的 filter、map 等。\n终端操作 一个流有且只能有一个终端操作，当这个操作执行后，流就被关闭了，无法再被操作，因此一个流只能被遍历一次，若想在遍历需要通过源数据在生成流。终端操作的执行，才会真正开始流的遍历。如下面即将介绍的 count、collect 等。\nstream的使用 中间操作 filter 筛选 // 通过使用filter方法进行条件筛选，filter的方法参数为一个条件（过滤保留函数返回值为 true 的元素） List\u0026lt;Integer\u0026gt; integerList = Arrays.asList(1, 2, 3, 4, 5, 6); Stream\u0026lt;Integer\u0026gt; stream = integerList.stream().filter(i -\u0026gt; i \u0026gt; 3); // 结果为：4,5,6 distinct 去重 // 通过distinct方法快速去除重复的元素 List\u0026lt;Integer\u0026gt; integerList = Arrays.asList(1, 1, 2, 3, 4, 5); Stream\u0026lt;Integer\u0026gt; stream = integerList.stream().distinct(); // 结果为：1,2,3,4,5 limit 返回指定流个数 // 通过limit方法指定返回流的个数，limit的参数值必须 \u0026gt;=0，否则将会抛出异常。 List\u0026lt;Integer\u0026gt; integerList = Arrays.asList(1, 1, 2, 3, 4, 5); Stream\u0026lt;Integer\u0026gt; stream = integerList.stream().limit(3); 结果为： 1,1,2 skip 跳过流中的元素 // 通过skip方法跳过流中的元素，skip的参数值必须\u0026gt;=0，否则将会抛出异常 List\u0026lt;Integer\u0026gt; integerList = Arrays.asList(1, 1, 2, 3, 4, 5); Stream\u0026lt;Integer\u0026gt; stream = integerList.stream().skip(2); // 结果为： 2,3,4,5 map 流映射 // 所谓流映射就是将接受的元素映射成另外一个元素 List\u0026lt;String\u0026gt; stringList = Arrays.asList(\u0026#34;Java 8\u0026#34;, \u0026#34;Lambdas\u0026#34;, \u0026#34;In\u0026#34;, \u0026#34;Action\u0026#34;); List\u0026lt;Integer\u0026gt; collect = stringList.stream() .map(String::length) .collect(Collectors.toList()); // 通过map方法可以完成映射，该例子完成中 String -\u0026gt; Integer 的映射 // 结果为：[6, 7, 2, 6] flatMap 流转换 // 将一个流中的每个值都转换为另一个流 List\u0026lt;String\u0026gt; wordList = Arrays.asList(\u0026#34;Java 8\u0026#34;, \u0026#34;Lambdas\u0026#34;, \u0026#34;In\u0026#34;, \u0026#34;Action\u0026#34;); List\u0026lt;String\u0026gt; strList = wordList.stream() .map(w -\u0026gt; w.split(\u0026#34; \u0026#34;)) .flatMap(Arrays::stream) .distinct() .collect(Collectors.toList()); // map(w -\u0026gt; w.split(\u0026#34; \u0026#34;)) 的返回值为 Stream\u0026lt;String[]\u0026gt;，想获取 Stream，可以通过flatMap方法完成 Stream -\u0026gt;Stream 的转换 // 结果为：[Java, 8, Lambdas, In, Action] allMatch 匹配所有元素 // 匹配流中所有元素是否满足条件 List\u0026lt;Integer\u0026gt; integerList = Arrays.asList(1, 2, 3, 4, 5); if (integerList.stream().allMatch(i -\u0026gt; i \u0026gt; 3)) { System.out.println(\u0026#34;所有元素值都大于3\u0026#34;); } else { System.out.println(\u0026#34;并非所有元素值都大于3\u0026#34;); } // 结果为：并非所有元素值都大于3 anyMatch匹配其中一个 // 匹配流中是否存在一个满足条件的元素 List\u0026lt;Integer\u0026gt; integerList = Arrays.asList(1, 2, 3, 4, 5); if (integerList.stream().anyMatch(i -\u0026gt; i \u0026gt; 3)) { System.out.println(\u0026#34;存在值大于3的元素\u0026#34;); } else { System.out.println(\u0026#34;不存在值大于3的元素\u0026#34;); } // 结果为：存在值大于3的元素 // 上述代码等同于： for (Integer i : integerList) { if (i \u0026gt; 3) { System.out.println(\u0026#34;存在大于3的值\u0026#34;); break; } } noneMatch全部不匹配 List\u0026lt;Integer\u0026gt; integerList = Arrays.asList(1, 2, 3, 4, 5); if (integerList.stream().noneMatch(i -\u0026gt; i \u0026gt; 3)) { System.out.println(\u0026#34;值都小于3的元素\u0026#34;); } else { System.out.println(\u0026#34;值不都小于3的元素\u0026#34;); } 终端操作 count 统计流中元素个数 List\u0026lt;Integer\u0026gt; integerList = Arrays.asList(1, 2, 3, 4, 5); Long result = integerList.stream().count(); // 结果为：5 findFirst 查找第一个 List\u0026lt;Integer\u0026gt; integerList = Arrays.asList(1, 2, 3, 4, 5); Optional\u0026lt;Integer\u0026gt; result = integerList.stream().filter(i -\u0026gt; i \u0026gt; 3).findFirst(); System.out.println(result.orElse(-1)); // 结果为：4 findAny 随机查找一个 List\u0026lt;Integer\u0026gt; integerList = Arrays.asList(1, 2, 3, 4, 5); Optional\u0026lt;Integer\u0026gt; result = integerList.stream().filter(i -\u0026gt; i \u0026gt; 3).findAny(); System.out.println(result.orElse(-1)); // 结果为：4 // 通过findAny方法查找到其中一个大于三的元素并打印，因为内部进行优化的原因，当找到第一个满足大于三的元素时就结束，该方法结果和findFirst方法结果一样。提供findAny方法是为了更好的利用并行流，findFirst方法在并行上限制更多【本篇文章将不介绍并行流】 reduce 将流中的元素组合 用于求和 List\u0026lt;Integer\u0026gt; integerList = Arrays.asList(1, 2, 3, 4, 5); int sum = integerList.stream() .reduce(0, Integer::sum); // 结果为：15 // reduce接受两个参数，一个初始值这里是0，一个 BinaryOperatoraccumulator 来将两个元素结合起来产生一个新值，另外reduce方法还有一个没有初始化值的重载方法 用于取得最大和最小值 List\u0026lt;String\u0026gt; stringList = Arrays.asList(\u0026#34;Java 8\u0026#34;, \u0026#34;Lambdas\u0026#34;, \u0026#34;In\u0026#34;, \u0026#34;Action\u0026#34;); Optional\u0026lt;Integer\u0026gt; min = stringList.stream() .map(String::length) .reduce(Integer::min); Optional\u0026lt;Integer\u0026gt; max = stringList.stream() .map(String::length) .reduce(Integer::max); // 结果为：Optional[2] 和 Optional[7] min/max 获取最小最大值 // 写法1 List\u0026lt;String\u0026gt; stringList = Arrays.asList(\u0026#34;Java 8\u0026#34;, \u0026#34;Lambdas\u0026#34;, \u0026#34;In\u0026#34;, \u0026#34;Action\u0026#34;); Optional\u0026lt;Integer\u0026gt; min = stringList.stream() .map(String::length) .min(Integer::compareTo); Optional\u0026lt;Integer\u0026gt; max = stringList.stream() .map(String::length) .max(Integer::compareTo); // 写法2 List\u0026lt;String\u0026gt; stringList = Arrays.asList(\u0026#34;Java 8\u0026#34;, \u0026#34;Lambdas\u0026#34;, \u0026#34;In\u0026#34;, \u0026#34;Action\u0026#34;); OptionalInt min = stringList.stream() .mapToInt(String::length) .min(); OptionalInt max = stringList.stream() .mapToInt(String::length) .max(); // 使用reduce List\u0026lt;String\u0026gt; stringList = Arrays.asList(\u0026#34;Java 8\u0026#34;, \u0026#34;Lambdas\u0026#34;, \u0026#34;In\u0026#34;, \u0026#34;Action\u0026#34;); Optional\u0026lt;Integer\u0026gt; min = stringList.stream() .map(String::length) .reduce(Integer::min); Optional\u0026lt;Integer\u0026gt; max = stringList.stream() .map(String::length) .reduce(Integer::max); sum / summingxxx / reduce 求和 // 方式1：sum List\u0026lt;String\u0026gt; stringList = Arrays.asList(\u0026#34;Java 8\u0026#34;, \u0026#34;Lambdas\u0026#34;, \u0026#34;In\u0026#34;, \u0026#34;Action\u0026#34;); int sum = stringList.stream() .mapToInt(String::length) .sum(); // 方式2：summingInt List\u0026lt;String\u0026gt; stringList = Arrays.asList(\u0026#34;Java 8\u0026#34;, \u0026#34;Lambdas\u0026#34;, \u0026#34;In\u0026#34;, \u0026#34;Action\u0026#34;); // 如果数据类型为double、long，则通过summingDouble、summingLong方法进行求和 int sum = stringList.stream() .collect(summingInt(String::length)); // 方式3：reduce List\u0026lt;String\u0026gt; stringList = Arrays.asList(\u0026#34;Java 8\u0026#34;, \u0026#34;Lambdas\u0026#34;, \u0026#34;In\u0026#34;, \u0026#34;Action\u0026#34;); int sum = stringList.stream() .map(String::length) .reduce(0, Integer::sum); 在上面求和、求最大值、最小值的时候，对于相同操作有不同的方法可以选择执行。可以选择collect、reduce、min/max/sum方法，推荐使用min、max、sum方法。因为它最简洁易读，同时通过mapToInt将对象流转换为数值流，避免了装箱和拆箱操作\naveragingxxx 求平均值 // averagingxxx List\u0026lt;String\u0026gt; stringList = Arrays.asList(\u0026#34;Java 8\u0026#34;, \u0026#34;Lambdas\u0026#34;, \u0026#34;In\u0026#34;, \u0026#34;Action\u0026#34;); double average = stringList.stream() .collect(averagingInt(String::length)); summarizingxxx 同时求总和、平均值、最大值、最小值 // 如果数据类型为double、long，则通过summarizingDouble、summarizingLong方法 List\u0026lt;String\u0026gt; stringList = Arrays.asList(\u0026#34;Java 8\u0026#34;, \u0026#34;Lambdas\u0026#34;, \u0026#34;In\u0026#34;, \u0026#34;Action\u0026#34;); IntSummaryStatistics intSummaryStatistics = stringList.stream() .collect(summarizingInt(String::length)); double average = intSummaryStatistics.getAverage(); // 获取平均值 int min = intSummaryStatistics.getMin(); // 获取最小值 int max = intSummaryStatistics.getMax(); // 获取最大值 long sum = intSummaryStatistics.getSum(); // 获取总和 foreach 遍历 List\u0026lt;String\u0026gt; stringList = Arrays.asList(\u0026#34;Java 8\u0026#34;, \u0026#34;Lambdas\u0026#34;, \u0026#34;In\u0026#34;, \u0026#34;Action\u0026#34;); stringList.stream().forEach(System.out::println); collect 返回集合 List\u0026lt;String\u0026gt; stringList = Arrays.asList(\u0026#34;Java 8\u0026#34;, \u0026#34;Lambdas\u0026#34;, \u0026#34;In\u0026#34;, \u0026#34;Action\u0026#34;); List\u0026lt;Integer\u0026gt; intList = stringList.stream() .map(String::length) .collect(toList()); Set\u0026lt;Integer\u0026gt; intSet = stringList.stream() .map(String::length) .collect(toSet()); // 等价 List\u0026lt;Integer\u0026gt; intList = new ArrayList\u0026lt;\u0026gt;(); Set\u0026lt;Integer\u0026gt; intSet = new HashSet\u0026lt;\u0026gt;(); for (String item : stringList) { intList.add(item.length()); intSet.add(item.length()); } 通过遍历和返回集合的使用发现流只是把原来的外部迭代放到了内部进行，这也是流的主要特点之一。内部迭代可以减少好多代码量\njoining 拼接流中的元素 List\u0026lt;String\u0026gt; stringList = Arrays.asList(\u0026#34;Java 8\u0026#34;, \u0026#34;Lambdas\u0026#34;, \u0026#34;In\u0026#34;, \u0026#34;Action\u0026#34;); String result = stringList.stream() .map(String::toLowerCase) .collect(Collectors.joining(\u0026#34;-\u0026#34;)); // 结果为：java 8-lambdas-in-action groupingBy 分组 // 在collect方法中传入groupingBy进行分组，其中groupingBy的方法参数为分类函数 List\u0026lt;String\u0026gt; stringList = Arrays.asList(\u0026#34;Java 8\u0026#34;, \u0026#34;Lambdas\u0026#34;, \u0026#34;In\u0026#34;, \u0026#34;Action\u0026#34;); Map\u0026lt;Integer, List\u0026lt;String\u0026gt;\u0026gt; collect = stringList.stream().collect(groupingBy(String::length)); // 结果为：{2=[In], 6=[Java 8, Action], 7=[Lambdas]} 嵌套groupingBy进行多级分类\nList\u0026lt;String\u0026gt; stringList = Arrays.asList(\u0026#34;Java 12\u0026#34;, \u0026#34;Lambdas\u0026#34;, \u0026#34;In\u0026#34;, \u0026#34;Action\u0026#34;); Map\u0026lt;Integer, Map\u0026lt;Integer, List\u0026lt;String\u0026gt;\u0026gt;\u0026gt; collect = stringList.stream() .collect(groupingBy( String::length, groupingBy(String::hashCode) )); // 结果为：{2={2373=[In]}, 6={1955883606=[Action]}, 7={1611513196=[Lambdas], -155279169=[Java 12]}} List\u0026lt;String\u0026gt; stringList = Arrays.asList(\u0026#34;Java 12\u0026#34;, \u0026#34;Lambdas\u0026#34;, \u0026#34;In\u0026#34;, \u0026#34;Action\u0026#34;); Map\u0026lt;Integer, Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt;\u0026gt; collect = stringList.stream() .collect(groupingBy( String::length, groupingBy(item -\u0026gt; { if (item.length() \u0026lt;= 2) { return \u0026#34;level1\u0026#34;; } else if (item.length() \u0026lt;= 6) { return \u0026#34;level2\u0026#34;; } else { return \u0026#34;level3\u0026#34;; } }) )); // 结果为：{2={level1=[In]}, 6={level2=[Action]}, 7={level3=[Java 12, Lambdas]}} partitioningBy 分区 分区是特殊的分组，它分类依据是true和false，所以返回的结果最多可以分为两组\nList\u0026lt;String\u0026gt; stringList = Arrays.asList(\u0026#34;Java 12\u0026#34;, \u0026#34;Lambdas\u0026#34;, \u0026#34;In\u0026#34;, \u0026#34;Action\u0026#34;); Map\u0026lt;Boolean, List\u0026lt;String\u0026gt;\u0026gt; collect = stringList.stream().collect(partitioningBy(String::isEmpty)); // 结果为：{false=[Java 12, Lambdas, In, Action], true=[]} List\u0026lt;Integer\u0026gt; integerList = Arrays.asList(1, 2, 3, 4, 5); Map\u0026lt;Boolean, List\u0026lt;Integer\u0026gt;\u0026gt; result = integerList.stream().collect(partitioningBy(i -\u0026gt; i \u0026lt; 3)); // 结果为：{false=[3, 4, 5], true=[1, 2]} 本篇文章为学习笔记，感谢以下文章的总结 https://blog.csdn.net/QiuHaoqian/article/details/120942134\n","permalink":"https://lesanouo.github.io/blog/posts/code/165012480002/","summary":"\u003cp\u003e本篇笔记主要记录我在学习Java的stream流中记录的笔记\u003c/p\u003e\n\u003ch2 id=\"stream是什么\"\u003estream是什么\u003c/h2\u003e\n\u003cp\u003e流是从支持数据处理操作的源生成的元素序列，源可以是数组、文件、集合、函数。流不是集合元素，它不是数据结构并不保存数据，它的主要目的在于计算\u003c/p\u003e","title":"Java中Stream学习"},{"content":"在进行华为机试时遇到了报数游戏的编程题（约瑟夫环），但是看了很多网上的解题都非常长，于是经过不断的学习参考，有了下面这个解题方法，也不知道是不是最好的😭\n题目：\n100个人围成一圈，每个人有一个编码，编号从1开始到100.他们从1开始依次报数，报到为M的人自动退出圈圈，然后下一个人接着从1开始报数，直到剩余的人数小于M。请问最后剩余的人在原先的编号为多少？\n例如：输入M=3时，输出为：“58，91”；输入M=4时，输出为： “34，45， 97”\n解答：\nimport java.util.*; public class test { public static void main(String[] args) { Scanner in = new Scanner(System.in); int n = in.nextInt(); List list = new ArrayList\u0026lt;Integer\u0026gt;(100); for (int i = 1; i \u0026lt;= 100; i++) { list.add(i); } int i = 0; while (list.size() \u0026gt;= n) { i = (i + n - 1) % list.size(); list.remove(i); } list.stream().forEach(System.out::println); } } ","permalink":"https://lesanouo.github.io/blog/posts/code/165012480001/","summary":"\u003cp\u003e在进行华为机试时遇到了报数游戏的编程题（约瑟夫环），但是看了很多网上的解题都非常长，于是经过不断的学习参考，有了下面这个解题方法，也不知道是不是最好的😭\u003c/p\u003e","title":"华为机试题：报数游戏"},{"content":"在 web 软件开发中，API接口管理非常重要，也是前后端对接的关键，这里分享一个非常好用且可以私有化部署的接口管理系统Yapi，对那些内网开发的小伙伴们是一个不错的选择。\nYapi简介 Yapi 由 YMFE 开源，旨在为开发、产品、测试人员提供更优雅的接口管理服务，可以帮助开发者轻松创建、发布、维护 API\n权限管理 YApi 成熟的团队管理扁平化项目权限配置满足各类企业的需求\n可视化接口管理 基于 websocket 的多人协作接口编辑功能和类 postman 测试工具，让多人协作成倍提升开发效率\nMock Server 易用的 Mock Server，再也不用担心 mock 数据的生成了\n自动化测试 完善的接口自动化测试,保证数据的正确性\n数据导入 支持导入 swagger, postman, har 数据格式，方便迁移旧项目\n插件机制 强大的插件机制，满足各类业务需求\nYapi使用Docker安装 由于内网开发环境，导致安装各种环境或者系统非常不方便，所以个人比较推荐通过docker来安装\n拉取镜像 docker pull registry.cn-hangzhou.aliyuncs.com/anoy/yapi\n创建挂载目录 mkdir -p /data/yapi/mongodata\n运行专用mongo（也可以放在已有的mongo） docker run -d --name yapimongo --restart always -v /data/yapi/mongodata:/data/db mongo\n初始化 Yapi 数据库索引及管理员账号 docker run -it --rm --link yapimongo:mongo --entrypoint npm --workdir /api/vendors registry.cn-hangzhou.aliyuncs.com/anoy/yapi run install-server\n--rm：在 Docker 容器退出时，默认容器内部的文件系统仍然被保留，以方便调试并保留用户数据。但是，对于 foreground 容器，由于其只是在开发调试过程中短期运行，其用户数据并无保留的必要，因而可以在容器启动时设置 \u0026ndash;rm 选项，这样在容器退出时就能够自动清理容器内部的文件系统\n--entrypoint：类似于 CMD 指令，但其不会被 docker run 的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序。但是, 如果运行 docker run 时使用了 \u0026ndash;entrypoint 选项，将覆盖 ENTRYPOINT 指令指定的程序\n--workdir：指定工作目录。用 WORKDIR 指定的工作目录，会在构建镜像的每一层中都存在\nrun：用于执行后面跟着的命令行命令\n创建Yapi容器并启动 docker run -d --name yapi --restart=always --link yapimongo:mongo --workdir /api/vendors -p 3001:3000 registry.cn-hangzhou.aliyuncs.com/anoy/yapi server/app.js\n--link：用于容器直接的互通\n使用Yapi 访问 http://localhost:3000 登录账号 admin@admin.com，密码 ymfe.org\nYapi配置 # 进入Yapi容器中 docker exec -it yapi /bin/bash # 修改配置文件 vi ../config.json # 修改内容如下 { \u0026#34;port\u0026#34;: \u0026#34;3000\u0026#34;, \u0026#34;adminAccount\u0026#34;: \u0026#34;admin@admin.com\u0026#34;, \u0026#34;closeRegister\u0026#34;:true, # 配置禁用注册，主要是添加这句配置 \u0026#34;db\u0026#34;: { # 配置MongoDB \u0026#34;servername\u0026#34;: \u0026#34;mongo\u0026#34;, \u0026#34;DATABASE\u0026#34;: \u0026#34;yapi\u0026#34;, \u0026#34;port\u0026#34;: 27017 } } # 退出 exit # 重启容器 docker restart yapi 本文参考：\ndocker安装yapi\n具体使用可参考官方教程\n","permalink":"https://lesanouo.github.io/blog/posts/code/164891520001/","summary":"\u003cp\u003e在 web 软件开发中，API接口管理非常重要，也是前后端对接的关键，这里分享一个非常好用且可以私有化部署的接口管理系统Yapi，对那些内网开发的小伙伴们是一个不错的选择。\u003c/p\u003e","title":"分享可私有部署的接口管理系统Yapi"},{"content":"本篇文章记录本人搭建CI\u0026amp;CD实现持续集成和持续部署\n1.使用docker安装gitlab 下载镜像 （使用中文社区版） docker pull twang2218/gitlab-ce-zh\n创建所需目录为后续挂载文件 进入所需目录后，打开PowerShell，通过以下命令进行目录创建\nmkdir -p gitlab/etc 、 mkdir -p gitlab/etc 、 mkdir -p gitlab/etc\n目录结构如下图所示\n启动容器 镜像下载完成后可通过 docker images查看下载结果，再通过镜像启动为容器\ndocker run -d -p 9443:443 -p 9080:80 -p 9022:22 \\ --restart always --name testgitlab \\ -v D:\\testgitlab\\gitlab\\etc:/etc/gitlab \\ -v D:\\testgitlab\\gitlab\\log:/var/log/gitlab \\ -v D:\\testgitlab\\gitlab\\data:/var/opt/gitlab \\ --privileged=true twang2218/gitlab-ce-zh # 执行完成后会返回一串字符串 其中：\n-d：后台执行\n-p：端口映射\n--restart：重启机制\n--name：容器名称\n-v：挂载文件，使得容器内文件在宿主机内有映射\n--privileged：使得容器获取宿主机root权限\n进入容器，修改配置 输入命令 docker exec -it testgitlab bash 即可进入刚刚创建好的容器\n1.修改 gitlab.rb配置的两种方式：1. 进入挂载好的etc目录下找到 gitlab.rb文件进行修改；2. 通过进入容器内进行命令行 vi /etc/gitlab/gitlab.rb 修改\n# 整个gitlab.rb都是注释了的，我们可以按需加入我们的配置\r# 1. gitlab访问地址，可以写域名。如果端口不写的话默认为80端口\reaxternal_url \u0026#39;http://192.168.3.12:9080\u0026#39;\r# 2. ssh主机ip\rgitlab_rails[\u0026#39;gitlab_ssh_host\u0026#39;] = \u0026#39;192.168.3.12\u0026#39;\r# 3. ssh连接端口\rgitlab_rails[\u0026#39;gitlab_shell_ssh_port\u0026#39;] = 9022\r# 4. 防止内存占用过大，限制线程数\runicorn[\u0026#39;worker_processes\u0026#39;] = 2 2.修改 gitlab.yml配置（这一步原本不是必须的，因为 gitlab.rb内配置会覆盖这个，为了防止没有成功覆盖所以我在这里进行配置，当然你也可以选择不修改 gitlab.rb直接修改这里）\n通过命令行 vi /opt/gitlab/embedded/service/gitlab-rails/config/gitlab.yml修改，或者找到挂载文件修改\n修改上图红框配置\n3.让修改后的配置生效，并重启\ngitlab-ctl reconfigure 、 gitlab-ctl restart 、 exit（退出容器命令行）\n或者重启容器 docker restart testgitlab\n访问gitlab 输入http://192.168.3.12:9080打开页面（ip请输入前面设置的），默认账户root，密码需要重新设置至少8位\n2.使用docker安装jenkins 下载镜像 docker pull jenkins/jenkins\n创建所需目录为后续挂载文件 在服务器上先创建一个jenkins工作目录 /var/jenkins_mount，赋予相应权限，稍后我们将jenkins容器目录挂载到这个目录上，这样我们就可以很方便地对容器内的配置文件进行修改。如何后续在容器内修改的话会非常麻烦，由于容器中无vi命令。\nmkdir -p /var/jenkins_mount 、 chmod 777 /var/jenkins_mount\n启动容器 docker run -d -p 10240:8080 -p 10241:50000 -v D:\\testjenkins\\jenkins_mount:/var/jenkins_home -v /etc/localtime:/etc/localtime --name testjenkins jenkins/jenkins # 其中-v /etc/localtime:/etc/localtime让容器使用和服务器同样的时间设置 可以通过 docker ps来查看启动情况\n可以通过 docker logs testjenkins来查看容器日志\n修改配置 进入刚刚挂载的文件，修改 hudson.model.UpdateCenter.xml文件\n将 url 修改为 清华大学官方镜像：https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json ，配置镜像加速\n还需要修改 default.json文件，位置为 cd /var/jenkins_home/updates\n使用sed命令修改 default.json\nlinux下：\nsed -i \u0026#39;s/http:\\/\\/updates.jenkins-ci.org\\/download/https:\\/\\/mirrors.tuna.tsinghua.edu.cn\\/jenkins/g\u0026#39; default.json \u0026amp;\u0026amp; sed -i \u0026#39;s/http:\\/\\/www.google.com/https:\\/\\/www.baidu.com/g\u0026#39; default.json mac下：\nsed -i \u0026#34;\u0026#34; \u0026#39;s/http:\\/\\/updates.jenkins-ci.org\\/download/https:\\/\\/mirrors.tuna.tsinghua.edu.cn\\/jenkins/g\u0026#39; default.json \u0026amp;\u0026amp; sed -i \u0026#34;\u0026#34; \u0026#39;s/http:\\/\\/www.google.com/https:\\/\\/www.baidu.com/g\u0026#39; default.json 重启容器 docker restart testjenkins\n访问jenkins 输入http://localhost:10240打开页面\n选择默认插件安装即可\n3.gitlab + jenkins 为了实现自动持续构建, 不需要人工操作 ( 留人工操作用于处理特殊情况 )，通过gitlab+jenkins实现CI\u0026amp;CD，具体流程如下\n开发提交代码 开发对需要发布的版本打上 Tag 触发 GitLab 的 tag push 事件, 调用 Webhook Webhook 触发 Jenkins 的构建任务 Jenkins 构建完项目可以按版本号上传到仓库、部署、通知相关人员等等 配置gitlab 建一个测试项目 test ，随便 commit 一些内容，比如通过网页添加 README.md 创建账号的 access token ，用于 Jenkins 调用 GitLab 的 API 记下生成的 access token , 后面需要用到！！！且它只会展示一次，请记录好！！！ 配置jenkins 安装环境所需插件 Git Parameter ( 用于参数化构建中动态获取项目分支 ) Generic Webhook Trigger ( 用于解析 Webhook 传过来的参数 ) GitLab ( 用于推送构建结果给 GitLab ) 添加 GitLab 凭据 在系统配置中配置gitlab 创建新的FreeStyle任务 General 勾选 参数化构建过程, 添加 Git Parameter 类型的参数 ref , 这样构建的时候就可以指定分支进行构建\n源码管理 选择 Git , 添加项目地址和授权方式 ( 帐号密码 或者 ssh key ) , 分支填写构建参数 $ref\n构建触发器 选择 Generic Webhook Trigger 方式用于解析 GitLab 推过来的详细参数 ( jsonpath 在线测试 ) 。其他触发方式中: Trigger builds remotely 是 Jenkins 自带的, Build when a change is pushed to GitLab 是 GitLab 插件 提供的, 都属于简单的触发构建, 无法做复杂的处理\nOptional filter 虽然 Generic Webhook Trigger 提供了 Token 参数进行鉴权, 但为了避免不同项目进行混调 ( 比如 A 项目提交代码却触发了 B 项目的构建) , 还要对请求做下过滤。Optional filter 中 Text 填写需要校验的内容 ( 可使用变量 ) , Expression 使用正则表达式对 Text 进行匹配, 匹配成功才允许触发构建\n构建 构建内容按自己实际的项目类型进行调整, 使用 Maven 插件 或 脚本 等等\n构建后操作 构建后操作添加 Publish build status to GitLab 动作, 实现构建结束后通知构建结果给 GitLab\n在GitLab的项目页面中, 添加一个Webhook 添加一个 Webhook ( http://JENKINS_URL/generic-webhook-trigger/invoke?token=\u0026lt;上面 Jenkins 项目配置中的 token\u0026gt; ) , 触发器选择 标签推送事件。因为日常开发中 push 操作比较频繁而且不是每个版本都需要构建, 所以只针对需要构建的版本打上 Tag 就好了\nhttp://172.20.10.7:10240//generic-webhook-trigger/invoke?token=d63ad84eb18cb04d4459ec347a196dce\n创建完使用 test 按钮 先测试下, 可能会出现下面的错误\nRequests to the local network are not allowed 通过下面方法解决\n测试效果 将代码拉下来在本地操作通过IDEA进行操作\n然后使用快捷键 Cmd + Shift + K 调出 Push 窗口 , 把 Tag 推送到 GitLab 中\n回到 GitLab 页面可以看到触发了 Webhook , View details 查看请求详情, Response body 中 triggered 字段值为 true 则表示成功触发了 Jenkins 进行构建\n注意: 每添加一个 Tag 就会触发一次事件, 不管是不是一起 push 的。所以一次 push 多个 Tag 会触发 Jenkins 进行多次构建。不过 Jenkins 已经做了处理, 默认串行执行任务 ( 一个任务结束再执行下一个 ) , 而且在构建前有一个 pending 状态, 此时被多次触发会进行合并, 并取首次触发的参数, 如下图所示:\n关于 Tag 的几点说明 推送 Tag 到远端的时候, 远端已存在 ( 同名 ) 的 Tag 不会被添加到远端 拉取远端的 Tag 时, 本地已存在 ( 同名 ) 的 Tag 不会添加到本地 拉取远端的 Tag 时, 本地不会删除远端已删除的 Tag , 需要同步远端的 Tag 可以先删除本地所有 Tag 再 pull 删除 Tag 也会推送事件, 要做好过滤 ( 上面配置中已使用 commitsId 字段进行过滤 ) 本篇文章产考下列文章：\ndocker安装gitlab\ndocker安装jenkins\ndocker中jenkins插件加速\n整合gitlab+jenkins\n","permalink":"https://lesanouo.github.io/blog/posts/code/164874240001/","summary":"\u003cp\u003e本篇文章记录本人搭建CI\u0026amp;CD实现持续集成和持续部署\u003c/p\u003e\n\u003ch2 id=\"1使用docker安装gitlab\"\u003e1.使用docker安装gitlab\u003c/h2\u003e\n\u003ch3 id=\"下载镜像-使用中文社区版\"\u003e下载镜像 （使用中文社区版）\u003c/h3\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/blog/posts/code/164874240001/images/1.png\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003edocker pull twang2218/gitlab-ce-zh\u003c/code\u003e\u003c/p\u003e\n\u003ch3 id=\"创建所需目录为后续挂载文件\"\u003e创建所需目录为后续挂载文件\u003c/h3\u003e\n\u003cp\u003e进入所需目录后，打开PowerShell，通过以下命令进行目录创建\u003c/p\u003e","title":"记一次搭建GitLab+Jenkins实现CI\u0026CD"},{"content":"默认.NET的Docker镜像是不包含libgdiplus的，所以本文介绍如何通过在原有镜像基础上构建一个满足个人需求的Docker镜像。\nDocker 简介 Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。\nDocker 的应用场景：\nWeb 应用的自动化打包和发布。 自动化测试和持续集成、发布。 在服务型环境中部署和调整数据库或其他的后台应用。 从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。 Docker 的优点：\nDocker 是一个用于开发，交付和运行应用程序的开放平台。Docker 使您能够将应用程序与基础架构分开，从而可以快速交付软件。借助 Docker，您可以与管理应用程序相同的方式来管理基础架构。通过利用 Docker 的方法来快速交付，测试和部署代码，您可以大大减少编写代码和在生产环境中运行代码之间的延迟。\n快速，一致地交付您的应用程序 响应式部署和扩展 在同一硬件上运行更多工作负载 Docker 命令 详细命令可以查看Docker 命令大全\n常用镜像命令 # 1. 查看服务器中 Docker 镜像列表 docker images # 2. 搜索镜像 docker search 镜像名 # 3. 拉取镜像（不加tag(版本号)就默认拉取Docker仓库中该镜像的最新版本latest; 加:tag则是拉取指定版本） docker pull 镜像名 docker pull 镜像名:v1 # 4. 运行镜像 docker run -itd --name=\u0026#34;nginx\u0026#34; --restart=always -p 80:80 -v /data:/data nginx:latest # 5. 删除镜像 docker rmi -f 镜像名/镜像ID # 6. 保存镜像 docker save nginx -o /nginx.tar # 7. 加载镜像 docker load -i 镜像文件位置 常用容器命令 1. 查看正在运行容器列表 docker ps 2. 查看所有容器 docker ps -a 3. 停止容器 docker stop 容器名/容器ID 4. 删除容器 docker rm -f 容器名/容器ID 5. 进入容器方式 docker exec -it 容器名/容器ID /bin/bash exit/ctl+p+q #退出 6. 重启容器 docker restart 容器名/容器ID 7. 启动容器 docker start 容器名/容器ID 8. kill 容器 docker kill 容器名/容器ID 9. 容器文件拷贝 docker cp 容器名/ID:容器内路径 容器外路径 #容器内拷出 docker cp 容器外路径 容器名/ID:容器内路径 #容器外拷入 10. 查看容器日志 docker logs -f --tail=100 容器 #tail查看末尾多少行 默认all 11. 修改存在容器的启动配置 docker update --restart=always 容器 12. 更换容器名 docker rename 容器 容器新名字 13. 通过容器提交镜像！！！### docker commit -a=\u0026#34;提交作者\u0026#34; -m=\u0026#34;提交信息\u0026#34; 容器 提交镜像:tag Docker 运维命令 1. 查看Docker工作目录 sudo docker info | grep \u0026#34;Docker Root Dir\u0026#34; 2. 查看Docker磁盘占用总体情况 du -hs /var/lib/docker/ 3. 查看Docker的磁盘使用具体情况 docker system df 4. 删除无用的容器和镜像 docker rm `docker ps -a | grep Exited | awk \u0026#39;{print $1}\u0026#39;` docker rmi -f `docker images | grep \u0026#39;\u0026lt;none\u0026gt;\u0026#39; | awk \u0026#39;{print $3}\u0026#39;` 5. 清除所有无容器使用的镜像 docker system prune -a 6. 查找大文件 find / -type f -size +100M -print0 | xargs -0 du -h | sort -nr 7. 查找指定Docker使用目录下大于指定大小文件 find / -type f -size +100M -print0 | xargs -0 du -h | sort -nr | grep \u0026#39;/var/lib/docker/overlap2/*\u0026#39; 构建一个带libgdiplus的DotNetCore基础镜像 通过Docker拉取一个.netcore3.1基础镜像：docker pull mcr.microsoft.com/dotnet/aspnet:3.1\n进入容器：docker run -it mcr.microsoft.com/dotnet/aspnet:3.1 /bin/bash 安装libgdiplus：\napt-get update -y apt-get install -y libgdiplus apt-get clean ln -s /usr/lib/libgdiplus.so /usr/lib/gdiplus.dll 提交为新镜像：\ndocker commit -a=\u0026quot;Lesan\u0026quot; -m=\u0026quot;added libgdiplus based on .netcore3.1\u0026quot; 28a66ebccd55 dotnetcore-with-libgdiplus:v3.1\n修改项目Dockerfile基础镜像为刚刚构建的自定义镜像 dotnetcore-with-libgdiplus:v3.1\n借鉴参考以下文章：\nhttps://blog.csdn.net/leilei1366615/article/details/106267225\nhttps://www.runoob.com/docker/docker-command-manual.html\nhttps://blog.csdn.net/u014374975/article/details/115436174\n","permalink":"https://lesanouo.github.io/blog/posts/code/164831040001/","summary":"\u003cp\u003e默认.NET的Docker镜像是不包含libgdiplus的，所以本文介绍如何通过在原有镜像基础上构建一个满足个人需求的Docker镜像。\u003c/p\u003e\n\u003ch2 id=\"docker-简介\"\u003eDocker 简介\u003c/h2\u003e\n\u003cp\u003eDocker 是一个开源的应用容器引擎，基于 \u003cstrong\u003eGo 语言\u003c/strong\u003e 并遵从 Apache2.0 协议开源。Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。\u003c/p\u003e","title":"构建一个带libgdiplus的.NET基础Docker镜像"},{"content":"消息推送是大部分系统都需要做到的功能，在.NET中我分别通过RabbitMQ、MQTT、SignalR实现消息推送功能，本篇文章将通过它们实现简单的推送功能，手把手带大家完成编程。本文环境为 .NET Core 3.1下\nSignalR实现 简介 SignalR是一个开源的库，跨平台；让Web应用与其他应用通讯变得很简单，Web服务端可以实时的将内容推送给对应的客户端，客户端发送的信息也可以实时到其他客户端。\nSignalR提供了一种远程过程调用(RPC)的方式，使得客户端可以调用服务器的方法，同样在服务器端的方法中也能调用客户端的方法。\n示例 Nuget包为： \u0026lt;PackageReference Include=\u0026quot;Microsoft.AspNetCore.SignalR.Core\u0026quot; Version=\u0026quot;1.1.0\u0026quot; /\u0026gt;\n首先我们需要创建一个自己的SignalR Hub using Microsoft.AspNetCore.SignalR; using System.Threading.Tasks; namespace KBEAM.Hubs { public class ChatHub : Hub // 继承自SignalR Hub库 { public async Task SendMessage(string user, string message) { await Clients.All.SendAsync(\u0026#34;ReceiveMessage\u0026#34;, user, message); } public async Task SendMessageToGroup(string group, string message) { await Clients.Group(group).SendAsync(\u0026#34;ReceiveMessageFromGroup\u0026#34;, group, message); } public async Task AddToGroup(string groupName) { await Groups.AddToGroupAsync(Context.ConnectionId, groupName); await Clients.Group(groupName).SendAsync(\u0026#34;ReceiveMessage\u0026#34;, $\u0026#34;{Context.ConnectionId} has joined the group {groupName}.\u0026#34;); } public async Task RemoveFromGroup(string groupName) { await Groups.RemoveFromGroupAsync(Context.ConnectionId, groupName); //await Clients.Group(groupName).SendAsync(\u0026#34;ReceiveMessage\u0026#34;, $\u0026#34;{Context.ConnectionId} has left the group {groupName}.\u0026#34;); } } } 在Startup.cs文件中注册相关服务及管道 // 1.在ConfigureServices函数中添加以下语句，注册相关服务 services.AddSignalR(); // 2.在Configure函数中添加以下语句，配置管道终结点 app.UseEndpoints(endpoints =\u0026gt; { // ... endpoints.MapHub\u0026lt;ChatHub\u0026gt;(\u0026#34;/chatHub\u0026#34;); // ... }); 编写服务端业务，推送消息 // 定义一个上下文 private readonly IHubContext\u0026lt;ChatHub\u0026gt; hubContext; // 通过构造函数注入依赖 public MonitorService(IHubContext\u0026lt;ChatHub\u0026gt; hub) { hubContext = hub; } //在需要的地方调用方法，进行消息推送 await hubContext.Clients.Group(group).SendAsync(\u0026#34;ReceiveMessageFromGroup\u0026#34;,group, \u0026#34;需要发送的消息\u0026#34;); JS客户端程序编写 首先，需要通过npm来安装SignalR封装好的JS文件，npm install @microsoft/signalr\n// 1.首先进行SignalR客户端连接 const signalR = require(\u0026#34;@microsoft/signalr\u0026#34;) let conn = new signalR.HubConnectionBuilder() .withUrl(\u0026#34;http://localhost:8988/chatHub\u0026#34;) .withAutomaticReconnect() .configureLogging(signalR.LogLevel.Error) .build() export default conn import signalR from \u0026#34;@/utils/signalR\u0026#34;; // 2.客户端调用服务端方法（RPC） signalR.invoke(\u0026#34;AddToGroup\u0026#34;, \u0026#34;groupName\u0026#34;).catch(function (err) { // 加入用户组 return console.error(err.toString()); }); signalR.invoke(\u0026#34;RemoveFromGroup\u0026#34;, \u0026#34;大屏\u0026#34;).catch(function (err) { // 移除用户组 return console.error(err.toString()); }); // 3.客户端监听服务器消息 signalR.on(\u0026#34;ReceiveMessageFromGroup\u0026#34;, function (group, message) { console.log(group + \u0026#34; \u0026#34; + message); that.lineChartData = JSON.parse(message); }); RabbitMQ实现 简介 RabbitMQ是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件），由以高性能、健壮以及可伸缩性出名的 Erlang 写成。\n示例 首先您需要在电脑上安装好 Erlang及RabbitMQ服务器，这一步大家就自行搜索解决吧，网上应该有很多的解决方法\nRabbitMQ准备 首先开启Stomp插件\nrabbitmq-plugins enable rabbitmq_management # 开启此插件后有管理界面http://localhost:15672/ rabbitmq-plugins enable rabbitmq_web_stomp rabbitmq-plugins enable rabbitmq_web_stomp_examples 服务端发送消息 所需Nuget包： \u0026lt;PackageReference Include=\u0026quot;RabbitMQ.Client\u0026quot; Version=\u0026quot;6.2.4\u0026quot; /\u0026gt;\n// 建立RabbitMQ连接 private static readonly ConnectionFactory rabbitMqFactory = new ConnectionFactory() { HostName = \u0026#34;localhost\u0026#34;, UserName = \u0026#34;用户名\u0026#34;, Password = \u0026#34;密码\u0026#34;, Port = 5672, VirtualHost = \u0026#34;虚拟主机配置\u0026#34; }; // 发送消息 using (IConnection conn = rabbitMqFactory.CreateConnection()) { using (IModel channel = conn.CreateModel()) { channel.ExchangeDeclare(\u0026#34;monitor\u0026#34;, ExchangeType.Direct, durable: true, autoDelete: false, arguments: null); channel.QueueDeclare(\u0026#34;message\u0026#34;, durable: true, autoDelete: false, exclusive: false, arguments: null); channel.QueueBind(\u0026#34;message\u0026#34;, \u0026#34;monitor\u0026#34;, routingKey: \u0026#34;message\u0026#34;); var props = channel.CreateBasicProperties(); props.Persistent = true; channel.BasicPublish(exchange: \u0026#34;monitor\u0026#34;, routingKey: \u0026#34;message\u0026#34;, basicProperties: props, body: Encoding.UTF8.GetBytes(JsonConvert.SerializeObject(new { expectedData, actualData }))); } } 客户端接受消息 首先需要安装npm库文件，npm install stompjs\nimport Stomp from \u0026#34;stompjs\u0026#34;; // 定义一个RabbitMQ客户端 data() { return { client: Stomp.client(\u0026#34;ws://localhost:15674/ws\u0026#34;), }; }, // 初始化连接操作 created() { this.client.connect( \u0026#34;用户名\u0026#34;, \u0026#34;密码\u0026#34;, this.onConnected, this.onFailed, \u0026#34;虚拟主机名称\u0026#34; ); } methods: { onConnected: function () { //订阅频道 // const topic = localStorage.getItem(\u0026#34;Lesan\u0026#34;); console.log(\u0026#34;连接成功\u0026#34;); this.client.subscribe( \u0026#34;/exchange/monitor/message\u0026#34;, this.responseCallback, this.onFailed ); }, onFailed: function (frame) { console.log(\u0026#34;MQ Failed: \u0026#34; + frame); this.$message.error(\u0026#34;连接失败\u0026#34;); }, // 回传消息 responseCallback: function (frame) { console.log(\u0026#34;MQ msg=\u0026gt;\u0026#34; + frame.body); this.lineChartData = JSON.parse(frame.body); //接收消息处理 }, // 断开相应的连接 close: function () { this.client.disconnect(function () { console.log(\u0026#34;已退出账号\u0026#34;); }); }, }, MQTT实现 简介 MQTT是IBM开发的一个即时通讯协议，该协议支持所有的平台，几乎可以把所有联网的物品和外部连接起来。\n使用发布/订阅消息模式，提供一对多的消息发布，解除应用程序耦合。这一点很类似于XMPP，但是MQTT的信息冗余远小于XMPP。 使用TCP/IP提供网络连接。主流的MQTT是基于TCP连接进行数据推送的，但是同样有基于UDP的版本，叫做MQTT-SN。这两种版本由于基于不同的连接方式，优缺点自然也就各有不同了。 三种消息传输方式QoS： 0代表“至多一次”，消息发布完全依赖底层 TCP/IP 协议。会发生消息丢失或重复。这一级别可用于如下情况，环境传感器数据，丢失一次读记录无所谓，因为不久后还会有第二次发送 1代表“至少一次”，确保消息到达，但消息重复可能会发生 2代表“只有一次”，确保消息到达一次。这一级别可用于如下情况，在计费系统中，消息重复或丢失会导致不正确的结果 示例 服务端开发 所需Nuget包：\u0026lt;PackageReference Include=\u0026quot;MQTTnet.AspNetCore\u0026quot; Version=\u0026quot;3.1.2\u0026quot; /\u0026gt;\n对Program.cs修改：\npublic static IHostBuilder CreateHostBuilder(string[] args) =\u0026gt; Host.CreateDefaultBuilder(args) .ConfigureWebHostDefaults(webBuilder =\u0026gt; { webBuilder.UseKestrel(o =\u0026gt; { o.ListenAnyIP(8988); o.ListenAnyIP(1884, t =\u0026gt; t.UseMqtt()); }); webBuilder.UseStartup\u0026lt;Startup\u0026gt;(); //webBuilder.UseUrls(\u0026#34;http://0.0.0.0:8988\u0026#34;); }); 对Startup.cs修改：\n// 在ConfigureServices函数中添加 services.AddHostedMqttServer(mqttServer =\u0026gt; mqttServer.WithoutDefaultEndpoint().WithConnectionValidator(c =\u0026gt; { if (c.Username != \u0026#34;admin\u0026#34; || c.Password != \u0026#34;123456\u0026#34;) { c.ReasonCode = MqttConnectReasonCode.BadUserNameOrPassword; return; } c.ReasonCode = MqttConnectReasonCode.Success; })) .AddMqttConnectionHandler() .AddConnections(); // 在Configure函数中添加 app.UseEndpoints(endpoints =\u0026gt; { endpoints.MapConnectionHandler\u0026lt;MqttConnectionHandler\u0026gt;( \u0026#34;/mqtt\u0026#34;, httpConnectionDispatcherOptions =\u0026gt; httpConnectionDispatcherOptions.WebSockets.SubProtocolSelector = protocolList =\u0026gt; protocolList.FirstOrDefault() ?? string.Empty); }); app.UseMqttServer(S =\u0026gt; { MqttHelper.Server = S; S.ClientConnectedHandler = new MqttServerClientConnectedHandlerDelegate(OnConnected); S.StartedHandler = new MqttServerStartedHandlerDelegate(OnStarted); }); // 添加事件处理函数 private void OnStarted(EventArgs obj) { RecurringJob.AddOrUpdate\u0026lt;MonitorService\u0026gt;(\u0026#34;MonitorData\u0026#34;, p =\u0026gt; p.UpdateDataAsync(\u0026#34;大屏\u0026#34;), \u0026#34;0/15 * * * * *\u0026#34;); } private void OnConnected(MqttServerClientConnectedEventArgs args) { Console.WriteLine(args.ClientId); } // 消息推送方法 MqttHelper.PublishAsync(\u0026#34;monitor\u0026#34;, JsonConvert.SerializeObject(new { expectedData, actualData })); 添加MqttHelper类：\nusing MQTTnet.Server; using System.Text; namespace Common { public class MqttHelper { public static IMqttServer Server { get; set; } public static void PublishAsync(string topic, byte[] payload) { if (Server != null) { Server.PublishAsync(new MQTTnet.MqttApplicationMessage() { Topic = topic, Payload = payload }, new System.Threading.CancellationToken(false)); } } public static void PublishAsync(string topic, string payload) { if (Server != null) { Server.PublishAsync(new MQTTnet.MqttApplicationMessage() { Topic = topic, Payload = Encoding.UTF8.GetBytes(payload) }, new System.Threading.CancellationToken(false)); ; } } } } 客服端开发 首先需要引入npm包：npm install mqtt\nimport mqtt from \u0026#34;mqtt\u0026#34;; // 连接Mqtt服务器，并订阅消息 mounted() { let that = this; let mqttClient = mqtt.connect(\u0026#34;ws://localhost:8988/mqtt\u0026#34;, { username: \u0026#34;用户名\u0026#34;, password: \u0026#34;密码\u0026#34;, clientId: \u0026#34;客户端ID\u0026#34;, }); mqttClient.on(\u0026#34;connect\u0026#34;, (e) =\u0026gt; { console.log(\u0026#34;connected\u0026#34;, e); mqttClient.subscribe(\u0026#34;monitor\u0026#34;, { qos: 1 }, (err) =\u0026gt; { if (!err) { console.log(\u0026#34;subscribed\u0026#34;); } }); }); mqttClient.on(\u0026#34;message\u0026#34;, (topic, message) =\u0026gt; { console.log(topic, message.toString()); that.lineChartData = JSON.parse(message.toString()); }); }, 其他 Vue前端测试客户端全部代码，通过Vue-cli搭建的项目，修改App.vue即可\n\u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;img alt=\u0026#34;Vue logo\u0026#34; src=\u0026#34;./assets/logo.png\u0026#34; /\u0026gt; \u0026lt;HelloWorld msg=\u0026#34;Welcome to Your Vue.js App\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import HelloWorld from \u0026#34;./components/HelloWorld.vue\u0026#34;; import mqtt from \u0026#34;mqtt\u0026#34;; import Stomp from \u0026#34;stompjs\u0026#34;; export default { name: \u0026#34;App\u0026#34;, components: { HelloWorld, }, data() { return { rabbitClient: Stomp.client(\u0026#34;ws://172.21.30.233:15674/ws\u0026#34;), }; }, created() {}, mounted() { // this.useMqtt(); // this.useRabbitMQ(); this.useSignalR(); }, methods: { useSignalR() { const signalR = require(\u0026#34;@microsoft/signalr\u0026#34;); const conn = new signalR.HubConnectionBuilder() .withUrl(\u0026#34;http://172.21.30.233:8988/chatHub\u0026#34;) .withAutomaticReconnect() .configureLogging(signalR.LogLevel.Error) .build(); conn .start() .then(() =\u0026gt; { console.log(\u0026#34;conneted\u0026#34;); conn.invoke(\u0026#34;AddToGroup\u0026#34;, \u0026#34;大屏\u0026#34;).catch(function (err) { return console.error(err.toString()); }); conn.on(\u0026#34;ReceiveMessageFromGroup\u0026#34;, function (group, message) { console.log(group + \u0026#34; \u0026#34; + message); }); }) .catch((err) =\u0026gt; { return console.error(err.toString()); }); }, useMqtt() { let mqttClient = mqtt.connect(\u0026#34;ws://172.21.30.233:8988/mqtt\u0026#34;, { username: \u0026#34;admin\u0026#34;, password: \u0026#34;123456\u0026#34;, // clientId: \u0026#34;Lesan\u0026#34;, }); mqttClient.on(\u0026#34;connect\u0026#34;, (e) =\u0026gt; { console.log(\u0026#34;connected\u0026#34;, e); mqttClient.subscribe(\u0026#34;monitor\u0026#34;, { qos: 1 }, (err) =\u0026gt; { if (!err) { console.log(\u0026#34;subscribed\u0026#34;); } }); }); mqttClient.on(\u0026#34;message\u0026#34;, (topic, message) =\u0026gt; { console.log(topic, message.toString()); }); }, useRabbitMQ() { // this.rabbitClient.heartbeat.outgoing = 0; // this.rabbitClient.heartbeat.incoming = 0; this.rabbitClient.connect( \u0026#34;KB\u0026#34;, \u0026#34;KB\u0026#34;, this.onConnected, this.onFailed, \u0026#34;kb_monitor\u0026#34; ); }, onConnected: function () { //订阅频道 // const topic = localStorage.getItem(\u0026#34;Lesan\u0026#34;); console.log(\u0026#34;连接成功\u0026#34;); this.rabbitClient.subscribe( \u0026#34;/exchange/monitor/message\u0026#34;, this.responseCallback, this.onFailed ); }, onFailed: function (frame) { console.log(\u0026#34;MQ Failed: \u0026#34; + frame); this.$message.error(\u0026#34;连接失败\u0026#34;); }, // 回传消息 responseCallback: function (frame) { console.log(\u0026#34;MQ msg=\u0026gt;\u0026#34; + frame.body); //接收消息处理 }, // 断开相应的连接 close: function () { this.rabbitClient.disconnect(function () { console.log(\u0026#34;已退出账号\u0026#34;); }); }, }, }; \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; #app { font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px; } \u0026lt;/style\u0026gt; ","permalink":"https://lesanouo.github.io/blog/posts/code/164761920001/","summary":"\u003cp\u003e消息推送是大部分系统都需要做到的功能，在.NET中我分别通过RabbitMQ、MQTT、SignalR实现消息推送功能，本篇文章将通过它们实现简单的推送功能，手把手带大家完成编程。本文环境为 \u003ccode\u003e.NET Core 3.1\u003c/code\u003e下\u003c/p\u003e","title":"在.NET中实现消息推送的三种方式"},{"content":"RabbitMQ简述 MQ全称为Message Queue, 消息队列（MQ）是一种应用程序对应用程序的通信方法。RabbitMQ是一个在AMQP基础上完整的，可复用的企业消息系统。他遵循Mozilla Public License开源协议。AMQP(高级消息队列协议) 是一个异步消息传递所使用的应用层协议规范，作为线路层协议，而不是API（例如JMS），AMQP 客户端能够无视消息的来源任意发送和接受信息。AMQP的原始用途只是为金融界提供一个可以彼此协作的消息协议，而现在的目标则是为通用消息队列架构提供通用构建工具。因此，面向消息的中间件 （MOM）系统，例如发布/订阅队列，没有作为基本元素实现。AMQP当中有四个概念非常重要（一个虚拟主机持有一组交换机、队列和绑定）：\nvirtual host，虚拟主机 exchange，交换机 queue，队列 binding，绑定 消息传递过程 上图为RabbitMQ中一些重要名词的概述，其中包括Connection、Channel、Exchange、Queue、Bind、Routing Key\n上图为消息从生产到消费的整个流程，其中Exchange，与Queue都是可以设置相关属性，队列的持久化，交换器类型制定\n这个过程走分三个部分，1、客户端（生产消息队列），2、RabbitMQ服务端（负责路由规则的绑定与消息的分发），3、客户端（消费消息队列中的消息）\n由图可以看出，一个消息可以走一次网络却被分发到不同的消息队列中，然后被多个的客户端消费，那么这个过程就是RabbitMQ的核心机制，RabbitMQ的路由类型与消费模式\nRabbitMQ中Exchange的类型 类型有4种，direct，fanout，topic，headers。其中headers不常用，本篇不做介绍，其他三种类型，会做详细介绍。\n那么这些类型是什么意思呢？就是Exchange与队列进行绑定后，消息根据exchang的类型，按照不同的绑定规则分发消息到消息队列中，可以是一个消息被分发给多个消息队列，也可以是一个消息分发到一个消息队列。具体请看下文。\n介绍之初还要说下RoutingKey，这是个什么玩意呢？他是exchange与消息队列绑定中的一个标识。有些路由类型会按照标识对应消息队列，有些路由类型忽略routingkey。具体看下文。\nExchange类型direct 根据交换器名称与routingkey来找队列的\nNote:消息从client发出，传送给交换器ChangeA，RoutingKey为routingkey.ZLH,那么不管你发送给Queue1，还是Queue2一个消息都会保存在Queue1，Queue2，Queue3，三个队列中。这就是交换器的direct类型的路由规则。只要找到路由器与routingkey绑定的队列，那么他有多少队列，他就分发给多少队列。\nExchange类型fanout 这个类型忽略Routingkey，他为广播模式\nNote:消息从客户端发出，只要queue与exchange有绑定，那么他不管你的Routingkey是什么他都会将消息分发给所有与该exchang绑定的队列中。\nExchange类型topic 这个类型的路由规则如果你掌握啦，那是相当的好用，与灵活。他是根据RoutingKey的设置，来做匹配的，其中这里还有两个通配符为：\n*，代表任意的一个词。例如topic.zlh.*，他能够匹配到，topic.zlh.one ,topic.zlh.two ,topic.zlh.abc, \u0026hellip;.\n#，代表任意多个词。例如topic.#，他能够匹配到，topic.zlh.one ,topic.zlh.two ,topic.zlh.abc, \u0026hellip;.\nNote：这个图看上去很乱，但是他是根据匹配符做匹配的，这里我建议你自己做下消息队列的具体操作。\n消息队列的消费与消息确认 消息队列的消费 Note:如果一个消息队列中有大量消息等待操作时，我们可以用多个客户端来处理消息，这里的分发机制是采用负载均衡算法中的轮询。第一个消息给A，下一个消息给B，下下一个消息给A，下下下一个消息给B\u0026hellip;\u0026hellip;以此类推\n消息确认 保证消息的安全性，保证此消息被正确处理后才能在服务端的消息队列中删除。那么rabbitmq提供啦ack应答机制，来实现这一功能。\nack应答有两种方式：1、自动应答，2、手动应答\n使用例子 生产者 using RabbitMQ.Client; using System; using System.Text; namespace RabbitMQProduct { internal class Program { static void Main(string[] args) { Console.WriteLine(\u0026#34;Welcome to RabbitMQ Product!\u0026#34;); DirectExchangeSendMsg(); // TopicExchangeSendMsg(); Console.WriteLine(\u0026#34;按任意值，退出程序\u0026#34;); Console.ReadKey(); } /// \u0026lt;summary\u0026gt; /// 连接配置 /// \u0026lt;/summary\u0026gt; private static readonly ConnectionFactory rabbitMqFactory = new ConnectionFactory() { UserName = \u0026#34;guest\u0026#34;, Password = \u0026#34;guest\u0026#34;, Port = 5672, //VirtualHost = \u0026#34;LesanVirtualHost\u0026#34; }; /// \u0026lt;summary\u0026gt; /// 路由名称 /// \u0026lt;/summary\u0026gt; const string ExchangeName = \u0026#34;Lesan.exchange\u0026#34;; //队列名称 const string QueueName = \u0026#34;Lesan.queue\u0026#34;; /// \u0026lt;summary\u0026gt; /// 路由名称 /// \u0026lt;/summary\u0026gt; const string TopExchangeName = \u0026#34;topic.Lesan.exchange\u0026#34;; //队列名称 const string TopQueueName = \u0026#34;topic.Lesan.queue\u0026#34;; /// \u0026lt;summary\u0026gt; /// 单点精确路由模式 /// \u0026lt;/summary\u0026gt; public static void DirectExchangeSendMsg() { using (IConnection conn = rabbitMqFactory.CreateConnection()) { using (IModel channel = conn.CreateModel()) { //设置交换器的类型 channel.ExchangeDeclare(ExchangeName, ExchangeType.Direct, durable: true, autoDelete: false, arguments: null); //声明一个队列，设置队列是否持久化，排他性，与自动删除 channel.QueueDeclare(QueueName, durable: true, autoDelete: false, exclusive: false, arguments: null); //绑定消息队列，交换器，routingkey channel.QueueBind(QueueName, ExchangeName, routingKey: QueueName); var props = channel.CreateBasicProperties(); //队列持久化 props.Persistent = true; string vadata = Console.ReadLine(); while (vadata != \u0026#34;exit\u0026#34;) { var msgBody = Encoding.UTF8.GetBytes(vadata); //发送信息 channel.BasicPublish(exchange: ExchangeName, routingKey: QueueName, basicProperties: props, body: msgBody); Console.WriteLine(string.Format(\u0026#34;***发送时间:{0}，发送完成，输入exit退出消息发送\u0026#34;, DateTime.Now.ToString(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;))); vadata = Console.ReadLine(); } } } } /// \u0026lt;summary\u0026gt; /// topic 模糊匹配模式，符号“#”匹配一个或多个词，符号“*”匹配不多不少一个词。因此“log.#”能够匹配到“log.info.oa”，但是“log.*” 只会匹配到“log.error” /// \u0026lt;/summary\u0026gt; public static void TopicExchangeSendMsg() { using (IConnection conn = rabbitMqFactory.CreateConnection()) { using (IModel channel = conn.CreateModel()) { channel.ExchangeDeclare(TopExchangeName, ExchangeType.Topic, durable: false, autoDelete: false, arguments: null); channel.QueueDeclare(TopQueueName, durable: false, autoDelete: false, exclusive: false, arguments: null); channel.QueueBind(TopQueueName, TopExchangeName, routingKey: TopQueueName); //var props = channel.CreateBasicProperties(); //props.Persistent = true; string vadata = Console.ReadLine(); while (vadata != \u0026#34;exit\u0026#34;) { var msgBody = Encoding.UTF8.GetBytes(vadata); channel.BasicPublish(exchange: TopExchangeName, routingKey: TopQueueName, basicProperties: null, body: msgBody); Console.WriteLine(string.Format(\u0026#34;***发送时间:{0}，发送完成，输入exit退出消息发送\u0026#34;, DateTime.Now.ToString(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;))); vadata = Console.ReadLine(); } } } } } } 消费者 using RabbitMQ.Client; using RabbitMQ.Client.Events; using System; using System.Text; namespace RabbitMQConsumer { internal class Program { static void Main(string[] args) { Console.WriteLine(\u0026#34;Welcome to RabbitMQ Consumer!\u0026#34;); //DirectAcceptExchange(); //DirectAcceptExchangeEvent(); DirectAcceptExchangeTask(); //TopicAcceptExchange(); Console.WriteLine(\u0026#34;按任意值，退出程序\u0026#34;); Console.ReadKey(); } /// \u0026lt;summary\u0026gt; /// 连接配置 /// \u0026lt;/summary\u0026gt; private static readonly ConnectionFactory rabbitMqFactory = new ConnectionFactory() { UserName = \u0026#34;guest\u0026#34;, Password = \u0026#34;guest\u0026#34;, Port = 5672, //VirtualHost = \u0026#34;LesanVirtualHost\u0026#34; }; /// \u0026lt;summary\u0026gt; /// 路由名称 /// \u0026lt;/summary\u0026gt; const string ExchangeName = \u0026#34;Lesan.exchange\u0026#34;; //队列名称 const string QueueName = \u0026#34;Lesan.queue\u0026#34;; /// \u0026lt;summary\u0026gt; /// 路由名称 /// \u0026lt;/summary\u0026gt; const string TopExchangeName = \u0026#34;topic.Lesan.exchange\u0026#34;; //队列名称 const string TopQueueName = \u0026#34;topic.Lesan.queue\u0026#34;; /// \u0026lt;summary\u0026gt; /// 基于时间轮询的，每隔一段时间获取一次 /// \u0026lt;/summary\u0026gt; public static void DirectAcceptExchange() { using (IConnection conn = rabbitMqFactory.CreateConnection()) { using (IModel channel = conn.CreateModel()) { //设置交换器的类型 channel.ExchangeDeclare(ExchangeName, ExchangeType.Direct, durable: true, autoDelete: false, arguments: null); //声明一个队列，设置队列是否持久化，排他性，与自动删除 channel.QueueDeclare(QueueName, durable: true, autoDelete: false, exclusive: false, arguments: null); //绑定消息队列，交换器，routingkey channel.QueueBind(QueueName, ExchangeName, routingKey: QueueName); while (true) { BasicGetResult msgResponse = channel.BasicGet(QueueName, true); if (msgResponse != null) { var msgBody = Encoding.UTF8.GetString(msgResponse.Body.ToArray()); Console.WriteLine(string.Format(\u0026#34;***接收时间:{0}，消息内容：{1}\u0026#34;, DateTime.Now.ToString(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;), msgBody)); } System.Threading.Thread.Sleep(TimeSpan.FromSeconds(1)); } } } } /// \u0026lt;summary\u0026gt; /// 基于事件的，当消息到达时触发事件，获取数据 /// \u0026lt;/summary\u0026gt; public static void DirectAcceptExchangeEvent() { using (IConnection conn = rabbitMqFactory.CreateConnection()) { using (IModel channel = conn.CreateModel()) { //channel.ExchangeDeclare(ExchangeName, \u0026#34;direct\u0026#34;, durable: true, autoDelete: false, arguments: null); channel.QueueDeclare(QueueName, durable: true, autoDelete: false, exclusive: false, arguments: null); //channel.QueueBind(QueueName, ExchangeName, routingKey: QueueName); var consumer = new EventingBasicConsumer(channel); consumer.Received += (model, ea) =\u0026gt; { var msgBody = Encoding.UTF8.GetString(ea.Body.ToArray()); Console.WriteLine(string.Format(\u0026#34;***接收时间:{0}，消息内容：{1}\u0026#34;, DateTime.Now.ToString(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;), msgBody)); }; channel.BasicConsume(QueueName, true, consumer: consumer); Console.WriteLine(\u0026#34;按任意值，退出程序\u0026#34;); Console.ReadKey(); } } } /// \u0026lt;summary\u0026gt; /// 基于事件的，当消息到达时触发事件，获取数据 /// \u0026lt;/summary\u0026gt; public static void DirectAcceptExchangeTask() { using (IConnection conn = rabbitMqFactory.CreateConnection()) { using (IModel channel = conn.CreateModel()) { //channel.ExchangeDeclare(ExchangeName, \u0026#34;direct\u0026#34;, durable: true, autoDelete: false, arguments: null); channel.QueueDeclare(QueueName, durable: true, autoDelete: false, exclusive: false, arguments: null); channel.BasicQos(prefetchSize: 0, prefetchCount: 1, global: false);//告诉broker同一时间只处理一个消息 //channel.QueueBind(QueueName, ExchangeName, routingKey: QueueName); //定义这个队列的消费者 var consumer = new EventingBasicConsumer(channel); consumer.Received += (model, ea) =\u0026gt; { var msgBody = Encoding.UTF8.GetString(ea.Body.ToArray()); Console.WriteLine(string.Format(\u0026#34;***接收时间:{0}，消息内容：{1}\u0026#34;, DateTime.Now.ToString(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;), msgBody)); int dots = msgBody.Split(\u0026#39;.\u0026#39;).Length - 1; System.Threading.Thread.Sleep(dots * 1000); //处理完成，告诉Broker可以服务端可以删除消息，分配新的消息过来 channel.BasicAck(deliveryTag: ea.DeliveryTag, multiple: false); }; //noAck设置false,告诉broker，发送消息之后，消息暂时不要删除，等消费者处理完成再说 //false为手动应答，true为自动应答 channel.BasicConsume(QueueName, false, consumer: consumer); Console.WriteLine(\u0026#34;按任意值，退出程序\u0026#34;); Console.ReadKey(); } } } /// \u0026lt;summary\u0026gt; /// topic 模糊匹配模式，符号“#”匹配一个或多个词，符号“*”匹配不多不少一个词。因此“log.#”能够匹配到“log.info.oa”，但是“log.*” 只会匹配到“log.error” /// \u0026lt;/summary\u0026gt; public static void TopicAcceptExchange() { using (IConnection conn = rabbitMqFactory.CreateConnection()) { using (IModel channel = conn.CreateModel()) { channel.ExchangeDeclare(TopExchangeName, ExchangeType.Topic, durable: false, autoDelete: false, arguments: null); channel.QueueDeclare(TopQueueName, durable: false, autoDelete: false, exclusive: false, arguments: null); channel.BasicQos(prefetchSize: 0, prefetchCount: 1, global: false); channel.QueueBind(TopQueueName, TopExchangeName, routingKey: TopQueueName); var consumer = new EventingBasicConsumer(channel); consumer.Received += (model, ea) =\u0026gt; { var msgBody = Encoding.UTF8.GetString(ea.Body.ToArray()); Console.WriteLine(string.Format(\u0026#34;***接收时间:{0}，消息内容：{1}\u0026#34;, DateTime.Now.ToString(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;), msgBody)); int dots = msgBody.Split(\u0026#39;.\u0026#39;).Length - 1; System.Threading.Thread.Sleep(dots * 1000); Console.WriteLine(\u0026#34; [x] Done\u0026#34;); channel.BasicAck(deliveryTag: ea.DeliveryTag, multiple: false); }; channel.BasicConsume(TopQueueName, false, consumer: consumer); Console.WriteLine(\u0026#34;按任意值，退出程序\u0026#34;); Console.ReadKey(); } } } } } 引用 以上笔记摘录自网络\nhttps://www.cnblogs.com/knowledgesea/p/5296008.html https://www.cnblogs.com/personblog/p/10681741.html\n","permalink":"https://lesanouo.github.io/blog/posts/code/164502720001/","summary":"\u003ch2 id=\"rabbitmq简述\"\u003eRabbitMQ简述\u003c/h2\u003e\n\u003cp\u003eMQ全称为Message Queue, 消息队列（MQ）是一种应用程序对应用程序的通信方法。RabbitMQ是一个在AMQP基础上完整的，可复用的企业消息系统。他遵循Mozilla Public License开源协议。AMQP(高级消息队列协议) 是一个异步消息传递所使用的应用层协议规范，作为线路层协议，而不是API（例如JMS），AMQP 客户端能够无视消息的来源任意发送和接受信息。AMQP的原始用途只是为金融界提供一个可以彼此协作的消息协议，而现在的目标则是为通用消息队列架构提供通用构建工具。因此，面向消息的中间件 （MOM）系统，例如发布/订阅队列，没有作为基本元素实现。AMQP当中有四个概念非常重要（一个虚拟主机持有一组交换机、队列和绑定）：\u003c/p\u003e","title":"RabbitMQ笔记"},{"content":"Linux关机,重启 # 关机 shutdown -h now # 重启 shutdown -r now 查看系统,CPU信息 # 查看系统内核信息 uname -a # 查看系统内核版本 cat /proc/version # 查看当前用户环境变量 env cat /proc/cpuinfo # 查看有几个逻辑cpu, 包括cpu型号 cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c # 查看有几颗cpu,每颗分别是几核 cat /proc/cpuinfo | grep physical | uniq -c # 查看当前CPU运行在32bit还是64bit模式下, 如果是运行在32bit下也不代表CPU不支持64bit getconf LONG_BIT # 结果大于0, 说明支持64bit计算. lm指long mode, 支持lm则是64bit cat /proc/cpuinfo | grep flags | grep \u0026#39; lm \u0026#39; | wc -l 建立软连接 ln -s /usr/local/jdk1.8/ jdk rpm相关 # 查看是否通过rpm安装了该软件 rpm -qa | grep 软件名 sshkey # 创建sshkey ssh-keygen -t rsa -C your_email@example.com #id_rsa.pub 的内容拷贝到要控制的服务器的 home/username/.ssh/authorized_keys 中,如果没有则新建(.ssh权限为700, authorized_keys权限为600) 命令重命名 # 在各个用户的.bash_profile中添加重命名配置 alias ll=\u0026#39;ls -alF\u0026#39; 同步服务器时间 sudo ntpdate -u ntp.api.bz 后台运行 # 后台运行,并且有nohup.out输出 nohup xxx \u0026amp; # 后台运行, 不输出任何日志 nohup xxx \u0026gt; /dev/null \u0026amp; # 后台运行, 并将错误信息做标准输出到日志中 nohup xxx \u0026gt;out.log 2\u0026gt;\u0026amp;1 \u0026amp; 强制活动用户退出 # 命令来完成强制活动用户退出.其中TTY表示终端名称 pkill -kill -t [TTY] 查看命令路径 which \u0026lt;命令\u0026gt; 查看进程所有打开最大fd数 ulimit -n 配置dns vim /etc/resolv.conf nslookup,查看域名路由表 nslookup google.com last,最近登录信息列表 # 最近登录的5个账号 last -n 5 设置固定ip ifconfig em1 192.168.5.177 netmask 255.255.255.0 查看进程内加载的环境变量 # 也可以去 cd /proc 目录下, 查看进程内存中加载的东西 ps eww -p XXXXX(进程号) 查看进程树找到服务器进程 ps auwxf 查看进程启动路径 cd /proc/xxx(进程号) ls -all # cwd对应的是启动路径 添加用户,配置sudo权限 # 新增用户 useradd 用户名 passwd 用户名 #增加sudo权限 vim /etc/sudoers # 修改文件里面的 # root ALL=(ALL) ALL # 用户名 ALL=(ALL) ALL 强制关闭进程名包含xxx的所有进程 ps aux|grep xxx | grep -v grep | awk \u0026#39;{print $2}\u0026#39; | xargs kill -9 vim操作 #normal模式下 g表示全局, x表示查找的内容, y表示替换后的内容 :%s/x/y/g #normal模式下 0 # 光标移到行首(数字0) $ # 光标移至行尾 shift + g # 跳到文件最后 gg # 跳到文件头 # 显示行号 :set nu # 去除行号 :set nonu # 检索 /xxx(检索内容) # 从头检索, 按n查找下一个 ?xxx(检索内容) # 从尾部检索 打开只读文件,修改后需要保存时(不用切换用户即可保存的方式) # 在normal模式下 :w !sudo tee % 查看磁盘, 文件目录基本信息 # 查看磁盘挂载情况 mount # 查看磁盘分区信息 df # 查看目录及子目录大小 du -H -h # 查看当前目录下各个文件, 文件夹占了多少空间, 不会递归 du -sh * wc命令 # 查看文件里有多少行 wc -l filename # 看文件里有多少个word wc -w filename # 文件里最长的那一行是多少个字 wc -L filename # 统计字节数 wc -c 压缩命令 tar czvf xxx.tar 压缩目录 zip -r xxx.zip 压缩目录 解压缩命令 tar zxvf xxx.tar # 解压到指定文件夹 tar zxvf xxx.tar -C /xxx/yyy/ unzip xxx.zip 变更文件所属用户, 用户组 chown eagleye.eagleye xxx.log cp, scp, mkdir #复制 cp xxx.log # 复制并强制覆盖同名文件 cp -f xxx.log # 复制文件夹 cp -r xxx(源文件夹) yyy(目标文件夹) # 远程复制 scp -P ssh端口 username@10.10.10.101:/home/username/xxx /home/xxx # 级联创建目录 mkdir -p /xxx/yyy/zzz # 批量创建文件夹, 会在test,main下都创建java, resources文件夹 mkdir -p src/{test,main}/{java,resources} 比较两个文件 diff -u 1.txt 2.txt 日志输出的字节数,可以用作性能测试 # 如果做性能测试, 可以每执行一次, 往日志里面输出 “.” , 这样日志中的字节数就是实际的性能测试运行的次数, 还可以看见实时速率. tail -f xxx.log | pv -bt 查看, 去除特殊字符 # 查看特殊字符 cat -v xxx.sh # 去除特殊字符 sed -i \u0026#39;s/^M//g’ env.sh 去除文件的特殊字符, 比如^M: 需要这样输入: ctrl+v+enter 处理因系统原因引起的文件中特殊字符的问题 # 可以转换为该系统下的文件格式 cat file.sh \u0026gt; file.sh_bak # 先将file.sh中文件内容复制下来然后运行, 然后粘贴内容, 最后ctrl + d 保存退出 cat \u0026gt; file1.sh # 在vim中通过如下设置文件编码和文件格式 :set fileencodings=utf-8 ，然后 w （存盘）一下即可转化为 utf8 格式， :set fileformat=unix # 在mac下使用dos2unix进行文件格式化 find . -name \u0026#34;*.sh\u0026#34; | xargs dos2unix tee, 重定向的同时输出到屏幕 awk ‘{print $0}’ xxx.log | tee test.log grep # 反向匹配, 查找不包含xxx的内容 grep -v xxx # 排除所有空行 grep -v \u0026#39;^/pre\u0026gt;\u0026#39; # 返回结果 2,则说明第二行是空行 grep -n “^$” 111.txt # 查询以abc开头的行 grep -n “^abc” 111.txt # 同时列出该词语出现在文章的第几行 grep \u0026#39;xxx\u0026#39; -n xxx.log # 计算一下该字串出现的次数 grep \u0026#39;xxx\u0026#39; -c xxx.log # 比对的时候，不计较大小写的不同 grep \u0026#39;xxx\u0026#39; -i xxx.log awk # 以\u0026#39;:\u0026#39; 为分隔符,如果第五域有user则输出该行 awk -F \u0026#39;:\u0026#39; \u0026#39;{if ($5 ~ /user/) print $0}\u0026#39; /etc/passwd # 统计单个文件中某个字符（串）(中文无效)出现的次数 awk -v RS=\u0026#39;character\u0026#39; \u0026#39;END {print --NR}\u0026#39; xxx.txt find # 在目录下找后缀是.mysql的文件 find /home/eagleye -name \u0026#39;*.mysql\u0026#39; -print # 会从 /usr 目录开始往下找，找最近3天之内存取过的文件。 find /usr -atime 3 –print # 会从 /usr 目录开始往下找，找最近5天之内修改过的文件。 find /usr -ctime 5 –print # 会从 /doc 目录开始往下找，找jacky 的、文件名开头是 j的文件。 find /doc -user jacky -name \u0026#39;j*\u0026#39; –print # 会从 /doc 目录开始往下找，找寻文件名是 ja 开头或者 ma开头的文件。 find /doc \\( -name \u0026#39;ja*\u0026#39; -o- -name \u0026#39;ma*\u0026#39; \\) –print # 会从 /doc 目录开始往下找，找到凡是文件名结尾为 bak的文件，把它删除掉。-exec 选项是执行的意思，rm 是删除命令，{ } 表示文件名，“\\;”是规定的命令结尾。 find /doc -name \u0026#39;*bak\u0026#39; -exec rm {} \\; 查看什么进程使用了该端口 lsof -i:port 获取本机ip地址 /sbin/ifconfig -a|grep inet|grep -v 127.0.0.1|grep -v inet6|awk \u0026#39;{print $2}\u0026#39;|tr -d \u0026#34;addr:\u0026#34; iptables # 查看iptables状态 service iptables status # 要封停一个ip iptables -I INPUT -s ***.***.***.*** -j DROP # 要解封一个IP，使用下面这条命令： iptables -D INPUT -s ***.***.***.*** -j DROP 备注: 参数-I是表示Insert（添加），-D表示Delete（删除）。后面跟的是规则，INPUT表示入站，***.***.***.***表示要封停的IP，DROP表示放弃连接。 #开启9090端口的访问 /sbin/iptables -I INPUT -p tcp --dport 9090 -j ACCEPT # 防火墙开启、关闭、重启 /etc/init.d/iptables status /etc/init.d/iptables start /etc/init.d/iptables stop /etc/init.d/iptables restart nc命令, tcp调试利器 #给某一个endpoint发送TCP请求,就将data的内容发送到对端 nc 192.168.0.11 8000 \u0026lt; data.txt #nc可以当做服务器，监听某个端口号,把某一次请求的内容存储到received_data里 nc -l 8000 \u0026gt; received_data #上边只监听一次，如果多次可以加上-k参数 nc -lk 8000 tcpdump # dump出本机12301端口的tcp包 tcpdump -i em1 tcp port 12301 -s 1500 -w abc.pcap 跟踪网络路由路径 # traceroute默认使用udp方式, 如果是-I则改成icmp方式 traceroute -I www.163.com # 从ttl第3跳跟踪 traceroute -M 3 www.163.com # 加上端口跟踪 traceroute -p 8080 192.168.10.11 ss # 显示本地打开的所有端口 ss -l # 显示每个进程具体打开的socket ss -pl # 显示所有tcp socket ss -t -a # 显示所有的UDP Socekt ss -u -a # 显示所有已建立的SMTP连接 ss -o state established \u0026#39;( dport = :smtp or sport = :smtp )\u0026#39; # 显示所有已建立的HTTP连接 ss -o state established \u0026#39;( dport = :http or sport = :http )\u0026#39; 找出所有连接X服务器的进程 ss -x src /tmp/.X11-unix/* 列出当前socket统计信息 ss -s 解释：netstat是遍历/proc下面每个PID目录，ss直接读/proc/net下面的统计信息。所以ss执行的时候消耗资源以及消耗的时间都比netstat少很多 netstat # 输出每个ip的连接数，以及总的各个状态的连接数 netstat -n | awk \u0026#39;/^tcp/ {n=split($(NF-1),array,\u0026#34;:\u0026#34;);if(n\u0026lt;=2)++S[array[(1)]];else++S[array[(4)]];++s[$NF];++N} END {for(a in S){printf(\u0026#34;%-20s %s\\n\u0026#34;, a, S[a]);++I}printf(\u0026#34;%-20s %s\\n\u0026#34;,\u0026#34;TOTAL_IP\u0026#34;,I);for(a in s) printf(\u0026#34;%-20s %s\\n\u0026#34;,a, s[a]);printf(\u0026#34;%-20s %s\\n\u0026#34;,\u0026#34;TOTAL_LINK\u0026#34;,N);}\u0026#39; # 统计所有连接状态, # CLOSED：无连接是活动的或正在进行 # LISTEN：服务器在等待进入呼叫 # SYN_RECV：一个连接请求已经到达，等待确认 # SYN_SENT：应用已经开始，打开一个连接 # ESTABLISHED：正常数据传输状态 # FIN_WAIT1：应用说它已经完成 # FIN_WAIT2：另一边已同意释放 # ITMED_WAIT：等待所有分组死掉 # CLOSING：两边同时尝试关闭 # TIME_WAIT：主动关闭连接一端还没有等到另一端反馈期间的状态 # LAST_ACK：等待所有分组死掉 netstat -n | awk \u0026#39;/^tcp/ {++state[$NF]} END {for(key in state) print key,\u0026#34;\\t\u0026#34;,state[key]}\u0026#39; # 查找较多time_wait连接 netstat -n|grep TIME_WAIT|awk \u0026#39;{print $5}\u0026#39;|sort|uniq -c|sort -rn|head -n20 top dmesg,查看系统日志 iostat,磁盘IO情况监控 iostat -xz 1 # r/s, w/s, rkB/s, wkB/s：分别表示每秒读写次数和每秒读写数据量（千字节）。读写量过大，可能会引起性能问题。 # await：IO操作的平均等待时间，单位是毫秒。这是应用程序在和磁盘交互时，需要消耗的时间，包括IO等待和实际操作的耗时。如果这个数值过大，可能是硬件设备遇到了瓶颈或者出现故障。 # avgqu-sz：向设备发出的请求平均数量。如果这个数值大于1，可能是硬件设备已经饱和（部分前端硬件设备支持并行写入）。 # %util：设备利用率。这个数值表示设备的繁忙程度，经验值是如果超过60，可能会影响IO性能（可以参照IO操作平均等待时间）。如果到达100%，说明硬件设备已经饱和。 # 如果显示的是逻辑设备的数据，那么设备利用率不代表后端实际的硬件设备已经饱和。值得注意的是，即使IO性能不理想，也不一定意味这应用程序性能会不好，可以利用诸如预读取、写缓存等策略提升应用性能。 free,内存使用情况 free -m eg: total used free shared buffers cached Mem: 1002 769 232 0 62 421 -/+ buffers/cache: 286 715 Swap: 1153 0 1153 第一部分Mem行: total 内存总数: 1002M used 已经使用的内存数: 769M free 空闲的内存数: 232M shared 当前已经废弃不用,总是0 buffers Buffer 缓存内存数: 62M cached Page 缓存内存数:421M 关系：total(1002M) = used(769M) + free(232M) 第二部分(-/+ buffers/cache): (-buffers/cache) used内存数：286M (指的第一部分Mem行中的used – buffers – cached) (+buffers/cache) free内存数: 715M (指的第一部分Mem行中的free + buffers + cached) 可见-buffers/cache反映的是被程序实实在在吃掉的内存,而+buffers/cache反映的是可以挪用的内存总数. 第三部分是指交换分区 sar,查看网络吞吐状态 # sar命令在这里可以查看网络设备的吞吐率。在排查性能问题时，可以通过网络设备的吞吐量，判断网络设备是否已经饱和 sar -n DEV 1 # sar命令在这里用于查看TCP连接状态，其中包括： # active/s：每秒本地发起的TCP连接数，既通过connect调用创建的TCP连接； # passive/s：每秒远程发起的TCP连接数，即通过accept调用创建的TCP连接； # retrans/s：每秒TCP重传数量； # TCP连接数可以用来判断性能问题是否由于建立了过多的连接，进一步可以判断是主动发起的连接，还是被动接受的连接。TCP重传可能是因为网络环境恶劣，或者服务器压力过大导致丢包 sar -n TCP,ETCP 1 vmstat, 给定时间监控CPU使用率, 内存使用, 虚拟内存交互, IO读写 # 2表示每2秒采集一次状态信息, 1表示只采集一次(忽略既是一直采集) vmstat 2 1 ","permalink":"https://lesanouo.github.io/blog/posts/snippet/linux/","summary":"\u003ch2 id=\"linux关机重启\"\u003eLinux关机,重启\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 关机\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eshutdown -h now\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 重启\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eshutdown -r now\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"查看系统cpu信息\"\u003e查看系统,CPU信息\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 查看系统内核信息\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003euname -a\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 查看系统内核版本\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ecat /proc/version\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 查看当前用户环境变量\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eenv\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ecat /proc/cpuinfo\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 查看有几个逻辑cpu, 包括cpu型号\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ecat /proc/cpuinfo \u003cspan class=\"p\"\u003e|\u003c/span\u003e grep name \u003cspan class=\"p\"\u003e|\u003c/span\u003e cut -f2 -d: \u003cspan class=\"p\"\u003e|\u003c/span\u003e uniq -c\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 查看有几颗cpu,每颗分别是几核\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ecat /proc/cpuinfo \u003cspan class=\"p\"\u003e|\u003c/span\u003e grep physical \u003cspan class=\"p\"\u003e|\u003c/span\u003e uniq -c\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 查看当前CPU运行在32bit还是64bit模式下, 如果是运行在32bit下也不代表CPU不支持64bit\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egetconf LONG_BIT\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 结果大于0, 说明支持64bit计算. lm指long mode, 支持lm则是64bit\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ecat /proc/cpuinfo \u003cspan class=\"p\"\u003e|\u003c/span\u003e grep flags \u003cspan class=\"p\"\u003e|\u003c/span\u003e grep \u003cspan class=\"s1\"\u003e\u0026#39; lm \u0026#39;\u003c/span\u003e \u003cspan class=\"p\"\u003e|\u003c/span\u003e wc -l\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"建立软连接\"\u003e建立软连接\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eln -s /usr/local/jdk1.8/ jdk\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"rpm相关\"\u003erpm相关\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 查看是否通过rpm安装了该软件\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003erpm -qa \u003cspan class=\"p\"\u003e|\u003c/span\u003e grep 软件名\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"sshkey\"\u003esshkey\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 创建sshkey\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003essh-keygen -t rsa -C your_email@example.com\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e#id_rsa.pub 的内容拷贝到要控制的服务器的 home/username/.ssh/authorized_keys 中,如果没有则新建(.ssh权限为700, authorized_keys权限为600)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"命令重命名\"\u003e命令重命名\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 在各个用户的.bash_profile中添加重命名配置\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003ealias\u003c/span\u003e \u003cspan class=\"nv\"\u003ell\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;ls -alF\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"同步服务器时间\"\u003e同步服务器时间\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo ntpdate -u ntp.api.bz\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"后台运行\"\u003e后台运行\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 后台运行,并且有nohup.out输出\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003enohup xxx \u003cspan class=\"p\"\u003e\u0026amp;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 后台运行, 不输出任何日志\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003enohup xxx \u0026gt; /dev/null \u003cspan class=\"p\"\u003e\u0026amp;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 后台运行, 并将错误信息做标准输出到日志中\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003enohup xxx \u0026gt;out.log 2\u0026gt;\u003cspan class=\"p\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"m\"\u003e1\u003c/span\u003e \u003cspan class=\"p\"\u003e\u0026amp;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"强制活动用户退出\"\u003e强制活动用户退出\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 命令来完成强制活动用户退出.其中TTY表示终端名称\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003epkill -kill -t \u003cspan class=\"o\"\u003e[\u003c/span\u003eTTY\u003cspan class=\"o\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"查看命令路径\"\u003e查看命令路径\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ewhich \u0026lt;命令\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"查看进程所有打开最大fd数\"\u003e查看进程所有打开最大fd数\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eulimit\u003c/span\u003e -n\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"配置dns\"\u003e配置dns\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003evim /etc/resolv.conf\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"nslookup查看域名路由表\"\u003enslookup,查看域名路由表\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003enslookup google.com\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"last最近登录信息列表\"\u003elast,最近登录信息列表\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 最近登录的5个账号\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003elast -n \u003cspan class=\"m\"\u003e5\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"设置固定ip\"\u003e设置固定ip\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eifconfig em1  192.168.5.177 netmask 255.255.255.0\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"查看进程内加载的环境变量\"\u003e查看进程内加载的环境变量\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 也可以去 cd /proc 目录下, 查看进程内存中加载的东西\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eps eww -p  XXXXX\u003cspan class=\"o\"\u003e(\u003c/span\u003e进程号\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"查看进程树找到服务器进程\"\u003e查看进程树找到服务器进程\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eps auwxf\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"查看进程启动路径\"\u003e查看进程启动路径\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003ecd\u003c/span\u003e /proc/xxx\u003cspan class=\"o\"\u003e(\u003c/span\u003e进程号\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003els -all\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# cwd对应的是启动路径\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"添加用户配置sudo权限\"\u003e添加用户,配置sudo权限\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 新增用户\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003euseradd 用户名\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003epasswd 用户名\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e#增加sudo权限\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003evim /etc/sudoers\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 修改文件里面的\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# root    ALL=(ALL)       ALL\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 用户名 ALL=(ALL)       ALL\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"强制关闭进程名包含xxx的所有进程\"\u003e强制关闭进程名包含xxx的所有进程\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eps aux\u003cspan class=\"p\"\u003e|\u003c/span\u003egrep xxx \u003cspan class=\"p\"\u003e|\u003c/span\u003e grep -v grep \u003cspan class=\"p\"\u003e|\u003c/span\u003e awk \u003cspan class=\"s1\"\u003e\u0026#39;{print $2}\u0026#39;\u003c/span\u003e \u003cspan class=\"p\"\u003e|\u003c/span\u003e xargs \u003cspan class=\"nb\"\u003ekill\u003c/span\u003e -9\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"vim操作\"\u003evim操作\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e#normal模式下 g表示全局, x表示查找的内容, y表示替换后的内容\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e:%s/x/y/g\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e#normal模式下\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"m\"\u003e0\u003c/span\u003e  \u003cspan class=\"c1\"\u003e# 光标移到行首(数字0)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e$  \u003cspan class=\"c1\"\u003e# 光标移至行尾\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eshift\u003c/span\u003e + g \u003cspan class=\"c1\"\u003e# 跳到文件最后\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egg \u003cspan class=\"c1\"\u003e# 跳到文件头\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 显示行号\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e:set nu\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 去除行号\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e:set nonu\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 检索\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e/xxx\u003cspan class=\"o\"\u003e(\u003c/span\u003e检索内容\u003cspan class=\"o\"\u003e)\u003c/span\u003e  \u003cspan class=\"c1\"\u003e# 从头检索, 按n查找下一个\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e?xxx\u003cspan class=\"o\"\u003e(\u003c/span\u003e检索内容\u003cspan class=\"o\"\u003e)\u003c/span\u003e  \u003cspan class=\"c1\"\u003e# 从尾部检索\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"打开只读文件修改后需要保存时不用切换用户即可保存的方式\"\u003e打开只读文件,修改后需要保存时(不用切换用户即可保存的方式)\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 在normal模式下\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e:w !sudo tee %\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"查看磁盘-文件目录基本信息\"\u003e查看磁盘, 文件目录基本信息\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 查看磁盘挂载情况\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003emount\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 查看磁盘分区信息\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003edf\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 查看目录及子目录大小\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003edu -H -h\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 查看当前目录下各个文件, 文件夹占了多少空间, 不会递归\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003edu -sh *\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"wc命令\"\u003ewc命令\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 查看文件里有多少行\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ewc -l filename\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 看文件里有多少个word\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ewc -w filename\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 文件里最长的那一行是多少个字\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ewc -L filename\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 统计字节数\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ewc -c\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"压缩命令\"\u003e压缩命令\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003etar czvf xxx.tar 压缩目录\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ezip -r xxx.zip 压缩目录\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"解压缩命令\"\u003e解压缩命令\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003etar zxvf xxx.tar\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 解压到指定文件夹\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003etar zxvf xxx.tar -C /xxx/yyy/\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eunzip xxx.zip\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"变更文件所属用户-用户组\"\u003e变更文件所属用户, 用户组\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003echown eagleye.eagleye xxx.log\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"cp-scp-mkdir\"\u003ecp, scp, mkdir\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e#复制\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ecp xxx.log\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 复制并强制覆盖同名文件\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ecp -f xxx.log\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 复制文件夹\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ecp -r xxx\u003cspan class=\"o\"\u003e(\u003c/span\u003e源文件夹\u003cspan class=\"o\"\u003e)\u003c/span\u003e yyy\u003cspan class=\"o\"\u003e(\u003c/span\u003e目标文件夹\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 远程复制\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003escp -P ssh端口 username@10.10.10.101:/home/username/xxx /home/xxx\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 级联创建目录\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003emkdir -p /xxx/yyy/zzz\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 批量创建文件夹, 会在test,main下都创建java, resources文件夹\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003emkdir -p src/\u003cspan class=\"o\"\u003e{\u003c/span\u003etest,main\u003cspan class=\"o\"\u003e}\u003c/span\u003e/\u003cspan class=\"o\"\u003e{\u003c/span\u003ejava,resources\u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"比较两个文件\"\u003e比较两个文件\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ediff -u 1.txt 2.txt\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"日志输出的字节数可以用作性能测试\"\u003e日志输出的字节数,可以用作性能测试\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 如果做性能测试, 可以每执行一次, 往日志里面输出 “.” , 这样日志中的字节数就是实际的性能测试运行的次数, 还可以看见实时速率.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003etail -f xxx.log \u003cspan class=\"p\"\u003e|\u003c/span\u003e pv -bt\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"查看-去除特殊字符\"\u003e查看, 去除特殊字符\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 查看特殊字符\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ecat -v xxx.sh\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 去除特殊字符\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esed -i \u003cspan class=\"err\"\u003e\u0026#39;\u003c/span\u003es/^M//g’ env.sh  去除文件的特殊字符, 比如^M:  需要这样输入: ctrl+v+enter\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"处理因系统原因引起的文件中特殊字符的问题\"\u003e处理因系统原因引起的文件中特殊字符的问题\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 可以转换为该系统下的文件格式\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ecat file.sh \u0026gt; file.sh_bak\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 先将file.sh中文件内容复制下来然后运行, 然后粘贴内容, 最后ctrl + d 保存退出\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ecat \u0026gt; file1.sh\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 在vim中通过如下设置文件编码和文件格式\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e:set \u003cspan class=\"nv\"\u003efileencodings\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003eutf-8 ，然后 w （存盘）一下即可转化为 utf8 格式，\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e:set \u003cspan class=\"nv\"\u003efileformat\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003eunix\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 在mac下使用dos2unix进行文件格式化\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003efind . -name \u003cspan class=\"s2\"\u003e\u0026#34;*.sh\u0026#34;\u003c/span\u003e \u003cspan class=\"p\"\u003e|\u003c/span\u003e xargs dos2unix\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"tee-重定向的同时输出到屏幕\"\u003etee, 重定向的同时输出到屏幕\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eawk ‘\u003cspan class=\"o\"\u003e{\u003c/span\u003eprint \u003cspan class=\"nv\"\u003e$0\u003c/span\u003e\u003cspan class=\"o\"\u003e}\u003c/span\u003e’ xxx.log \u003cspan class=\"p\"\u003e|\u003c/span\u003e tee test.log\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"grep\"\u003egrep\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 反向匹配, 查找不包含xxx的内容\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egrep -v xxx\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 排除所有空行\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egrep -v \u003cspan class=\"s1\"\u003e\u0026#39;^/pre\u0026gt;\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 返回结果 2,则说明第二行是空行\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egrep -n “^$” 111.txt\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 查询以abc开头的行\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egrep -n “^abc” 111.txt\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 同时列出该词语出现在文章的第几行\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egrep \u003cspan class=\"s1\"\u003e\u0026#39;xxx\u0026#39;\u003c/span\u003e -n xxx.log\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 计算一下该字串出现的次数\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egrep \u003cspan class=\"s1\"\u003e\u0026#39;xxx\u0026#39;\u003c/span\u003e -c xxx.log\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 比对的时候，不计较大小写的不同\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egrep \u003cspan class=\"s1\"\u003e\u0026#39;xxx\u0026#39;\u003c/span\u003e -i xxx.log\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"awk\"\u003eawk\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 以\u0026#39;:\u0026#39; 为分隔符,如果第五域有user则输出该行\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eawk -F \u003cspan class=\"s1\"\u003e\u0026#39;:\u0026#39;\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;{if ($5 ~ /user/) print $0}\u0026#39;\u003c/span\u003e /etc/passwd\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 统计单个文件中某个字符（串）(中文无效)出现的次数\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eawk -v \u003cspan class=\"nv\"\u003eRS\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;character\u0026#39;\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;END {print --NR}\u0026#39;\u003c/span\u003e xxx.txt\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"find\"\u003efind\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 在目录下找后缀是.mysql的文件\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003efind /home/eagleye -name \u003cspan class=\"s1\"\u003e\u0026#39;*.mysql\u0026#39;\u003c/span\u003e -print\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 会从 /usr 目录开始往下找，找最近3天之内存取过的文件。\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003efind /usr -atime \u003cspan class=\"m\"\u003e3\u003c/span\u003e –print\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 会从 /usr 目录开始往下找，找最近5天之内修改过的文件。\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003efind /usr -ctime \u003cspan class=\"m\"\u003e5\u003c/span\u003e –print\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 会从 /doc 目录开始往下找，找jacky 的、文件名开头是 j的文件。\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003efind /doc -user jacky -name \u003cspan class=\"s1\"\u003e\u0026#39;j*\u0026#39;\u003c/span\u003e –print\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 会从 /doc 目录开始往下找，找寻文件名是 ja 开头或者 ma开头的文件。\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003efind /doc \u003cspan class=\"se\"\u003e\\(\u003c/span\u003e -name \u003cspan class=\"s1\"\u003e\u0026#39;ja*\u0026#39;\u003c/span\u003e -o- -name \u003cspan class=\"s1\"\u003e\u0026#39;ma*\u0026#39;\u003c/span\u003e \u003cspan class=\"se\"\u003e\\)\u003c/span\u003e –print\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e#  会从 /doc 目录开始往下找，找到凡是文件名结尾为 bak的文件，把它删除掉。-exec 选项是执行的意思，rm 是删除命令，{ } 表示文件名，“\\;”是规定的命令结尾。\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003efind /doc -name \u003cspan class=\"s1\"\u003e\u0026#39;*bak\u0026#39;\u003c/span\u003e -exec rm \u003cspan class=\"o\"\u003e{}\u003c/span\u003e \u003cspan class=\"se\"\u003e\\;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"查看什么进程使用了该端口\"\u003e查看什么进程使用了该端口\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003elsof -i:port\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"获取本机ip地址\"\u003e获取本机ip地址\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e/sbin/ifconfig -a\u003cspan class=\"p\"\u003e|\u003c/span\u003egrep inet\u003cspan class=\"p\"\u003e|\u003c/span\u003egrep -v 127.0.0.1\u003cspan class=\"p\"\u003e|\u003c/span\u003egrep -v inet6\u003cspan class=\"p\"\u003e|\u003c/span\u003eawk \u003cspan class=\"s1\"\u003e\u0026#39;{print $2}\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003etr -d \u003cspan class=\"s2\"\u003e\u0026#34;addr:\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"iptables\"\u003eiptables\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 查看iptables状态\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eservice iptables status\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 要封停一个ip\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eiptables -I INPUT -s ***.***.***.*** -j DROP\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 要解封一个IP，使用下面这条命令：\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eiptables -D INPUT -s ***.***.***.*** -j DROP\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e备注: 参数-I是表示Insert（添加），-D表示Delete（删除）。后面跟的是规则，INPUT表示入站，***.***.***.***表示要封停的IP，DROP表示放弃连接。\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e#开启9090端口的访问\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e/sbin/iptables -I INPUT -p tcp --dport \u003cspan class=\"m\"\u003e9090\u003c/span\u003e -j ACCEPT\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 防火墙开启、关闭、重启\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e/etc/init.d/iptables status\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e/etc/init.d/iptables start\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e/etc/init.d/iptables stop\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e/etc/init.d/iptables restart\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"nc命令-tcp调试利器\"\u003enc命令, tcp调试利器\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e#给某一个endpoint发送TCP请求,就将data的内容发送到对端\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003enc 192.168.0.11 \u003cspan class=\"m\"\u003e8000\u003c/span\u003e \u0026lt; data.txt\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e#nc可以当做服务器，监听某个端口号,把某一次请求的内容存储到received_data里\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003enc -l \u003cspan class=\"m\"\u003e8000\u003c/span\u003e \u0026gt; received_data\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e#上边只监听一次，如果多次可以加上-k参数\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003enc -lk \u003cspan class=\"m\"\u003e8000\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"tcpdump\"\u003etcpdump\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# dump出本机12301端口的tcp包\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003etcpdump -i em1 tcp port \u003cspan class=\"m\"\u003e12301\u003c/span\u003e -s \u003cspan class=\"m\"\u003e1500\u003c/span\u003e -w abc.pcap\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"跟踪网络路由路径\"\u003e跟踪网络路由路径\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# traceroute默认使用udp方式, 如果是-I则改成icmp方式\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003etraceroute -I www.163.com\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 从ttl第3跳跟踪\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003etraceroute -M \u003cspan class=\"m\"\u003e3\u003c/span\u003e www.163.com\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 加上端口跟踪\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003etraceroute -p \u003cspan class=\"m\"\u003e8080\u003c/span\u003e 192.168.10.11\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"ss\"\u003ess\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 显示本地打开的所有端口\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ess -l\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 显示每个进程具体打开的socket\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ess -pl\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 显示所有tcp socket\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ess -t -a\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 显示所有的UDP Socekt\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ess -u -a\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 显示所有已建立的SMTP连接\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ess -o state established \u003cspan class=\"s1\"\u003e\u0026#39;( dport = :smtp or sport = :smtp )\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 显示所有已建立的HTTP连接\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ess -o state established \u003cspan class=\"s1\"\u003e\u0026#39;( dport = :http or sport = :http )\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e找出所有连接X服务器的进程\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ess -x src /tmp/.X11-unix/*\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e列出当前socket统计信息\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ess -s\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e解释：netstat是遍历/proc下面每个PID目录，ss直接读/proc/net下面的统计信息。所以ss执行的时候消耗资源以及消耗的时间都比netstat少很多\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"netstat\"\u003enetstat\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 输出每个ip的连接数，以及总的各个状态的连接数\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003enetstat -n \u003cspan class=\"p\"\u003e|\u003c/span\u003e awk \u003cspan class=\"s1\"\u003e\u0026#39;/^tcp/ {n=split($(NF-1),array,\u0026#34;:\u0026#34;);if(n\u0026lt;=2)++S[array[(1)]];else++S[array[(4)]];++s[$NF];++N} END {for(a in S){printf(\u0026#34;%-20s %s\\n\u0026#34;, a, S[a]);++I}printf(\u0026#34;%-20s %s\\n\u0026#34;,\u0026#34;TOTAL_IP\u0026#34;,I);for(a in s) printf(\u0026#34;%-20s %s\\n\u0026#34;,a, s[a]);printf(\u0026#34;%-20s %s\\n\u0026#34;,\u0026#34;TOTAL_LINK\u0026#34;,N);}\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 统计所有连接状态,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# CLOSED：无连接是活动的或正在进行\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# LISTEN：服务器在等待进入呼叫\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# SYN_RECV：一个连接请求已经到达，等待确认\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# SYN_SENT：应用已经开始，打开一个连接\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# ESTABLISHED：正常数据传输状态\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# FIN_WAIT1：应用说它已经完成\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# FIN_WAIT2：另一边已同意释放\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# ITMED_WAIT：等待所有分组死掉\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# CLOSING：两边同时尝试关闭\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# TIME_WAIT：主动关闭连接一端还没有等到另一端反馈期间的状态\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# LAST_ACK：等待所有分组死掉\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003enetstat -n \u003cspan class=\"p\"\u003e|\u003c/span\u003e awk \u003cspan class=\"s1\"\u003e\u0026#39;/^tcp/ {++state[$NF]} END {for(key in state) print key,\u0026#34;\\t\u0026#34;,state[key]}\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 查找较多time_wait连接\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003enetstat -n\u003cspan class=\"p\"\u003e|\u003c/span\u003egrep TIME_WAIT\u003cspan class=\"p\"\u003e|\u003c/span\u003eawk \u003cspan class=\"s1\"\u003e\u0026#39;{print $5}\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003esort\u003cspan class=\"p\"\u003e|\u003c/span\u003euniq -c\u003cspan class=\"p\"\u003e|\u003c/span\u003esort -rn\u003cspan class=\"p\"\u003e|\u003c/span\u003ehead -n20\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"top\"\u003etop\u003c/h2\u003e\n\u003ch2 id=\"dmesg查看系统日志\"\u003edmesg,查看系统日志\u003c/h2\u003e\n\u003ch2 id=\"iostat磁盘io情况监控\"\u003eiostat,磁盘IO情况监控\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eiostat -xz \u003cspan class=\"m\"\u003e1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# r/s, w/s, rkB/s, wkB/s：分别表示每秒读写次数和每秒读写数据量（千字节）。读写量过大，可能会引起性能问题。\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# await：IO操作的平均等待时间，单位是毫秒。这是应用程序在和磁盘交互时，需要消耗的时间，包括IO等待和实际操作的耗时。如果这个数值过大，可能是硬件设备遇到了瓶颈或者出现故障。\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# avgqu-sz：向设备发出的请求平均数量。如果这个数值大于1，可能是硬件设备已经饱和（部分前端硬件设备支持并行写入）。\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# %util：设备利用率。这个数值表示设备的繁忙程度，经验值是如果超过60，可能会影响IO性能（可以参照IO操作平均等待时间）。如果到达100%，说明硬件设备已经饱和。\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 如果显示的是逻辑设备的数据，那么设备利用率不代表后端实际的硬件设备已经饱和。值得注意的是，即使IO性能不理想，也不一定意味这应用程序性能会不好，可以利用诸如预读取、写缓存等策略提升应用性能。\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"free内存使用情况\"\u003efree,内存使用情况\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003efree -m\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eeg:\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e     total       used       free     shared    buffers     cached\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eMem:          \u003cspan class=\"m\"\u003e1002\u003c/span\u003e        \u003cspan class=\"m\"\u003e769\u003c/span\u003e        \u003cspan class=\"m\"\u003e232\u003c/span\u003e          \u003cspan class=\"m\"\u003e0\u003c/span\u003e         \u003cspan class=\"m\"\u003e62\u003c/span\u003e        \u003cspan class=\"m\"\u003e421\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e-/+ buffers/cache:          \u003cspan class=\"m\"\u003e286\u003c/span\u003e        \u003cspan class=\"m\"\u003e715\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eSwap:          \u003cspan class=\"m\"\u003e1153\u003c/span\u003e          \u003cspan class=\"m\"\u003e0\u003c/span\u003e       \u003cspan class=\"m\"\u003e1153\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e第一部分Mem行:\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003etotal 内存总数: 1002M\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eused 已经使用的内存数: 769M\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003efree 空闲的内存数: 232M\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eshared 当前已经废弃不用,总是0\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ebuffers Buffer 缓存内存数: 62M\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ecached Page 缓存内存数:421M\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e关系：total\u003cspan class=\"o\"\u003e(\u003c/span\u003e1002M\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e used\u003cspan class=\"o\"\u003e(\u003c/span\u003e769M\u003cspan class=\"o\"\u003e)\u003c/span\u003e + free\u003cspan class=\"o\"\u003e(\u003c/span\u003e232M\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e第二部分\u003cspan class=\"o\"\u003e(\u003c/span\u003e-/+ buffers/cache\u003cspan class=\"o\"\u003e)\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e-buffers/cache\u003cspan class=\"o\"\u003e)\u003c/span\u003e used内存数：286M \u003cspan class=\"o\"\u003e(\u003c/span\u003e指的第一部分Mem行中的used – buffers – cached\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e+buffers/cache\u003cspan class=\"o\"\u003e)\u003c/span\u003e free内存数: 715M \u003cspan class=\"o\"\u003e(\u003c/span\u003e指的第一部分Mem行中的free + buffers + cached\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e可见-buffers/cache反映的是被程序实实在在吃掉的内存,而+buffers/cache反映的是可以挪用的内存总数.\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e第三部分是指交换分区\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"sar查看网络吞吐状态\"\u003esar,查看网络吞吐状态\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# sar命令在这里可以查看网络设备的吞吐率。在排查性能问题时，可以通过网络设备的吞吐量，判断网络设备是否已经饱和\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esar -n DEV \u003cspan class=\"m\"\u003e1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# sar命令在这里用于查看TCP连接状态，其中包括：\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# active/s：每秒本地发起的TCP连接数，既通过connect调用创建的TCP连接；\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# passive/s：每秒远程发起的TCP连接数，即通过accept调用创建的TCP连接；\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# retrans/s：每秒TCP重传数量；\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# TCP连接数可以用来判断性能问题是否由于建立了过多的连接，进一步可以判断是主动发起的连接，还是被动接受的连接。TCP重传可能是因为网络环境恶劣，或者服务器压力过大导致丢包\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esar -n TCP,ETCP \u003cspan class=\"m\"\u003e1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"vmstat-给定时间监控cpu使用率-内存使用-虚拟内存交互-io读写\"\u003evmstat, 给定时间监控CPU使用率, 内存使用, 虚拟内存交互, IO读写\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 2表示每2秒采集一次状态信息, 1表示只采集一次(忽略既是一直采集)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003evmstat \u003cspan class=\"m\"\u003e2\u003c/span\u003e \u003cspan class=\"m\"\u003e1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"Linux 代码片段"},{"content":"\u0026lt;repositories\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;public\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;aliyun nexus\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;http://maven.aliyun.com/nexus/content/groups/public/\u0026lt;/url\u0026gt; \u0026lt;releases\u0026gt; \u0026lt;enabled\u0026gt;true\u0026lt;/enabled\u0026gt; \u0026lt;/releases\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;/repositories\u0026gt; \u0026lt;pluginRepositories\u0026gt; \u0026lt;pluginRepository\u0026gt; \u0026lt;id\u0026gt;public\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;aliyun nexus\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;http://maven.aliyun.com/nexus/content/groups/public/\u0026lt;/url\u0026gt; \u0026lt;releases\u0026gt; \u0026lt;enabled\u0026gt;true\u0026lt;/enabled\u0026gt; \u0026lt;/releases\u0026gt; \u0026lt;snapshots\u0026gt; \u0026lt;enabled\u0026gt;false\u0026lt;/enabled\u0026gt; \u0026lt;/snapshots\u0026gt; \u0026lt;/pluginRepository\u0026gt; \u0026lt;/pluginRepositories\u0026gt; ","permalink":"https://lesanouo.github.io/blog/posts/snippet/maven-aliyun-nexus/","summary":"\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-xml\" data-lang=\"xml\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nt\"\u003e\u0026lt;repositories\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nt\"\u003e\u0026lt;repository\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"nt\"\u003e\u0026lt;id\u0026gt;\u003c/span\u003epublic\u003cspan class=\"nt\"\u003e\u0026lt;/id\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"nt\"\u003e\u0026lt;name\u0026gt;\u003c/span\u003ealiyun nexus\u003cspan class=\"nt\"\u003e\u0026lt;/name\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"nt\"\u003e\u0026lt;url\u0026gt;\u003c/span\u003ehttp://maven.aliyun.com/nexus/content/groups/public/\u003cspan class=\"nt\"\u003e\u0026lt;/url\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"nt\"\u003e\u0026lt;releases\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\u003cspan class=\"nt\"\u003e\u0026lt;enabled\u0026gt;\u003c/span\u003etrue\u003cspan class=\"nt\"\u003e\u0026lt;/enabled\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"nt\"\u003e\u0026lt;/releases\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nt\"\u003e\u0026lt;/repository\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nt\"\u003e\u0026lt;/repositories\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nt\"\u003e\u0026lt;pluginRepositories\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nt\"\u003e\u0026lt;pluginRepository\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"nt\"\u003e\u0026lt;id\u0026gt;\u003c/span\u003epublic\u003cspan class=\"nt\"\u003e\u0026lt;/id\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"nt\"\u003e\u0026lt;name\u0026gt;\u003c/span\u003ealiyun nexus\u003cspan class=\"nt\"\u003e\u0026lt;/name\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"nt\"\u003e\u0026lt;url\u0026gt;\u003c/span\u003ehttp://maven.aliyun.com/nexus/content/groups/public/\u003cspan class=\"nt\"\u003e\u0026lt;/url\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"nt\"\u003e\u0026lt;releases\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\u003cspan class=\"nt\"\u003e\u0026lt;enabled\u0026gt;\u003c/span\u003etrue\u003cspan class=\"nt\"\u003e\u0026lt;/enabled\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"nt\"\u003e\u0026lt;/releases\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"nt\"\u003e\u0026lt;snapshots\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\u003cspan class=\"nt\"\u003e\u0026lt;enabled\u0026gt;\u003c/span\u003efalse\u003cspan class=\"nt\"\u003e\u0026lt;/enabled\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"nt\"\u003e\u0026lt;/snapshots\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nt\"\u003e\u0026lt;/pluginRepository\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nt\"\u003e\u0026lt;/pluginRepositories\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"Maven 阿里云镜像"},{"content":"本文为个人学习和实践 Nginx 的笔记\nNginx 常用功能 Nginx 有以下几个常用功能\n反向代理\n这是它的主要功能之一，客户端向服务器发送请求时，会先通过 Nginx 服务器，由服务器将请求分发到相应的Web服务器。正向代理是代理客户端，而反向代理则是代理服务器，Nginx 在提供反向代理服务方面，通过使用正则表达式进行相关配置，采取不同的转发策略，配置相当灵活，而且在配置后端转发请求时，完全不用关心网络环境如何，可以指定任意的IP地址和端口号，或其他类型的连接、请求等。\n负载均衡\n这也是 Nginx 最常用的功能之一，负载均衡，一方面是将单一的重负载分担到多个网络节点上做并行处理，每个节点处理结束后将结果汇总返回给用户，这样可以大幅度提高网络系统的处理能力；另一方面将大量的前端并发请求或数据流量分担到多个后端网络节点分别处理，这样可以有效减少前端用户等待相应的时间。而 Nginx 负载均衡都是属于后一方面，主要是对大量前端访问或流量进行分流，已保证前端用户访问效率，并可以减少后端服务器处理压力。\nWeb缓存\n在很多优秀的网站中，Nginx 可以作为前置缓存服务器，它被用于缓存前端请求，从而提高 Web服务器的性能。Nginx 会对用户已经访问过的内容在服务器本地建立副本，这样在一段时间内再次访问该数据，就不需要通过 Nginx 服务器向后端发出请求。减轻网络拥堵，减小数据传输延时，提高用户访问速度。\nNginx 安装 下载地址 Nginx 下载地址：http://nginx.org/en/download.html\nWindows 版本安装 解压下载的文件后\n下面对上面文件夹进行介绍：\nconf 目录：存放 Nginx 的主要配置文件，很多功能实现都是通过配置该目录下的 nginx.conf 文件，后面我们会详细介绍。 docs目录：存放 Nginx 服务器的主要文档资料，包括 Nginx 服务器的 LICENSE、OpenSSL 的 LICENSE 、PCRE 的 LICENSE 以及 zlib 的 LICENSE ，还包括本版本的 Nginx服务器升级的版本变更说明，以及 README 文档。 html目录：存放了两个后缀名为 .html 的静态网页文件，这两个文件与 Nginx 服务器的运行相关。 logs目录：存放 Nginx 服务器运行的日志文件。 nginx.exe：启动 Nginx 服务器的exe文件，如果 conf 目录下的 nginx.conf 文件配置正确的话，通过该文件即可启动 Nginx 服务器。 关闭 nginx 的方法：\n进入到 nginx 目录并且输入以下命令：nginx.exe -s stop\nLinux 版本安装 首先需要安装 nginx 的依赖环境：\nyum install gcc-c++ yum install -y pcre pcre-devel yum install -y zlib zlib-devel yum install -y openssl openssl-devel 对于 gcc，因为安装nginx需要先将官网下载的源码进行编译，编译依赖gcc环境，如果没有gcc环境的话，需要安装gcc。 对于 pcre，prce(Perl Compatible Regular Expressions)是一个Perl库，包括 perl 兼容的正则表达式库。nginx的http模块使用pcre来解析正则表达式，所以需要在linux上安装pcre库。 对于 zlib，zlib库提供了很多种压缩和解压缩的方式，nginx使用zlib对http包的内容进行gzip，所以需要在linux上安装zlib库。 对于 openssl，OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及SSL协议，并提供丰富的应用程序供测试或其它目的使用。nginx不仅支持http协议，还支持https（即在ssl协议上传输http），所以需要在linux安装openssl库。 编译及安装：\n1. 首先将下载的文件放到 Linux 系统中，然后解压： tar -zxvf nginx-1.14.0.tar.gz 2. 接着进入解压之后的目录进行编译安装 ./configure --prefix=/usr/local/nginx make make install 3. 进入到/usr/local/nginx目录，再进入sbin目录，通过以下命令启动nginx: ./nginx 通过 ps -ef | grep nginx 查看nginx的进程 4. 关闭nginx： 快速关闭：cd /usr/local/nginx/sbin ./nginx -s stop 相当于直接kill掉nginx的进程id 平缓关闭：cd /usr/local/nginx/sbin ./nginx -s quit 等nginx服务处理完所有请求后再关闭连接，停止工作 5. 重启nginx 先停止再启动：./nginx -s quit ./nginx 重新加载配置文件：./nginx -s reload 6. 检测配置文件语法是否正确 指定需要检测的配置文件：nginx -t -c /usr/local/nginx/conf/nginx.conf 检测默认nginx.conf配置文件：nginx -t nginx.conf 配置文件 根据默认配置文件，我们可以将nginx.conf配置文件分为三部分：\n全局块 从配置文件开始到 events 块之间的内容，主要会设置一些影响 nginx 服务器整体运行的配置指令，主要包括配置运行 Nginx 服务器的用户（组）、允许生成的 worker process 数，进程 PID 存放路径、日志存放路径和类型以及配置文件的引入等。\n比如：worker_processes 1; 这是Nginx服务器并发处理服务的关键配置，worker_processes 值越大，可以支持的并发处理量也越多，但是会受到硬件、软件等设备的制约。\nevents 块 比如：\nevents {\rworker_connections 1024;\r} events 块涉及的指令主要影响 Nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 work process 下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 word process 可以同时支持的最大连接数等。\n上述例子就表示每个 work process 支持的最大连接数为 1024.\n这部分的配置对 Nginx 的性能影响较大，在实际中应该灵活配置。\nhttp 块 http {\rinclude mime.types;\rdefault_type application/octet-stream;\rsendfile on;\rkeepalive_timeout 65;\rserver {\rlisten 80;\rserver_name localhost;\rlocation / {\rroot html;\rindex index.html index.htm;\r}\rerror_page 500 502 503 504 /50x.html;\rlocation = /50x.html {\rroot html;\r}\r}\r} 这是Nginx服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。\nhttp 块也可以包括 http全局块、server 块：\nhttp全局块\nhttp全局块配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。\nserver块\n这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了节省互联网服务器硬件成本。后面会详细介绍虚拟主机的概念。\n每个 http 块可以包括多个 server 块，而每个 server 块就相当于一个虚拟主机。\n而每个 server 块也分为全局 server 块，以及可以同时包含多个 locaton 块。\n全局server块：最常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或IP配置。\nlocation块：一个 server 块可以配置多个 location 块。\n这块的主要作用是基于 Nginx 服务器接收到的请求字符串（例如 server_name/uri-string），对虚拟主机名称（也可以是IP别名）之外的字符串（例如 前面的 /uri-string）进行匹配，对特定的请求进行处理。地址定向、数据缓存和应答控制等功能，还有许多第三方模块的配置也在这里进行。\n反向代理 代理定义 Nginx 主要能够代理如下几种协议，其中用到的最多的就是做Http代理服务器。\n在Java设计模式中，代理模式是这样定义的：给某个对象提供一个代理对象，并由代理对象控制原对象的引用。\n代理简单来说，就是如果我们想做什么，但又不想直接去做，那么这时候就找另外一个人帮我们去做。那么这个例子里面的中介公司就是给我们做代理服务的，我们委托中介公司帮我们找房子。\n正向代理定义 弄清楚什么是代理了，那么什么又是正向代理呢？\n这里我再举一个例子：大家都知道，现在国内是访问不了 Google的，那么怎么才能访问 Google呢？我们又想，美国人不是能访问 Google吗（这不废话，Google就是美国的），如果我们电脑的对外公网 IP 地址能变成美国的 IP 地址，那不就可以访问 Google了。你很聪明，VPN 就是这样产生的。我们在访问 Google 时，先连上 VPN 服务器将我们的 IP 地址变成美国的 IP 地址，然后就可以顺利的访问了。\n这里的 VPN 就是做正向代理的。正向代理服务器位于客户端和服务器之间，为了向服务器获取数据，客户端要向代理服务器发送一个请求，并指定目标服务器，代理服务器将目标服务器返回的数据转交给客户端。这里客户端是要进行一些正向代理的设置的。\nPS：这里介绍一下什么是 VPN，VPN 通俗的讲就是一种中转服务，当我们电脑接入 VPN 后，我们对外 IP 地址就会变成 VPN 服务器的 公网 IP，我们请求或接受任何数据都会通过这个VPN 服务器然后传入到我们本机。这样做有什么好处呢？比如 VPN 游戏加速方面的原理，我们要玩网通区的 LOL，但是本机接入的是电信的宽带，玩网通区的会比较卡，这时候就利用 VPN 将电信网络变为网通网络，然后在玩网通区的LOL就不会卡了（注意：VPN 是不能增加带宽的，不要以为不卡了是因为网速提升了）。\n可能听到这里大家还是很抽象，没关系，和下面的反向代理对比理解就简单了。\n反向代理定义 反向代理和正向代理的区别就是：正向代理代理客户端，反向代理代理服务器。\n反向代理，其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器IP地址。\n下面我们通过两张图来对比正向代理和方向代理：\n理解这两种代理的关键在于代理服务器所代理的对象是什么，正向代理代理的是客户端，我们需要在客户端进行一些代理的设置。而反向代理代理的是服务器，作为客户端的我们是无法感知到服务器的真实存在的。\n总结起来还是一句话：正向代理代理客户端，反向代理代理服务器。\nNginx 反向代理 相关指令 listen 该指令用于配置网络监听。主要有如下三种配置语法结构：\n① 配置监听的IP地址\nlisten address[:port] [default_server] [setfib=number] [backlog=number] [rcvbuf=size] [sndbuf=size] [deferred] [accept_filter=filter] [bind] [ssl];\n② 配置监听端口\nlisten port [default_server] [setfib=number] [backlog=number] [rcvbuf=size] [sndbuf=size] [accept_filter=filter] [deffered] [bind] [ipv6only=on|off] [ssl];\n③ 配置 UNIX Domain Socket\nlisten unix:path [default_server] [backlog=number] [rcvbuf=size] [sndbuf=size] [accept_filter=filter] [deffered] [bind] [ssl]\n上面的配置看似比较复杂，其实使用起来是比较简单的：\nlisten *:80 | *:8080 #监听所有80端口和8080端口\rlisten IP_address:port #监听指定的地址和端口号\rlisten IP_address #监听指定ip地址所有端口\rlisten port #监听该端口的所有IP连接 下面分别解释每个选项的具体含义：\n1、address:IP地址，如果是 IPV6地址，需要使用中括号[] 括起来，比如[fe80::1]等。\n2、port:端口号，如果只定义了IP地址，没有定义端口号，那么就使用80端口。\n3、path:socket文件路径，如 var/run/nginx.sock等。\n4、default_server:标识符，将此虚拟主机设置为 address:port 的默认主机。（在 nginx-0.8.21 之前使用的是 default 指令）\n5、 setfib=number:Nginx-0.8.44 中使用这个变量监听 socket 关联路由表，目前只对 FreeBSD 起作用，不常用。\n6、backlog=number:设置监听函数listen()最多允许多少网络连接同时处于挂起状态，在 FreeBSD 中默认为 -1,其他平台默认为511.\n7、rcvbuf=size:设置监听socket接收缓存区大小。\n8、sndbuf=size:设置监听socket发送缓存区大小。\n9、deferred:标识符，将accept()设置为Deferred模式。\n10、accept_filter=filter:设置监听端口对所有请求进行过滤，被过滤的内容不能被接收和处理，本指令只在 FreeBSD 和 NetBSD 5.0+ 平台下有效。filter 可以设置为 dataready 或 httpready 。\n11、bind:标识符，使用独立的bind() 处理此address:port，一般情况下，对于端口相同而IP地址不同的多个连接，Nginx 服务器将只使用一个监听指令，并使用 bind() 处理端口相同的所有连接。\n12、ssl:标识符，设置会话连接使用 SSL模式进行，此标识符和Nginx服务器提供的 HTTPS 服务有关。\nserver_name 该指令用于虚拟主机的配置。通常分为以下两种：\n1、基于名称的虚拟主机配置\n语法格式如下：\nserver_name name ...; 一、对于name 来说，可以只有一个名称，也可以有多个名称，中间用空格隔开。而每个名字由两段或者三段组成，每段之间用“.”隔开。\nserver_name 123.com www.123.com 二、可以使用通配符“*”，但通配符只能用在由三段字符组成的首段或者尾端，或者由两端字符组成的尾端。\nserver_name *.123.com www.123.* 三、还可以使用正则表达式，用“~”作为正则表达式字符串的开始标记。\nserver_name ~^www\\d+\\.123\\.com$; 该表达式“”表示匹配正则表达式，以www开头（“^”表示开头），紧跟着一个09之间的数字，在紧跟“.123.co”，最后跟着“m”($表示结尾)\n以上匹配的顺序优先级如下：\n1 ①、准确匹配 server_name\r2 ②、通配符在开始时匹配 server_name 成功\r3 ③、通配符在结尾时匹配 server_name 成功\r4 ④、正则表达式匹配 server_name 成功 2、基于 IP 地址的虚拟主机配置\n语法结构和基于域名匹配一样，而且不需要考虑通配符和正则表达式的问题。\nserver_name 192.168.1.1 location 该指令用于匹配 URL。\n语法如下：\nlocation [ = | ~ | ~* | ^~] uri {\r} 1、= ：用于不含正则表达式的 uri 前，要求请求字符串与 uri 严格匹配，如果匹配成功，就停止继续向下搜索并立即处理该请求。\n2、~：用于表示 uri 包含正则表达式，并且区分大小写。\n3、~*：用于表示 uri 包含正则表达式，并且不区分大小写。\n4、^~：用于不含正则表达式的 uri 前，要求 Nginx 服务器找到标识 uri 和请求字符串匹配度最高的 location 后，立即使用此 location 处理请求，而不再使用 location 块中的正则 uri 和请求字符串做匹配。\n注意：如果 uri 包含正则表达式，则必须要有 ~ 或者 ~* 标识。\nproxy_pass 该指令用于设置被代理服务器的地址。可以是主机名称、IP地址加端口号的形式。\n语法结构如下：\nproxy_pass URL; URL 为被代理服务器的地址，可以包含传输协议、主机名称或IP地址加端口号，URI等。\nproxy_pass http://www.123.com/uri; index 该指令用于设置网站的默认首页。\n语法为：\nindex filename ...; 后面的文件名称可以有多个，中间用空格隔开。\nindex index.html index.jsp; 通常该指令有两个作用：第一个是用户在请求访问网站时，请求地址可以不写首页名称；第二个是可以对一个请求，根据请求内容而设置不同的首页。\n配置案例 server {\rlisten 80;\rserver_name localhost;\rcharset utf-8;\rlocation / {\rroot /home/ruoyi/projects/ruoyi-ui;\rtry_files $uri $uri/ /index.html;\rindex index.html index.htm;\r}\rlocation /prod-api/ {\rproxy_set_header Host $http_host;\rproxy_set_header X-Real-IP $remote_addr;\rproxy_set_header REMOTE-HOST $remote_addr;\rproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\rproxy_pass http://localhost:8080/;\r}\rerror_page 500 502 503 504 /50x.html;\rlocation = /50x.html {\rroot html;\r}\r} 负载均衡 负载均衡的由来 早期的系统架构，基本上都是如下形式的：\n客户端发送多个请求到服务器，服务器处理请求，有一些可能要与数据库进行交互，服务器处理完毕后，再将结果返回给客户端。\n这种架构模式对于早期的系统相对单一，并发请求相对较少的情况下是比较适合的，成本也低。但是随着信息数量的不断增长，访问量和数据量的飞速增长，以及系统业务的复杂度增加，这种架构会造成服务器相应客户端的请求日益缓慢，并发量特别大的时候，还容易造成服务器直接崩溃。很明显这是由于服务器性能的瓶颈造成的问题，那么如何解决这种情况呢？\n我们首先想到的可能是升级服务器的配置，比如提高CPU执行频率，加大内存等提高机器的物理性能来解决此问题，但是我们知道摩尔定律的日益失效，硬件的性能提升已经不能满足日益提升的需求了。最明显的一个例子，天猫双十一当天，某个热销商品的瞬时访问量是极其庞大的，那么类似上面的系统架构，将机器都增加到现有的顶级物理配置，都是不能够满足需求的。那么怎么办呢？\n上面的分析我们去掉了增加服务器物理配置来解决问题的办法，也就是说纵向解决问题的办法行不通了，那么横向增加服务器的数量呢？这时候集群的概念产生了，单个服务器解决不了，我们增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负载均衡。\n负载均衡完美的解决了单个服务器硬件性能瓶颈的问题，但是随着而来的如何实现负载均衡呢？客户端怎么知道要将请求发送到那个服务器去处理呢？\nNginx 实现负载均衡 Nginx 服务器是介于客户端和服务器之间的中介，通过上一节的反向代理的功能，客户端发送的请求先经过 Nginx ，然后通过 Nginx 将请求根据相应的规则分发到相应的服务器。\n主要配置指令为上一讲的 pass_proxy 指令以及 upstream 指令。负载均衡主要通过专门的硬件设备或者软件算法实现。通过硬件设备实现的负载均衡效果好、效率高、性能稳定，但是成本较高。而通过软件实现的负载均衡主要依赖于均衡算法的选择和程序的健壮性。均衡算法又主要分为两大类：\n静态负载均衡算法：主要包括轮询算法、基于比率的加权轮询算法或者基于优先级的加权轮询算法。\n动态负载均衡算法：主要包括基于任务量的最少连接优化算法、基于性能的最快响应优先算法、预测算法及动态性能分配算法等。\n静态负载均衡算法在一般网络环境下也能表现的比较好，动态负载均衡算法更加适用于复杂的网络环境。\n例子：\n普通轮询算法 upstream OrdinaryPolling {\rserver 127.0.0.1:8080;\rserver 127.0.0.1:8081;\r}\rserver {\rlisten 80;\rserver_name localhost;\rlocation / {\rproxy_pass http://OrdinaryPolling;\rindex index.html index.htm index.jsp;\r}\r} 基于比例加权轮询 upstream OrdinaryPolling {\rserver 127.0.0.1:8080 weight=5;\rserver 127.0.0.1:8081 weight=2;\r}\rserver {\rlisten 80;\rserver_name localhost;\rlocation / {\rproxy_pass http://OrdinaryPolling;\rindex index.html index.htm index.jsp;\r}\r} 基于IP路由负载 我们知道一个请求在经过一个服务器处理时，服务器会保存相关的会话信息，比如session，但是该请求如果第一个服务器没处理完，通过nginx轮询到第二个服务器上，那么这个服务器是没有会话信息的。\n最典型的一个例子：用户第一次进入一个系统是需要进行登录身份验证的，首先将请求跳转到Tomcat1服务器进行处理，登录信息是保存在Tomcat1 上的，这时候需要进行别的操作，那么可能会将请求轮询到第二个Tomcat2上，那么由于Tomcat2 没有保存会话信息，会以为该用户没有登录，然后继续登录一次，如果有多个服务器，每次第一次访问都要进行登录，这显然是很影响用户体验的。\n这里产生的一个问题也就是集群环境下的 session 共享，如何解决这个问题？\n通常由两种方法：\n1、第一种方法是选择一个中间件，将登录信息保存在一个中间件上，这个中间件可以为 Redis 这样的数据库。那么第一次登录，我们将session 信息保存在 Redis 中，跳转到第二个服务器时，我们可以先去Redis上查询是否有登录信息，如果有，就能直接进行登录之后的操作了，而不用进行重复登录。\n2、第二种方法是根据客户端的IP地址划分，每次都将同一个 IP 地址发送的请求都分发到同一个 Tomcat 服务器，那么也不会存在 session 共享的问题。\n而 nginx 的基于 IP 路由负载的机制就是上诉第二种形式。大概配置如下：\nupstream OrdinaryPolling {\rip_hash;\rserver 127.0.0.1:8080 weight=5;\rserver 127.0.0.1:8081 weight=2;\r}\rserver {\rlisten 80;\rserver_name localhost;\rlocation / {\rproxy_pass http://OrdinaryPolling;\rindex index.html index.htm index.jsp;\r}\r}\r注意：我们在 upstream 指令块中增加了 ip_hash 指令。该指令就是告诉 nginx 服务器，同一个 IP 地址客户端发送的请求都将分发到同一个 Tomcat 服务器进行处理。 基于服务器响应时间负载分配 根据服务器处理请求的时间来进行负载，处理请求越快，也就是响应时间越短的优先分配。\nupstream OrdinaryPolling {\rserver 127.0.0.1:8080 weight=5;\rserver 127.0.0.1:8081 weight=2;\rfair;\r}\rserver {\rlisten 80;\rserver_name localhost;\rlocation / {\rproxy_pass http://OrdinaryPolling;\rindex index.html index.htm index.jsp;\r}\r}\r通过增加了 fair 指令。 对不同域名实现负载均衡 通过配合location 指令块我们还可以实现对不同域名实现负载均衡。\nupstream wordbackend {\rserver 127.0.0.1:8080;\rserver 127.0.0.1:8081;\r}\rupstream pptbackend {\rserver 127.0.0.1:8082;\rserver 127.0.0.1:8083;\r}\rserver {\rlisten 80;\rserver_name localhost;\rlocation /word/ {\rproxy_pass http://wordbackend;\rindex index.html index.htm index.jsp;\r}\rlocation /ppt/ {\rproxy_pass http://pptbackend;\rindex index.html index.htm index.jsp;\r}\r} 引用 以上学习笔记多处摘录自网络\nhttps://www.cnblogs.com/ysocean/p/9392912.html\n","permalink":"https://lesanouo.github.io/blog/posts/code/164494080001/","summary":"\u003cp\u003e本文为个人学习和实践 Nginx 的笔记\u003c/p\u003e\n\u003ch2 id=\"nginx-常用功能\"\u003eNginx 常用功能\u003c/h2\u003e\n\u003cp\u003eNginx 有以下几个常用功能\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e反向代理\u003c/p\u003e\n\u003cp\u003e这是它的主要功能之一，客户端向服务器发送请求时，会先通过 Nginx 服务器，由服务器将请求分发到相应的Web服务器。正向代理是代理客户端，而反向代理则是代理服务器，Nginx 在提供反向代理服务方面，通过使用正则表达式进行相关配置，采取不同的转发策略，配置相当灵活，而且在配置后端转发请求时，完全不用关心网络环境如何，可以指定任意的IP地址和端口号，或其他类型的连接、请求等。\u003c/p\u003e","title":"Nginx笔记"},{"content":"本篇文章是学习leetcode中链表相关算法总结的链表技巧。\n虚拟头节点 力扣第 21 题「合并两个有序链表」 ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) { ListNode *head = new ListNode(-1), *p = head; while (l1 \u0026amp;\u0026amp; l2) { if (l1-\u0026gt;val \u0026lt; l2-\u0026gt;val) { p-\u0026gt;next = l1; l1 = l1-\u0026gt;next; } else { p-\u0026gt;next = l2; l2 = l2-\u0026gt;next; } p = p-\u0026gt;next; } p-\u0026gt;next = l1 ? l1 : l2; return head-\u0026gt;next; } 这个算法的逻辑类似于「拉拉链」，l1, l2 类似于拉链两侧的锯齿，指针 p 就好像拉链的拉索，将两个有序链表合并\nListNode *head = new ListNode(-1), *p = head;中使用到了虚拟头节点，如果不使用虚拟节点，代码会复杂很多，而有了 head 节点这个占位符，可以避免处理空指针的情况，降低代码的复杂性\n优先队列 力扣第 23 题「合并K个升序链表」 struct cmp { bool operator()(ListNode *p1, ListNode *p2) { return p1-\u0026gt;val \u0026gt; p2-\u0026gt;val; } }; ListNode *mergeKLists(vector\u0026lt;ListNode *\u0026gt; \u0026amp;lists) { if (lists.size() == 0) return nullptr; ListNode *head = new ListNode(-1), *tail = head; priority_queue\u0026lt;ListNode *, vector\u0026lt;ListNode *\u0026gt;, cmp\u0026gt; pq; for (auto i : lists) { if (i) pq.push(i); } while (!pq.empty()) { ListNode *node = pq.top(); pq.pop(); tail-\u0026gt;next = node; tail = tail-\u0026gt;next; if (node-\u0026gt;next) pq.push(node-\u0026gt;next); } return head-\u0026gt;next; } 这里我们就要用到 优先级队列 这种数据结构，把链表节点放入一个最小堆，就可以每次获得 k 个节点中的最小节点\n它的时间复杂度是多少呢？\n优先队列 pq 中的元素个数最多是 k，所以一次 poll 或者 add 方法的时间复杂度是 O(logk)；所有的链表节点都会被加入和弹出 pq，所以算法整体的时间复杂度是 O(Nlogk)，其中 k 是链表的条数，N 是这些链表的节点总数。\n单链表的倒数第k个节点 力扣第 19 题「删除链表的倒数第 N 个结点」 ListNode *removeNthFromEnd(ListNode *head, int n) { ListNode *dummy = new ListNode(-1); dummy-\u0026gt;next = head; auto temp = FindFromEnd(dummy, n + 1); temp-\u0026gt;next = temp-\u0026gt;next-\u0026gt;next; return dummy-\u0026gt;next; } ListNode *FindFromEnd(ListNode *head, int n) { ListNode *first = head, *second = head; while (n--) { first = first-\u0026gt;next; } while (first) { first = first-\u0026gt;next; second = second-\u0026gt;next; } return second; } 首先，我们先让一个指针 p1 指向链表的头节点 head，然后走 k 步 现在的 p1，只要再走 n - k 步，就能走到链表末尾的空指针了对吧？趁这个时候，再用一个指针 p2 指向链表头节点 head 接下来就很显然了，让 p1 和 p2 同时向前走，p1 走到链表末尾的空指针时走了 n - k 步，p2 也走了 n - k 步，也就是链表的倒数第 k 个节点 这样，只遍历了一次链表，就获得了倒数第 k 个节点 p2 不过注意我们又使用了虚拟头结点的技巧，也是为了防止出现空指针的情况，比如说链表总共有 5 个节点，题目就让你删除倒数第 5 个节点，也就是第一个节点，那按照算法逻辑，应该首先找到倒数第 6 个节点。但第一个节点前面已经没有节点了，这就会出错。\n但有了我们虚拟节点 dummy 的存在，就避免了这个问题，能够对这种情况进行正确的删除。\n双指针 力扣第 876 题「链表的中间结点」 如果想一次遍历就得到中间节点，也需要耍点小聪明，使用「快慢指针」的技巧：\n我们让两个指针 slow 和 fast 分别指向链表头结点 head。\n每当慢指针 slow 前进一步，快指针 fast 就前进两步，这样，当 fast 走到链表末尾时，slow 就指向了链表中点。\nListNode *middleNode(ListNode *head) { ListNode *slow = head, *fast = head; while (fast \u0026amp;\u0026amp; fast-\u0026gt;next) { slow = slow-\u0026gt;next; fast = fast-\u0026gt;next-\u0026gt;next; } return slow; } 力扣第 141 题「环形链表」 判断链表是否包含环属于经典问题了，解决方案也是用快慢指针：\n每当慢指针 slow 前进一步，快指针 fast 就前进两步。\n如果 fast 最终遇到空指针，说明链表中没有环；如果 fast 最终和 slow 相遇，那肯定是 fast 超过了 slow 一圈，说明链表中含有环。\nbool hasCycle(ListNode *head) { ListNode *slow = head, *fast = head; while (fast \u0026amp;\u0026amp; fast-\u0026gt;next) { slow = slow-\u0026gt;next; fast = fast-\u0026gt;next-\u0026gt;next; if (slow == fast) return true; } return false; } 当然，这个问题还有进阶版：如果链表中含有环，如何计算这个环的起点？\n这里简单提一下解法：\nListNode detectCycle(ListNode head) { ListNode fast, slow; fast = slow = head; while (fast != null \u0026amp;\u0026amp; fast.next != null) { fast = fast.next.next; slow = slow.next; if (fast == slow) break; } // 上面的代码类似 hasCycle 函数 if (fast == null || fast.next == null) { // fast 遇到空指针说明没有环 return null; } // 重新指向头结点 slow = head; // 快慢指针同步前进，相交点就是环起点 while (slow != fast) { fast = fast.next; slow = slow.next; } return slow; } 力扣第 160 题「相交链表」 ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { ListNode *A = headA, *B = headB; while (A != B) { if (A) A = A-\u0026gt;next; else A = headB; if (B) B = B-\u0026gt;next; else B = headA; } return A; } 如果用两个指针 p1 和 p2 分别在两条链表上前进，并不能同时走到公共节点，也就无法得到相交节点 c1。\n解决这个问题的关键是，通过某些方式，让 p1 和 p2 能够同时到达相交节点 c1。\n所以，我们可以让 p1 遍历完链表 A 之后开始遍历链表 B，让 p2 遍历完链表 B 之后开始遍历链表 A，这样相当于「逻辑上」两条链表接在了一起。\n如果这样进行拼接，就可以让 p1 和 p2 同时进入公共部分，也就是同时到达相交节点 c1：\n那你可能会问，如果说两个链表没有相交点，是否能够正确的返回 null 呢？\n这个逻辑可以覆盖这种情况的，相当于 c1 节点是 null 空指针嘛，可以正确返回 null。\n这样，这道题就解决了，空间复杂度为 O(1)，时间复杂度为 O(N)。\n","permalink":"https://lesanouo.github.io/blog/posts/code/164312640001/","summary":"\u003cp\u003e本篇文章是学习leetcode中链表相关算法总结的链表技巧。\u003c/p\u003e\n\u003ch2 id=\"虚拟头节点\"\u003e虚拟头节点\u003c/h2\u003e\n\u003ch3 id=\"力扣第-21-题合并两个有序链表\"\u003e力扣第 21 题「合并两个有序链表」\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eListNode\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"nf\"\u003emergeTwoLists\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eListNode\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003el1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eListNode\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003el2\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eListNode\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003ehead\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"n\"\u003eListNode\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003ep\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ehead\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ewhile\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003el1\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan class=\"n\"\u003el2\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003el1\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eval\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003el2\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eval\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003enext\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003el1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003el1\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003el1\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003enext\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003eelse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003enext\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003el2\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003el2\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003el2\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003enext\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003ep\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003enext\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003enext\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003el1\u003c/span\u003e \u003cspan class=\"o\"\u003e?\u003c/span\u003e \u003cspan class=\"nl\"\u003el1\u003c/span\u003e \u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"n\"\u003el2\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003ehead\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003enext\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e这个算法的逻辑类似于「拉拉链」，\u003ccode\u003el1, l2\u003c/code\u003e 类似于拉链两侧的锯齿，指针 \u003ccode\u003ep\u003c/code\u003e 就好像拉链的拉索，将两个有序链表合并\u003c/p\u003e","title":"算法学习-链表"},{"content":"安装Hugo 到 Hugo Releases 下载对应的操作系统版本的Hugo二进制文件（hugo或者hugo.exe）\nMac下直接使用 Homebrew 安装：\nbrew install hugo 生成站点 使用Hugo快速生成站点，比如希望生成到 /path/to/site 路径：\n$ hugo new site /path/to/site 这样就在 /path/to/site 目录里生成了初始站点，进去目录：\n$ cd /path/to/site 站点目录结构：\n▸ archetypes/\r▸ content/\r▸ layouts/\r▸ static/\rconfig.toml 创建文章 创建一个 about 页面：\n$ hugo new about.md about.md 自动生成到了 content/about.md ，打开 about.md 看下：\n+++\rdate = \u0026#34;2015-10-25T08:36:54-07:00\u0026#34;\rdraft = true\rtitle = \u0026#34;about\u0026#34;\r+++\r正文内容 内容是 Markdown 格式的，+++ 之间的内容是 TOML 格式的，根据你的喜好，你可以换成 YAML 格式（使用 --- 标记）或者 JSON 格式。\n创建第一篇文章，放到 post 目录，方便之后生成聚合页面。\n$ hugo new post/first.md 安装皮肤 到 皮肤列表 挑选一个心仪的皮肤，比如你觉得 Hyde 皮肤不错，找到相关的 GitHub 地址，创建目录 themes，在 themes 目录里把皮肤 git clone 下来：\n# 创建 themes 目录 $ cd themes $ git clone https://github.com/spf13/hyde.git 运行Hugo 在你的站点根目录执行 Hugo 命令进行调试：\n$ hugo server --theme=hyde --buildDrafts 若在config.toml设置了theme和buildDrafts：\n$ hugo server 浏览器里打开： http://localhost:1313\n部署 假设你需要部署在 GitHub Pages 上，首先在GitHub上创建一个Repository，命名为：coderzh.github.io（coderzh替换为你的github用户名）。\n在站点根目录执行 Hugo 命令生成最终页面：\n$ hugo --theme=hyde --baseUrl=\u0026#34;http://coderzh.github.io/\u0026#34; 或者 $ hugo （注意，以上命令并不会生成草稿页面，如果未生成任何文章，请去掉文章头部的 draft=true 再重新生成。）\n如果一切顺利，所有静态页面都会生成到 public 目录，将pubilc目录里所有文件 push 到刚创建的Repository的 master 分支。\n浏览器里访问：http://coderzh.github.io/\n其他相关 关于文章内容 它使您可以直接包含内容的元数据。Hugo支持几种不同的格式，每种格式都有自己的识别令牌。\n支持的格式：\nTOML，以“+++”标识。 YAML，由“---”标识。 JSON，一个单独的JSON对象，由\u0026rsquo;{\u0026lsquo;和\u0026rsquo;}\u0026lsquo;包围，每行各自。 YAML Example --- title: \u0026#34;spf13-vim 3.0 release and new website\u0026#34; description: \u0026#34;spf13-vim is a cross platform distribution of vim plugins and resources for Vim.\u0026#34; tags: [ \u0026#34;.vimrc\u0026#34;, \u0026#34;plugins\u0026#34;, \u0026#34;spf13-vim\u0026#34;, \u0026#34;vim\u0026#34; ] lastmod: 2015-12-23 date: \u0026#34;2012-04-06\u0026#34; categories: - \u0026#34;Development\u0026#34; - \u0026#34;VIM\u0026#34; slug: \u0026#34;spf13-vim-3-0-release-and-new-website\u0026#34; --- Content of the file goes Here Required variables title The title for the content description The description for the content date The date the content will be sorted by taxonomies These will use the field name of the plural form of the index (see tags and categories above) Optional variables aliases An array of one or more aliases (e.g. old published path of a renamed content) that would be created to redirect to this content. See Aliases for details. draft If true, the content will not be rendered unless hugo is called with --buildDrafts publishdate If in the future, content will not be rendered unless hugo is called with --buildFuture type The type of the content (will be derived from the directory automatically if unset) isCJKLanguage If true, explicitly treat the content as CJKLanguage (.Summary and .WordCount can work properly in CJKLanguage) weight Used for sorting markup (Experimental) Specify \u0026quot;rst\u0026quot; for reStructuredText (requires rst2html) or \u0026quot;md\u0026quot; (default) for Markdown slug The token to appear in the tail of the URL, or url The full path to the content from the web root. If neither slug or url is present, the filename will be used.\n关于配置 通常的使用情况下，一个网站并不需要一个配置文件，因为它的目录结构和模板就提供了主要的配置。\nHugo 需要在源目录查找一个 config.toml 的配置文件。如果这个文件不存在，将会查找 config.yaml，然后是 config.json 。\n这个配置文件是一个整站的配置。它给 Hugo 提供了如何构建站点的方式，比如全局的参数和菜单。\n配置变量 下面是 Hugo 定义好的变量列表，以及他们的默认值，你可以设置他们：\n---\rarchetypedir: \u0026#34;archetype\u0026#34;\r# hostname (and path) to the root, e.g. http://spf13.com/\rbaseURL: \u0026#34;\u0026#34;\r# include content marked as draft\rbuildDrafts: false\r# include content with publishdate in the future\rbuildFuture: false\r# enable this to make all relative URLs relative to content root. Note that this does not affect absolute URLs.\rrelativeURLs: false\rcanonifyURLs: false\r# config file (default is path/config.yaml|json|toml)\rconfig: \u0026#34;config.toml\u0026#34;\rcontentdir: \u0026#34;content\u0026#34;\rdataDir: \u0026#34;data\u0026#34;\rdefaultExtension: \u0026#34;html\u0026#34;\rdefaultLayout: \u0026#34;post\u0026#34;\rdisableLiveReload: false\r# Do not build RSS files\rdisableRSS: false\r# Do not build Sitemap file\rdisableSitemap: false\r# edit new content with this editor, if provided\reditor: \u0026#34;\u0026#34;\rfootnoteAnchorPrefix: \u0026#34;\u0026#34;\rfootnoteReturnLinkContents: \u0026#34;\u0026#34;\r# google analytics tracking id\rgoogleAnalytics: \u0026#34;\u0026#34;\rlanguageCode: \u0026#34;\u0026#34;\rlayoutdir: \u0026#34;layouts\u0026#34;\r# Enable Logging\rlog: false\r# Log File path (if set, logging enabled automatically)\rlogFile: \u0026#34;\u0026#34;\r# \u0026#34;yaml\u0026#34;, \u0026#34;toml\u0026#34;, \u0026#34;json\u0026#34;\rmetaDataFormat: \u0026#34;toml\u0026#34;\rnewContentEditor: \u0026#34;\u0026#34;\r# Don\u0026#39;t sync modification time of files\rnoTimes: false\rpaginate: 10\rpaginatePath: \u0026#34;page\u0026#34;\rpermalinks:\r# Pluralize titles in lists using inflect\rpluralizeListTitles: true\r# Preserve special characters in taxonomy names (\u0026#34;Gérard Depardieu\u0026#34; vs \u0026#34;Gerard Depardieu\u0026#34;)\rpreserveTaxonomyNames: false\r# filesystem path to write files to\rpublishdir: \u0026#34;public\u0026#34;\r# color-codes for highlighting derived from this style\rpygmentsStyle: \u0026#34;monokai\u0026#34;\r# true: use pygments-css or false: color-codes directly\rpygmentsUseClasses: false\r# default sitemap configuration map\rsitemap:\r# filesystem path to read files relative from\rsource: \u0026#34;\u0026#34;\rstaticdir: \u0026#34;static\u0026#34;\r# display memory and timing of different steps of the program\rstepAnalysis: false\r# theme to use (located in /doc/themes/THEMENAME/)\rtheme: \u0026#34;\u0026#34;\rtitle: \u0026#34;\u0026#34;\r# if true, use /filename.html instead of /filename/\ruglyURLs: false\r# Do not make the url/path to lowercase\rdisablePathToLower: false\r# if true, auto-detect Chinese/Japanese/Korean Languages in the content. (.Summary and .WordCount can work properly in CJKLanguage)\rhasCJKLanguage false\r# verbose output\rverbose: false\r# verbose logging\rverboseLog: false\r# watch filesystem for changes and recreate as needed\rwatch: true\r--- ","permalink":"https://lesanouo.github.io/blog/posts/code/160269120001/","summary":"\u003ch3 id=\"安装hugo\"\u003e安装Hugo\u003c/h3\u003e\n\u003cp\u003e到 \u003ca href=\"https://github.com/spf13/hugo/releases\"\u003eHugo Releases\u003c/a\u003e 下载对应的操作系统版本的Hugo二进制文件（hugo或者hugo.exe）\u003c/p\u003e\n\u003cp\u003eMac下直接使用 \u003ccode\u003eHomebrew\u003c/code\u003e 安装：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ebrew install hugo\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"生成站点\"\u003e生成站点\u003c/h3\u003e\n\u003cp\u003e使用Hugo快速生成站点，比如希望生成到 \u003ccode\u003e/path/to/site\u003c/code\u003e 路径：\u003c/p\u003e","title":"Hugo个人静态网页生成"},{"content":"本文主要介绍如何通过GitHub+Vercel免费搭建一个自己的静态网页。\nGitHub Pages GitHub Pages是GitHub提供给大家的快速部署静态网页的功能，但是由于国内访问比较慢，这里提供一个相对较快的解决办法，就是用GitHub+Vercel。\n第一步：注册登录Vercel 我想大家应该都有GitHub账号吧，这里就不多说了。\n点击Vercel官网,并使用GitHub登录。\n注意⚠️：GitHub账号不要使用QQ邮箱作为主邮箱。如果已经用QQ邮箱注册了GitHub，可以到Setting -\u0026gt; Emails里修改自己的主邮箱。\n第二步：导入仓库 它会让你选择一种登录Vercel的方法，支持使用GitHub，GitLab和Bitbucket登录，这里我们选GitHub，后面就是无脑Next的步骤。\n顺利的话稍等片刻就会弹出部署成功的页面，还有浮夸的撒花。\n部署完成之后可以点击visit进入网页看看效果。\n第三步：配置域名 1.点击view Domains进行绑定自己的域名或者点击 Settings👉Domains👉输入自己的域名\n2.输入自己的域名，然后点Add，它会弹出来一些需要做的配置，接下来需要去我们的域名提供商那里根据Vercel给出的要求进行配置。需要修改的有：Name Servers以及域名解析\n最后等待等这两个改动都生效之后就可以用我们自己的域名访问刚刚建立的网站啦~\n以后想要修改网站的话，只需要将改动push到GitHub上，vercel会自动把改动同步过来，完全不用管，超省心。\n在一级域名配置好之后，也可以直接在vercel中使用二级域名，无需进行额外设置。\n","permalink":"https://lesanouo.github.io/blog/posts/code/160260480001/","summary":"\u003cp\u003e本文主要介绍如何通过GitHub+Vercel免费搭建一个自己的静态网页。\u003c/p\u003e\n\u003ch3 id=\"github-pages\"\u003eGitHub Pages\u003c/h3\u003e\n\u003cp\u003eGitHub Pages是GitHub提供给大家的快速部署静态网页的功能，但是由于国内访问比较慢，这里提供一个相对较快的解决办法，就是用GitHub+Vercel。\u003c/p\u003e","title":"搭建个人网站:GitHub+Vercel"},{"content":"一、写前准备 在atom文本编译器中自带着markdown的编写与浏览功能。 浏览使用快捷键ctl+shift+m就可以打开markdown预览。 简书中在设置-\u0026gt;默认编辑器-\u0026gt;markdown编译，就可以设置markdown。\n二、标题 在想要设置为标题的文字前面加#来表示标题 一个#号是以及标题，两个#是二级标题，最多有六级标题 标准语法需要在#后加空格才能表示\n三、字体 加粗 在要加粗的文字左右分别用两个*标注 斜体 在要倾斜的文字左右分别用一个*标注 斜体加粗 在要倾斜和加粗的文字左右分别用三个*标注 删除线 在要加删除线的文字左右分别用两个～标注 例如：\n**加粗字体**\r*斜体字体*\r***斜体加粗字体***\r~~删除字体~~ 效果：\n加粗字体，斜体字体，斜体加粗字体，删除字体\n四、引用 在引用文字前加\u0026gt;。引用可以嵌套，如一个\u0026gt;、两个\u0026gt;等等\n例如:\n这是一段引用\n五、分割线 三个或三个以上的-或者* 例：\n---\r*** 效果:\n六、图片 使用方法：\n![图片alt](图片地址 \u0026#39;\u0026#39;图片title\u0026#39;\u0026#39;)\r图片alt就是显示在图片下面的文字，相当于对图片内容的解释。\r图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 七、超链接 使用方法：\n[超链接名](超链接地址 \u0026#34;超链接title\u0026#34;) title可加可不加 注：Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替。\n\u0026lt;a href=\u0026#34;超链接地址\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;超链接名\u0026lt;/a\u0026gt;\r示例\r\u0026lt;a href=\u0026#34;https://www.jianshu.com/u/1f5ac0cf6a8b\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;简书\u0026lt;/a\u0026gt; 八、列表 无序列表 使用方法：无序列表用 - + * 任何一种都可以\n- 列表内容\r+ 列表内容\r* 列表内容\r注意：- + * 跟内容之间都要有一个空格 有序列表 使用方法：数字加点\n1.列表内容\r2.列表内容\r3.列表内容\r注意：序号跟内容之间要有空格 列表嵌套 使用方法：上一级和下一级之间敲三个空格\n九、表格 使用方法：\n| 表头 | 表头 | 表头 |\r| ---- | :---: | ---: |\r| 内容 | 内容 | 内容 |\r| 内容 | 内容 | 内容 |\r第二行分割表头和内容。\r-有一个就行\r文字默认居左\r-两边加：表示文字居中\r-右边加：表示文字居右\r注：原生的语法两边都要用 | 包起来。此处省略 效果：\n表头 表头 表头 内容 内容 内容 内容 内容 内容 十、代码 使用方法：\n单行代码：代码之间分别用一个反引号包起来 代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行 代码高亮：在第一行反引号后面输入代码块所使用的语言\n代码高亮演示：\n`c\r#include \u0026#34;stdio.h\u0026#34;\rint main(){\rprintf(\u0026#34;hello world\\n\u0026#34;);\rreturn 0;\r}\r`\r#include \u0026#34;stdio.h\u0026#34;\rint main(){\rprintf(\u0026#34;hello world\\n\u0026#34;);\rreturn 0;\r} 十一、流程图 使用方法：\nst=\u0026gt;start: 开始\rop=\u0026gt;operation: My Operation\rcond=\u0026gt;condition: Yes or No?\re=\u0026gt;end\rst-\u0026gt;op-\u0026gt;cond\rcond(yes)-\u0026gt;e\rcond(no)-\u0026gt;op 十二、数学表达式 用$将数学表达式包裹:\n$E = mc^2$\n十三、待办事项 在待办的事项文本或者清单文本前加上- 、- [x]即可\n- [ ] 表示未完成，- [x] 表示已完成。\r注：键入字符与字符之间都要保留一个字符的空格。 效果\n分析需求 研发 测试 结语 Markdown换行方法：\n在本行最后敲两个空格即可 每行间空一行即可 Mac上反引号方法： 在英文状态下按住option键+数字1左边的键\n本文章为个人学习笔记，转载了多人的博客，如有雷同请见谅。\n","permalink":"https://lesanouo.github.io/blog/posts/code/160243200001/","summary":"\u003ch2 id=\"一写前准备\"\u003e一、写前准备\u003c/h2\u003e\n\u003cp\u003e在atom文本编译器中自带着markdown的编写与浏览功能。\n浏览使用快捷键ctl+shift+m就可以打开markdown预览。\n简书中在设置-\u0026gt;默认编辑器-\u0026gt;markdown编译，就可以设置markdown。\u003c/p\u003e","title":"Markdown语法"},{"content":"😀😁😂🤣😃😄😅😆\n","permalink":"https://lesanouo.github.io/blog/about/","summary":"about","title":"👨‍💻 关于我"}]