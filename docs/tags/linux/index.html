<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Linux | Lesan's Blog</title><meta name=keywords content><meta name=description content="Lesan's Blog"><meta name=author content="Lesan"><link rel=canonical href=https://lesanouo.github.io/blog/tags/linux/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://lesanouo.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://lesanouo.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://lesanouo.github.io/blog/favicon.ico><link rel=apple-touch-icon href=https://lesanouo.github.io/blog/favicon.ico><link rel=mask-icon href=https://lesanouo.github.io/blog/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://lesanouo.github.io/blog/tags/linux/index.xml><link rel=alternate hreflang=zh-cn href=https://lesanouo.github.io/blog/tags/linux/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:url" content="https://lesanouo.github.io/blog/tags/linux/"><meta property="og:site_name" content="Lesan's Blog"><meta property="og:title" content="Linux"><meta property="og:description" content="Lesan's Blog"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Linux"><meta name=twitter:description content="Lesan's Blog"></head><body class="list dark" id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://lesanouo.github.io/blog/ accesskey=h title="Lesan's Blog (Alt + H)">Lesan's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://lesanouo.github.io/blog/archives title="📚 归档"><span>📚 归档</span></a></li><li><a href=https://lesanouo.github.io/blog/categories/ title="🗃️ 分类"><span>🗃️ 分类</span></a></li><li><a href=https://lesanouo.github.io/blog/tags/ title="🏷️ 标签"><span>🏷️ 标签</span></a></li><li><a href=https://lesanouo.github.io/blog/search/ title="🔎 搜索"><span>🔎 搜索</span></a></li><li><a href=https://lesanouo.github.io/blog/about/ title="👨‍💻 关于我"><span>👨‍💻 关于我</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://lesanouo.github.io/blog/>Home</a>&nbsp;»&nbsp;<a href=https://lesanouo.github.io/blog/tags/>🏷️ 标签</a></div><h1>Linux
<a href=/blog/tags/linux/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Linux系统使用systemd配置.NET项目开机自启动</h2></header><div class=entry-content><p>本片文章记录在Linux（CentOS7）中如何使用systemctl命令进行系统和服务管理
systemctl命令 # 设置开机自启动，可在任意目录下执行 systemctl enable xxx.service # 启动nginx服务 systemctl start xxx.service # 停止开机自启动 systemctl disable xxx.service # 查看服务当前状态 systemctl status xxx.service # 重新启动服务 systemctl restart xxx.service # 查看所有已启动的服务 systemctl list-units --type=service 创建xxx.service 在/etc/systemd/system/路径下，新增一个myTest.service文件，文件内容如下
...</p></div><footer class=entry-footer><span title='2024-04-28 00:00:00 +0000 UTC'>2024-04-28</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Lesan</footer><a class=entry-link aria-label="post link to Linux系统使用systemd配置.NET项目开机自启动" href=https://lesanouo.github.io/blog/posts/171423360001/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>CentOS7系统安装</h2></header><div class=entry-content><p>本片文章记录个人安装CentOS7在台式主机上作为小型服务器
制作U盘启动盘 1. iso镜像下载 可以通过阿里云镜像站下载iso文件，本人下载的是CentOS-7-x86_64-DVD-2009.iso
2. 下载启动盘制作软件 可以通过软件UltraISO进行启动盘制作
打开软件 -> 点击左上角文件 -> 选择打开 -> 打开对应iso 点击菜单栏启动 -> 选择写入硬盘镜像 选择对应U盘 -> 其余参数可默认 安装CentOS7 1. 插入U盘到主机 2. 配置 Bios 制作U盘启动 3. 选择对应U盘后即可开始安装 注意事项 通过UltraISO刻入后安装会报错，无法正常安装 选择Install CentOS 7时按下TAB键，屏幕下方会出现一串文字 vmlinuz initrd=initrd.img inst.stage2=hd:LABEL=CentOS\x207\x20x86_64 rd.live.check quiet
...</p></div><footer class=entry-footer><span title='2022-12-01 00:00:00 +0000 UTC'>2022-12-01</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Lesan</footer><a class=entry-link aria-label="post link to CentOS7系统安装" href=https://lesanouo.github.io/blog/posts/166982400001/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Linux中修改Docker存储位置</h2></header><div class=entry-content><p>在维护服务器时，发现docker所在盘容量已满，导致mongodb插入数据失败从而崩溃。由此记录修改Linux中Dockder位置时遇到的问题
...</p></div><footer class=entry-footer><span title='2022-07-02 00:00:00 +0000 UTC'>2022-07-02</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Lesan</footer><a class=entry-link aria-label="post link to Linux中修改Docker存储位置" href=https://lesanouo.github.io/blog/posts/165669120001/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Linux增加SSH端口</h2></header><div class=entry-content><p>简介 在大型企业中，服务器网络一般都会有各种各样的限制，常见的就会有堡垒机或者运维网关，以达到操作审计等目的。但对于开发者来讲，这些限制大大降低了效率，所以我们需要一个方便的方式来解决这个问题。
...</p></div><footer class=entry-footer><span title='2022-05-21 00:00:00 +0000 UTC'>2022-05-21</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Lesan</footer><a class=entry-link aria-label="post link to Linux增加SSH端口" href=https://lesanouo.github.io/blog/posts/165306240001/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Linux 代码片段</h2></header><div class=entry-content><p>Linux关机,重启 # 关机 shutdown -h now # 重启 shutdown -r now 查看系统,CPU信息 # 查看系统内核信息 uname -a # 查看系统内核版本 cat /proc/version # 查看当前用户环境变量 env cat /proc/cpuinfo # 查看有几个逻辑cpu, 包括cpu型号 cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c # 查看有几颗cpu,每颗分别是几核 cat /proc/cpuinfo | grep physical | uniq -c # 查看当前CPU运行在32bit还是64bit模式下, 如果是运行在32bit下也不代表CPU不支持64bit getconf LONG_BIT # 结果大于0, 说明支持64bit计算. lm指long mode, 支持lm则是64bit cat /proc/cpuinfo | grep flags | grep ' lm ' | wc -l 建立软连接 ln -s /usr/local/jdk1.8/ jdk rpm相关 # 查看是否通过rpm安装了该软件 rpm -qa | grep 软件名 sshkey # 创建sshkey ssh-keygen -t rsa -C your_email@example.com #id_rsa.pub 的内容拷贝到要控制的服务器的 home/username/.ssh/authorized_keys 中,如果没有则新建(.ssh权限为700, authorized_keys权限为600) 命令重命名 # 在各个用户的.bash_profile中添加重命名配置 alias ll='ls -alF' 同步服务器时间 sudo ntpdate -u ntp.api.bz 后台运行 # 后台运行,并且有nohup.out输出 nohup xxx & # 后台运行, 不输出任何日志 nohup xxx > /dev/null & # 后台运行, 并将错误信息做标准输出到日志中 nohup xxx >out.log 2>&amp;1 & 强制活动用户退出 # 命令来完成强制活动用户退出.其中TTY表示终端名称 pkill -kill -t [TTY] 查看命令路径 which &lt;命令> 查看进程所有打开最大fd数 ulimit -n 配置dns vim /etc/resolv.conf nslookup,查看域名路由表 nslookup google.com last,最近登录信息列表 # 最近登录的5个账号 last -n 5 设置固定ip ifconfig em1 192.168.5.177 netmask 255.255.255.0 查看进程内加载的环境变量 # 也可以去 cd /proc 目录下, 查看进程内存中加载的东西 ps eww -p XXXXX(进程号) 查看进程树找到服务器进程 ps auwxf 查看进程启动路径 cd /proc/xxx(进程号) ls -all # cwd对应的是启动路径 添加用户,配置sudo权限 # 新增用户 useradd 用户名 passwd 用户名 #增加sudo权限 vim /etc/sudoers # 修改文件里面的 # root ALL=(ALL) ALL # 用户名 ALL=(ALL) ALL 强制关闭进程名包含xxx的所有进程 ps aux|grep xxx | grep -v grep | awk '{print $2}' | xargs kill -9 vim操作 #normal模式下 g表示全局, x表示查找的内容, y表示替换后的内容 :%s/x/y/g #normal模式下 0 # 光标移到行首(数字0) $ # 光标移至行尾 shift + g # 跳到文件最后 gg # 跳到文件头 # 显示行号 :set nu # 去除行号 :set nonu # 检索 /xxx(检索内容) # 从头检索, 按n查找下一个 ?xxx(检索内容) # 从尾部检索 打开只读文件,修改后需要保存时(不用切换用户即可保存的方式) # 在normal模式下 :w !sudo tee % 查看磁盘, 文件目录基本信息 # 查看磁盘挂载情况 mount # 查看磁盘分区信息 df # 查看目录及子目录大小 du -H -h # 查看当前目录下各个文件, 文件夹占了多少空间, 不会递归 du -sh * wc命令 # 查看文件里有多少行 wc -l filename # 看文件里有多少个word wc -w filename # 文件里最长的那一行是多少个字 wc -L filename # 统计字节数 wc -c 压缩命令 tar czvf xxx.tar 压缩目录 zip -r xxx.zip 压缩目录 解压缩命令 tar zxvf xxx.tar # 解压到指定文件夹 tar zxvf xxx.tar -C /xxx/yyy/ unzip xxx.zip 变更文件所属用户, 用户组 chown eagleye.eagleye xxx.log cp, scp, mkdir #复制 cp xxx.log # 复制并强制覆盖同名文件 cp -f xxx.log # 复制文件夹 cp -r xxx(源文件夹) yyy(目标文件夹) # 远程复制 scp -P ssh端口 username@10.10.10.101:/home/username/xxx /home/xxx # 级联创建目录 mkdir -p /xxx/yyy/zzz # 批量创建文件夹, 会在test,main下都创建java, resources文件夹 mkdir -p src/{test,main}/{java,resources} 比较两个文件 diff -u 1.txt 2.txt 日志输出的字节数,可以用作性能测试 # 如果做性能测试, 可以每执行一次, 往日志里面输出 “.” , 这样日志中的字节数就是实际的性能测试运行的次数, 还可以看见实时速率. tail -f xxx.log | pv -bt 查看, 去除特殊字符 # 查看特殊字符 cat -v xxx.sh # 去除特殊字符 sed -i 's/^M//g’ env.sh 去除文件的特殊字符, 比如^M: 需要这样输入: ctrl+v+enter 处理因系统原因引起的文件中特殊字符的问题 # 可以转换为该系统下的文件格式 cat file.sh > file.sh_bak # 先将file.sh中文件内容复制下来然后运行, 然后粘贴内容, 最后ctrl + d 保存退出 cat > file1.sh # 在vim中通过如下设置文件编码和文件格式 :set fileencodings=utf-8 ，然后 w （存盘）一下即可转化为 utf8 格式， :set fileformat=unix # 在mac下使用dos2unix进行文件格式化 find . -name "*.sh" | xargs dos2unix tee, 重定向的同时输出到屏幕 awk ‘{print $0}’ xxx.log | tee test.log grep # 反向匹配, 查找不包含xxx的内容 grep -v xxx # 排除所有空行 grep -v '^/pre>' # 返回结果 2,则说明第二行是空行 grep -n “^$” 111.txt # 查询以abc开头的行 grep -n “^abc” 111.txt # 同时列出该词语出现在文章的第几行 grep 'xxx' -n xxx.log # 计算一下该字串出现的次数 grep 'xxx' -c xxx.log # 比对的时候，不计较大小写的不同 grep 'xxx' -i xxx.log awk # 以':' 为分隔符,如果第五域有user则输出该行 awk -F ':' '{if ($5 ~ /user/) print $0}' /etc/passwd # 统计单个文件中某个字符（串）(中文无效)出现的次数 awk -v RS='character' 'END {print --NR}' xxx.txt find # 在目录下找后缀是.mysql的文件 find /home/eagleye -name '*.mysql' -print # 会从 /usr 目录开始往下找，找最近3天之内存取过的文件。 find /usr -atime 3 –print # 会从 /usr 目录开始往下找，找最近5天之内修改过的文件。 find /usr -ctime 5 –print # 会从 /doc 目录开始往下找，找jacky 的、文件名开头是 j的文件。 find /doc -user jacky -name 'j*' –print # 会从 /doc 目录开始往下找，找寻文件名是 ja 开头或者 ma开头的文件。 find /doc \( -name 'ja*' -o- -name 'ma*' \) –print # 会从 /doc 目录开始往下找，找到凡是文件名结尾为 bak的文件，把它删除掉。-exec 选项是执行的意思，rm 是删除命令，{ } 表示文件名，“\;”是规定的命令结尾。 find /doc -name '*bak' -exec rm {} \; 查看什么进程使用了该端口 lsof -i:port 获取本机ip地址 /sbin/ifconfig -a|grep inet|grep -v 127.0.0.1|grep -v inet6|awk '{print $2}'|tr -d "addr:" iptables # 查看iptables状态 service iptables status # 要封停一个ip iptables -I INPUT -s ***.***.***.*** -j DROP # 要解封一个IP，使用下面这条命令： iptables -D INPUT -s ***.***.***.*** -j DROP 备注: 参数-I是表示Insert（添加），-D表示Delete（删除）。后面跟的是规则，INPUT表示入站，***.***.***.***表示要封停的IP，DROP表示放弃连接。 #开启9090端口的访问 /sbin/iptables -I INPUT -p tcp --dport 9090 -j ACCEPT # 防火墙开启、关闭、重启 /etc/init.d/iptables status /etc/init.d/iptables start /etc/init.d/iptables stop /etc/init.d/iptables restart nc命令, tcp调试利器 #给某一个endpoint发送TCP请求,就将data的内容发送到对端 nc 192.168.0.11 8000 &lt; data.txt #nc可以当做服务器，监听某个端口号,把某一次请求的内容存储到received_data里 nc -l 8000 > received_data #上边只监听一次，如果多次可以加上-k参数 nc -lk 8000 tcpdump # dump出本机12301端口的tcp包 tcpdump -i em1 tcp port 12301 -s 1500 -w abc.pcap 跟踪网络路由路径 # traceroute默认使用udp方式, 如果是-I则改成icmp方式 traceroute -I www.163.com # 从ttl第3跳跟踪 traceroute -M 3 www.163.com # 加上端口跟踪 traceroute -p 8080 192.168.10.11 ss # 显示本地打开的所有端口 ss -l # 显示每个进程具体打开的socket ss -pl # 显示所有tcp socket ss -t -a # 显示所有的UDP Socekt ss -u -a # 显示所有已建立的SMTP连接 ss -o state established '( dport = :smtp or sport = :smtp )' # 显示所有已建立的HTTP连接 ss -o state established '( dport = :http or sport = :http )' 找出所有连接X服务器的进程 ss -x src /tmp/.X11-unix/* 列出当前socket统计信息 ss -s 解释：netstat是遍历/proc下面每个PID目录，ss直接读/proc/net下面的统计信息。所以ss执行的时候消耗资源以及消耗的时间都比netstat少很多 netstat # 输出每个ip的连接数，以及总的各个状态的连接数 netstat -n | awk '/^tcp/ {n=split($(NF-1),array,":");if(n&lt;=2)++S[array[(1)]];else++S[array[(4)]];++s[$NF];++N} END {for(a in S){printf("%-20s %s\n", a, S[a]);++I}printf("%-20s %s\n","TOTAL_IP",I);for(a in s) printf("%-20s %s\n",a, s[a]);printf("%-20s %s\n","TOTAL_LINK",N);}' # 统计所有连接状态, # CLOSED：无连接是活动的或正在进行 # LISTEN：服务器在等待进入呼叫 # SYN_RECV：一个连接请求已经到达，等待确认 # SYN_SENT：应用已经开始，打开一个连接 # ESTABLISHED：正常数据传输状态 # FIN_WAIT1：应用说它已经完成 # FIN_WAIT2：另一边已同意释放 # ITMED_WAIT：等待所有分组死掉 # CLOSING：两边同时尝试关闭 # TIME_WAIT：主动关闭连接一端还没有等到另一端反馈期间的状态 # LAST_ACK：等待所有分组死掉 netstat -n | awk '/^tcp/ {++state[$NF]} END {for(key in state) print key,"\t",state[key]}' # 查找较多time_wait连接 netstat -n|grep TIME_WAIT|awk '{print $5}'|sort|uniq -c|sort -rn|head -n20 top dmesg,查看系统日志 iostat,磁盘IO情况监控 iostat -xz 1 # r/s, w/s, rkB/s, wkB/s：分别表示每秒读写次数和每秒读写数据量（千字节）。读写量过大，可能会引起性能问题。 # await：IO操作的平均等待时间，单位是毫秒。这是应用程序在和磁盘交互时，需要消耗的时间，包括IO等待和实际操作的耗时。如果这个数值过大，可能是硬件设备遇到了瓶颈或者出现故障。 # avgqu-sz：向设备发出的请求平均数量。如果这个数值大于1，可能是硬件设备已经饱和（部分前端硬件设备支持并行写入）。 # %util：设备利用率。这个数值表示设备的繁忙程度，经验值是如果超过60，可能会影响IO性能（可以参照IO操作平均等待时间）。如果到达100%，说明硬件设备已经饱和。 # 如果显示的是逻辑设备的数据，那么设备利用率不代表后端实际的硬件设备已经饱和。值得注意的是，即使IO性能不理想，也不一定意味这应用程序性能会不好，可以利用诸如预读取、写缓存等策略提升应用性能。 free,内存使用情况 free -m eg: total used free shared buffers cached Mem: 1002 769 232 0 62 421 -/+ buffers/cache: 286 715 Swap: 1153 0 1153 第一部分Mem行: total 内存总数: 1002M used 已经使用的内存数: 769M free 空闲的内存数: 232M shared 当前已经废弃不用,总是0 buffers Buffer 缓存内存数: 62M cached Page 缓存内存数:421M 关系：total(1002M) = used(769M) + free(232M) 第二部分(-/+ buffers/cache): (-buffers/cache) used内存数：286M (指的第一部分Mem行中的used – buffers – cached) (+buffers/cache) free内存数: 715M (指的第一部分Mem行中的free + buffers + cached) 可见-buffers/cache反映的是被程序实实在在吃掉的内存,而+buffers/cache反映的是可以挪用的内存总数. 第三部分是指交换分区 sar,查看网络吞吐状态 # sar命令在这里可以查看网络设备的吞吐率。在排查性能问题时，可以通过网络设备的吞吐量，判断网络设备是否已经饱和 sar -n DEV 1 # sar命令在这里用于查看TCP连接状态，其中包括： # active/s：每秒本地发起的TCP连接数，既通过connect调用创建的TCP连接； # passive/s：每秒远程发起的TCP连接数，即通过accept调用创建的TCP连接； # retrans/s：每秒TCP重传数量； # TCP连接数可以用来判断性能问题是否由于建立了过多的连接，进一步可以判断是主动发起的连接，还是被动接受的连接。TCP重传可能是因为网络环境恶劣，或者服务器压力过大导致丢包 sar -n TCP,ETCP 1 vmstat, 给定时间监控CPU使用率, 内存使用, 虚拟内存交互, IO读写 # 2表示每2秒采集一次状态信息, 1表示只采集一次(忽略既是一直采集) vmstat 2 1</p></div><footer class=entry-footer><span title='2022-02-16 00:00:00 +0000 UTC'>2022-02-16</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Lesan</footer><a class=entry-link aria-label="post link to Linux 代码片段" href=https://lesanouo.github.io/blog/posts/snippet/linux/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://lesanouo.github.io/blog/>Lesan's Blog</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>